,Method Code
0,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
1,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if(StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		return factory.getObject();
	}"
2,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
3,"	public String getConfig() {
		return this.config;
	}"
4,"	public void setConfig(String config) {
		this.config = config;
	}"
5,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
6,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
7,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
8,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
9,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
10,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
11,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
12,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
13,"	public Long getId() {
		return this.id;
	}"
14,"	public void setId(Long id) {
		this.id = id;
	}"
15,"	public String getName() {
		return this.name;
	}"
16,"	public void setName(String name) {
		this.name = name;
	}"
17,"	City findById(@Param(""cityId"") Long cityId);

}"
18,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
19,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
20,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
21,"	public Long getId() {
		return this.id;
	}"
22,"	public void setId(Long id) {
		this.id = id;
	}"
23,"	public String getName() {
		return this.name;
	}"
24,"	public void setName(String name) {
		this.name = name;
	}"
25,"	public String getState() {
		return this.state;
	}"
26,"	public void setState(String state) {
		this.state = state;
	}"
27,"	public String getCountry() {
		return this.country;
	}"
28,"	public void setCountry(String country) {
		this.country = country;
	}"
29,"	public String toString() {
		return ""City{"" +
				""id="" + this.id +"
30,"	City findByState(@Param(""state"") String state);

}"
31,"	public void test() {
		String output = this.out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""SAN FRANCISCO""));
	}"
32,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
33,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.selectCityById(1));
	}"
34,"	public Long getId() {
		return this.id;
	}"
35,"	public void setId(Long id) {
		this.id = id;
	}"
36,"	public String getName() {
		return this.name;
	}"
37,"	public void setName(String name) {
		this.name = name;
	}"
38,"	public String getState() {
		return this.state;
	}"
39,"	public void setState(String state) {
		this.state = state;
	}"
40,"	public String getCountry() {
		return this.country;
	}"
41,"	public void setCountry(String country) {
		this.country = country;
	}"
42,"	public String toString() {
		return ""City{"" +
				""id="" + this.id +"
43,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
44,"	public void test() {
		String output = this.out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""SAN FRANCISCO""));
	}"
45,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
46,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if(StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		return factory.getObject();
	}"
47,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
48,"	public String getConfig() {
		return this.config;
	}"
49,"	public void setConfig(String config) {
		this.config = config;
	}"
50,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
51,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
52,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
53,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
54,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
55,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
56,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
57,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
58,"	public Long getId() {
		return this.id;
	}"
59,"	public void setId(Long id) {
		this.id = id;
	}"
60,"	public String getName() {
		return this.name;
	}"
61,"	public void setName(String name) {
		this.name = name;
	}"
62,"	City findById(@Param(""cityId"") Long cityId);

}"
63,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
64,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
65,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
66,"	public Long getId() {
		return this.id;
	}"
67,"	public void setId(Long id) {
		this.id = id;
	}"
68,"	public String getName() {
		return this.name;
	}"
69,"	public void setName(String name) {
		this.name = name;
	}"
70,"	public String getState() {
		return this.state;
	}"
71,"	public void setState(String state) {
		this.state = state;
	}"
72,"	public String getCountry() {
		return this.country;
	}"
73,"	public void setCountry(String country) {
		this.country = country;
	}"
74,"	public String toString() {
		return ""City{"" +
				""id="" + this.id +"
75,"	City findByState(@Param(""state"") String state);

}"
76,"	public void test() {
		String output = this.out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""SAN FRANCISCO""));
	}"
77,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
78,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.selectCityById(1));
	}"
79,"	public Long getId() {
		return this.id;
	}"
80,"	public void setId(Long id) {
		this.id = id;
	}"
81,"	public String getName() {
		return this.name;
	}"
82,"	public void setName(String name) {
		this.name = name;
	}"
83,"	public String getState() {
		return this.state;
	}"
84,"	public void setState(String state) {
		this.state = state;
	}"
85,"	public String getCountry() {
		return this.country;
	}"
86,"	public void setCountry(String country) {
		this.country = country;
	}"
87,"	public String toString() {
		return ""City{"" +
				""id="" + this.id +"
88,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
89,"	public void test() {
		String output = this.out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""SAN FRANCISCO""));
	}"
90,"    public void checkConfigFileExists() {
        if (this.properties.isCheckConfigLocation()) {
            Resource resource = this.resourceLoader.getResource(this.properties"
91,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
        SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
        factory.setDataSource(dataSource);
        if (StringUtils.hasText(this.properties.getConfig())) {
            factory.setConfigLocation(this.resourceLoader.getResource(this.properties
                    .getConfig()));
        }
        return factory.getObject();
    }"
92,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory,
                this.properties.getExecutorType());"
93,"        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
                                            BeanDefinitionRegistry registry) {

            ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

            List<String> pkgs;
            try {
                pkgs = AutoConfigurationPackages.get(this.beanFactory);"
94,"        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
            this.beanFactory = beanFactory;
        }"
95,"        public void setResourceLoader(ResourceLoader resourceLoader) {
            this.resourceLoader = resourceLoader;
        }"
96,"        public void afterPropertiesSet() {
            log.debug(""no %s found, so "" + MapperFactoryBean.class.getName());
        }"
97,"    public void testNoDataSource() throws Exception {
        this.context = new AnnotationConfigApplicationContext();
        this.context.register(MybatisAutoConfiguration.class,
                PropertyPlaceholderAutoConfiguration.class);
        this.context.refresh();
        assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
    }"
98,"    public void testDefaultConfiguration() {
        this.context = new AnnotationConfigApplicationContext();
        this.context.register(EmbeddedDataSourceConfiguration.class,
                MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
                PropertyPlaceholderAutoConfiguration.class);
        this.context.refresh();
        assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
        assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
        assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
    }"
99,"    public void testWithConfigFile() {
        this.context = new AnnotationConfigApplicationContext();
        EnvironmentTestUtils.addEnvironment(this.context,
                ""mybatis.config:mybatis-config.xml"");
        this.context.register(EmbeddedDataSourceConfiguration.class,
                MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
                PropertyPlaceholderAutoConfiguration.class);
        this.context.refresh();
        assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
        assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
    }"
100,"    public void testDefaultBootConfiguration() {
        this.context = new AnnotationConfigApplicationContext();
        this.context.register(EmbeddedDataSourceConfiguration.class,
                MybatisBootMapperScanAutoConfiguration.class,
                MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
        this.context.refresh();
        assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
        assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
        assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
    }"
101,"        public CityMapperImpl cityMapper() {
            return new CityMapperImpl();
        }"
102,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader"
103,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(
					this.resourceLoader.getResource(this.properties.getConfig()));
		}
		return factory.getObject();
	}"
104,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
105,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
106,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
107,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
108,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
109,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
110,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
111,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
112,"	public void testDefaultBootConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
113,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
114,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader"
115,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(
					this.resourceLoader.getResource(this.properties.getConfig()));
		} else {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.getMapperLocations());
		}
		return factory.getObject();
	}"
116,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
117,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
118,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
119,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
120,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
121,"	public String getConfig() {
		return this.config;
	}"
122,"	public void setConfig(String config) {
		this.config = config;
	}"
123,"	public Resource[] getMapperLocations() {
		return this.mapperLocations;
	}"
124,"	public void setMapperLocations(Resource[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
125,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
126,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
127,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
128,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
129,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
130,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
131,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
132,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
133,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
134,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
135,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
136,"	public void testWithTypeHandlersPackage() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
137,"	public void testWithMapperLocation() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
138,"	public void testDefaultBootConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
139,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
140,"	public void setParameter(PreparedStatement ps, int i, Object parameter,
			JdbcType jdbcType) throws SQLException {
	}

	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}

	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}

	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}

}"
141,"	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}"
142,"	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}"
143,"	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}"
144,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader"
145,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(
					this.resourceLoader.getResource(this.properties.getConfig()));
		} else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.getMapperLocations());
		}
		return factory.getObject();
	}"
146,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
147,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
148,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
149,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
150,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
151,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
152,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
153,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
154,"	public void testWithTypeHandlersPackage() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
155,"	public void testWithMapperLocation() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
156,"	public void testDefaultBootConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
157,"	public void testWithInterceptors() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
	}"
158,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
159,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
160,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
161,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
162,"		public void setProperties(Properties properties) {

		}
	}

}"
163,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader"
164,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(
					this.resourceLoader.getResource(this.properties.getConfig()));
		} else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}
		return factory.getObject();
	}"
165,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
166,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
167,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
168,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
169,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
170,"	public String getConfig() {
		return this.config;
	}"
171,"	public void setConfig(String config) {
		this.config = config;
	}"
172,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
173,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
174,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
175,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
176,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
177,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
178,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
179,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
180,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
181,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
182,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation: this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
183,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
184,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
185,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
186,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
187,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		// Try to locate for VendorDatabaseIdProvider bean
		if (databaseIdProvider != null) {
			log.info(""Bean with DatabaseIdProvider interface found. Setting up SqlSessionFactory with it."");
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		else {
			log.info(""No bean with DatabaseIdProvider interface found."");
		}

		return factory.getObject();
	}"
188,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
189,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
190,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
191,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
192,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
193,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
194,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			if (this.databaseIdProvider != null) {
				factory.setDatabaseIdProvider(this.databaseIdProvider);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
195,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
196,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
197,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
198,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
199,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
200,"	public void testNoDataSource() throws Exception {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
201,"	public void testDefaultConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
202,"	public void testWithConfigFile() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
203,"	public void testWithTypeHandlersPackage() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
204,"	public void testWithMapperLocation() {
		this.context = new AnnotationConfigApplicationContext();
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
205,"	public void testDefaultBootConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
206,"	public void testWithInterceptors() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
	}"
207,"	public void testWithDatabaseIdProvider() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
208,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
209,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
210,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
211,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
212,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
213,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
214,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
215,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
216,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
217,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
218,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
219,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
220,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
221,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
222,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
223,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
	}"
224,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
225,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
226,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
227,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
228,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
229,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
230,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
231,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
232,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
233,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			if (this.databaseIdProvider != null) {
				factory.setDatabaseIdProvider(this.databaseIdProvider);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
234,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
235,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
236,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
237,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
238,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
239,"    public boolean isValid() {
        return true;
    }"
240,"    protected List<String> list(URL url, String path) throws IOException {
        ClassLoader cl = this.getClass().getClassLoader();
        ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
        Resource[] resources = resolver.getResources(path + ""/**/*.class"");
        List<Resource> resources1 = Arrays.asList(resources);
        List<String> resourcePaths = new ArrayList<String>();
        for (Resource resource: resources1) {
            resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
        }
        return resourcePaths;
    }"
241,"    private static String preserveSubpackageName(final URI uri, final String rootPath) {
        final String uriStr = uri.toString();
        final int start = uriStr.indexOf(rootPath);
        return uriStr.substring(start, uriStr.length());
    }"
242,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
243,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
244,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
245,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
246,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
247,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
248,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
249,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
250,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
251,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
252,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
253,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
254,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
255,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
256,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
257,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
258,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
259,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
260,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		if (this.interceptors != null && this.interceptors.length > 0) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (this.properties.getTypeAliasesPackage() != null) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (this.properties.getTypeHandlersPackage() != null) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (this.properties.getMapperLocations() != null) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
261,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
262,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
263,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
264,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
265,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
266,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
267,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
268,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
269,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
270,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
271,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
272,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
273,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
274,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
275,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
276,"	public void testWithXmlConfigAndDatabaseProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
277,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
278,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
279,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
280,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
281,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
282,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
283,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
284,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
285,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			if (this.databaseIdProvider != null) {
				factory.setDatabaseIdProvider(this.databaseIdProvider);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
286,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
287,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
288,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
289,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
290,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
291,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
292,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
293,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
294,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
295,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
296,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
297,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
298,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
299,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
300,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
301,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
302,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
303,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
304,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
305,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
306,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
307,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
308,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
309,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			if (this.databaseIdProvider != null) {
				factory.setDatabaseIdProvider(this.databaseIdProvider);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
310,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType() != null ?"
311,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
312,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
313,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
314,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
315,"	public String getConfig() {
		return this.config;
	}"
316,"	public void setConfig(String config) {
		this.config = config;
	}"
317,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
318,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
319,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
320,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
321,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
322,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
323,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
324,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
325,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
326,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
327,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation: this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
328,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
329,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
330,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
331,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
332,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
333,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
334,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
335,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.executorType:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
336,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
337,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
338,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
339,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
340,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
341,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
342,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
343,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
344,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
345,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
346,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
347,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
348,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
349,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType()); // use a default executor type(SIMPLE)
	}"
350,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType()); // use a executor type that specify on config file
	}"
351,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
352,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
353,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.executorType:REUSE""); // use a executor type that specify on spring's properties(or yaml)
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
354,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
355,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
356,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
357,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
358,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
359,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
360,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
361,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
362,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
363,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
364,"    public boolean isValid() {
        return true;
    }"
365,"    protected List<String> list(URL url, String path) throws IOException {
        ClassLoader cl = this.getClass().getClassLoader();
        ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
        Resource[] resources = resolver.getResources(""classpath*:"" + path + ""/**/*.class"");
        List<Resource> resources1 = Arrays.asList(resources);
        List<String> resourcePaths = new ArrayList<String>();
        for (Resource resource: resources1) {
            resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
        }
        return resourcePaths;
    }"
366,"    private static String preserveSubpackageName(final URI uri, final String rootPath) {
        final String uriStr = uri.toString();
        final int start = uriStr.indexOf(rootPath);
        return uriStr.substring(start, uriStr.length());
    }"
367,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
368,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
369,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
370,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
371,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
372,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
373,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
374,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
375,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
376,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
377,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
378,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
379,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
380,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
381,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
382,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
383,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
384,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
385,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
386,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
387,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		if (this.interceptors != null && this.interceptors.length > 0) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		factory.setMapperLocations(this.properties.resolveMapperLocations());

		return factory.getObject();
	}"
388,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		return new SqlSessionTemplate(sqlSessionFactory,
				this.properties.getExecutorType());"
389,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
390,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
391,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
392,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
393,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
394,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
395,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
396,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
397,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
398,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
399,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
400,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
401,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
402,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
403,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
404,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
405,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
406,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
407,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
408,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
409,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
410,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
411,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
412,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
413,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
414,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
415,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
416,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
417,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
418,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
419,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
	}"
420,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
421,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
422,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
423,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
424,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
425,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
426,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
427,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
428,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
429,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
430,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
431,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
432,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
433,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
434,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
435,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
436,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
437,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
438,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
439,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
440,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties
					.getConfig()));
		}
		else {
			if (this.interceptors != null && this.interceptors.length > 0) {
				factory.setPlugins(this.interceptors);
			}
			if (this.databaseIdProvider != null) {
				factory.setDatabaseIdProvider(this.databaseIdProvider);
			}
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
441,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
442,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			List<String> pkgs;
			try {
				pkgs = AutoConfigurationPackages.get(this.beanFactory);"
443,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
444,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
445,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
446,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
447,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
448,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
449,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
450,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
451,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeHandlersPackage:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
452,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.typeAliasesPackage:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapperLocations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
453,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
454,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
455,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
456,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
457,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
458,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
459,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
460,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
461,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
462,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
463,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
464,"    public boolean isValid() {
        return true;
    }"
465,"    protected List<String> list(URL url, String path) throws IOException {
        ClassLoader cl = this.getClass().getClassLoader();
        ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
        Resource[] resources = resolver.getResources(""classpath*:"" + path + ""/**/*.class"");
        List<Resource> resources1 = Arrays.asList(resources);
        List<String> resourcePaths = new ArrayList<String>();
        for (Resource resource: resources1) {
            resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
        }
        return resourcePaths;
    }"
466,"    private static String preserveSubpackageName(final URI uri, final String rootPath) {
        final String uriStr = uri.toString();
        final int start = uriStr.indexOf(rootPath);
        return uriStr.substring(start, uriStr.length());
    }"
467,"	public String getConfig() {
		return this.config;
	}"
468,"	public void setConfig(String config) {
		this.config = config;
	}"
469,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
470,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
471,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
472,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
473,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
474,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
475,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
476,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
477,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
478,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
479,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation : this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
480,"	public boolean isValid() {
		return true;
	}"
481,"	protected List<String> list(URL url, String path) throws IOException {
		ClassLoader cl = this.getClass().getClassLoader();
		ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
		Resource[] resources = resolver.getResources(""classpath*:"" + path + ""/**/*.class"");
		List<Resource> resources1 = Arrays.asList(resources);
		List<String> resourcePaths = new ArrayList<String>();
		for (Resource resource : resources1) {
			resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
		}
		return resourcePaths;
	}"
482,"	private static String preserveSubpackageName(final URI uri, final String rootPath) {
		final String uriStr = uri.toString();
		final int start = uriStr.indexOf(rootPath);
		return uriStr.substring(start, uriStr.length());
	}"
483,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
484,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
485,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
486,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
487,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
488,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
489,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
490,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
491,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
492,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
493,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
494,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
495,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
496,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
497,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
498,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
499,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
500,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
501,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
502,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
503,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
504,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
505,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
506,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
507,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
508,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
509,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
510,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
511,"	public Long getId() {
		return this.id;
	}"
512,"	public void setId(Long id) {
		this.id = id;
	}"
513,"	public String getName() {
		return this.name;
	}"
514,"	public void setName(String name) {
		this.name = name;
	}"
515,"	public void setParameter(PreparedStatement ps, int i, Object parameter,
			JdbcType jdbcType) throws SQLException {
	}

	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}

	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}

	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}

}"
516,"	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}"
517,"	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}"
518,"	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}"
519,"	City findById(@Param(""cityId"") Long cityId);

}"
520,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
521,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
522,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfig()));
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
523,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
524,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				List<String> pkgs = AutoConfigurationPackages.get(this.beanFactory);"
525,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
526,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
527,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
528,"	public Long getId() {
		return this.id;
	}"
529,"	public void setId(Long id) {
		this.id = id;
	}"
530,"	public String getName() {
		return this.name;
	}"
531,"	public void setName(String name) {
		this.name = name;
	}"
532,"	public String getState() {
		return this.state;
	}"
533,"	public void setState(String state) {
		this.state = state;
	}"
534,"	public String getCountry() {
		return this.country;
	}"
535,"	public void setCountry(String country) {
		this.country = country;
	}"
536,"	public String toString() {
		return getName() + "","" + getState() + "","" + getCountry();
	}"
537,"	City findByState(@Param(""state"") String state);

}"
538,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
	}"
539,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
540,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
541,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
542,"	public Long getId() {
		return this.id;
	}"
543,"	public void setId(Long id) {
		this.id = id;
	}"
544,"	public String getName() {
		return this.name;
	}"
545,"	public void setName(String name) {
		this.name = name;
	}"
546,"	public String getState() {
		return this.state;
	}"
547,"	public void setState(String state) {
		this.state = state;
	}"
548,"	public String getCountry() {
		return this.country;
	}"
549,"	public void setCountry(String country) {
		this.country = country;
	}"
550,"	public String toString() {
		return getName() + "","" + getState() + "","" + getCountry();
	}"
551,"	public Long getCity() {
		return city;
	}"
552,"	public void setCity(Long city) {
		this.city = city;
	}"
553,"	public String getName() {
		return name;
	}"
554,"	public void setName(String name) {
		this.name = name;
	}"
555,"	public String getAddress() {
		return address;
	}"
556,"	public void setAddress(String address) {
		this.address = address;
	}"
557,"	public String getZip() {
		return zip;
	}"
558,"	public void setZip(String zip) {
		this.zip = zip;
	}"
559,"	public static long getSerialversionuid() {
		return serialVersionUID;
	}"
560,"	public String toString() {
		return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
	}"
561,"	Hotel selectByCityId(int city_id);

}"
562,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
		assertTrue(""Wrong output: "" + output, output.contains(""1,Conrad Treasury Place,William & George Streets,4001""));		
	}"
563,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
564,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
565,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
566,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
	}"
567,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
568,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
569,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
		assertTrue(""Wrong output: "" + output, output.contains(""1,Conrad Treasury Place,William & George Streets,4001""));		
	}"
570,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
571,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfig()));
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
572,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
573,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			log.debug(""Searching for mappers annotated with @Mapper'"");
			
			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				if (this.resourceLoader != null) {"
574,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
575,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
576,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
577,"	City findById(@Param(""cityId"") Long cityId);

}"
578,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
579,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
580,"	public Long getId() {
		return this.id;
	}"
581,"	public void setId(Long id) {
		this.id = id;
	}"
582,"	public String getName() {
		return this.name;
	}"
583,"	public void setName(String name) {
		this.name = name;
	}"
584,"	public String getState() {
		return this.state;
	}"
585,"	public void setState(String state) {
		this.state = state;
	}"
586,"	public String getCountry() {
		return this.country;
	}"
587,"	public void setCountry(String country) {
		this.country = country;
	}"
588,"	public String toString() {
		return getName() + "","" + getState() + "","" + getCountry();
	}"
589,"	City findByState(@Param(""state"") String state);

}"
590,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
	}"
591,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
592,"	public Long getCity() {
		return city;
	}"
593,"	public void setCity(Long city) {
		this.city = city;
	}"
594,"	public String getName() {
		return name;
	}"
595,"	public void setName(String name) {
		this.name = name;
	}"
596,"	public String getAddress() {
		return address;
	}"
597,"	public void setAddress(String address) {
		this.address = address;
	}"
598,"	public String getZip() {
		return zip;
	}"
599,"	public void setZip(String zip) {
		this.zip = zip;
	}"
600,"	public static long getSerialversionuid() {
		return serialVersionUID;
	}"
601,"	public String toString() {
		return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
	}"
602,"	Hotel selectByCityId(int city_id);

}"
603,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
604,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfig()));
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
605,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
606,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			log.debug(""Searching for mappers annotated with @Mapper'"");
			
			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				if (this.resourceLoader != null) {"
607,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
608,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
609,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
610,"	public String getConfig() {
		return this.config;
	}"
611,"	public void setConfig(String config) {
		this.config = config;
	}"
612,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
613,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
614,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
615,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
616,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
617,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
618,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
619,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
620,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
621,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
622,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation : this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
623,"	public boolean isValid() {
		return true;
	}"
624,"	protected List<String> list(URL url, String path) throws IOException {
		ClassLoader cl = this.getClass().getClassLoader();
		ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
		Resource[] resources = resolver.getResources(""classpath*:"" + path + ""/**/*.class"");
		List<Resource> resources1 = Arrays.asList(resources);
		List<String> resourcePaths = new ArrayList<String>();
		for (Resource resource : resources1) {
			resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
		}
		return resourcePaths;
	}"
625,"	private static String preserveSubpackageName(final URI uri, final String rootPath) {
		final String uriStr = uri.toString();
		final int start = uriStr.indexOf(rootPath);
		return uriStr.substring(start, uriStr.length());
	}"
626,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
627,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
628,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
629,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
630,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
	}"
631,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
632,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
633,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
634,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
635,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
636,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
637,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
638,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
639,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
640,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
641,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
642,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
643,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
644,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
645,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
646,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
647,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
648,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
649,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
650,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
651,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
652,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
653,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
654,"	public Long getId() {
		return this.id;
	}"
655,"	public void setId(Long id) {
		this.id = id;
	}"
656,"	public String getName() {
		return this.name;
	}"
657,"	public void setName(String name) {
		this.name = name;
	}"
658,"	public void setParameter(PreparedStatement ps, int i, Object parameter,
			JdbcType jdbcType) throws SQLException {
	}

	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}

	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}

	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}

}"
659,"	public Object getResult(ResultSet rs, String columnName) throws SQLException {
		return null;
	}"
660,"	public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
		return null;
	}"
661,"	public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
		return null;
	}"
662,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
663,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
664,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfig()));
		}
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
665,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
666,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			log.debug(""Searching for mappers annotated with @Mapper'"");
			
			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				if (this.resourceLoader != null) {"
667,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
668,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
669,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
670,"	City findById(@Param(""cityId"") Long cityId);

}"
671,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
672,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
673,"	public Long getId() {
		return this.id;
	}"
674,"	public void setId(Long id) {
		this.id = id;
	}"
675,"	public String getName() {
		return this.name;
	}"
676,"	public void setName(String name) {
		this.name = name;
	}"
677,"	public String getState() {
		return this.state;
	}"
678,"	public void setState(String state) {
		this.state = state;
	}"
679,"	public String getCountry() {
		return this.country;
	}"
680,"	public void setCountry(String country) {
		this.country = country;
	}"
681,"	public String toString() {
		return getName() + "","" + getState() + "","" + getCountry();
	}"
682,"	City findByState(@Param(""state"") String state);

}"
683,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
	}"
684,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
685,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
686,"	public City selectCityById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
687,"	public Long getId() {
		return this.id;
	}"
688,"	public void setId(Long id) {
		this.id = id;
	}"
689,"	public String getName() {
		return this.name;
	}"
690,"	public void setName(String name) {
		this.name = name;
	}"
691,"	public String getState() {
		return this.state;
	}"
692,"	public void setState(String state) {
		this.state = state;
	}"
693,"	public String getCountry() {
		return this.country;
	}"
694,"	public void setCountry(String country) {
		this.country = country;
	}"
695,"	public String toString() {
		return getName() + "","" + getState() + "","" + getCountry();
	}"
696,"	public Long getCity() {
		return city;
	}"
697,"	public void setCity(Long city) {
		this.city = city;
	}"
698,"	public String getName() {
		return name;
	}"
699,"	public void setName(String name) {
		this.name = name;
	}"
700,"	public String getAddress() {
		return address;
	}"
701,"	public void setAddress(String address) {
		this.address = address;
	}"
702,"	public String getZip() {
		return zip;
	}"
703,"	public void setZip(String zip) {
		this.zip = zip;
	}"
704,"	public static long getSerialversionuid() {
		return serialVersionUID;
	}"
705,"	public String toString() {
		return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
	}"
706,"	Hotel selectByCityId(int city_id);

}"
707,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""San Francisco,CA,US""));
		assertTrue(""Wrong output: "" + output, output.contains(""1,Conrad Treasury Place,William & George Streets,4001""));		
	}"
708,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
709,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties"
710,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfig())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfig()));
		}
		factory.setConfiguration(properties.getConfiguration());
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
711,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
712,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			log.debug(""Searching for mappers annotated with @Mapper'"");
			
			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				if (this.resourceLoader != null) {"
713,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
714,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
715,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
716,"	public String getConfig() {
		return this.config;
	}"
717,"	public void setConfig(String config) {
		this.config = config;
	}"
718,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
719,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
720,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
721,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
722,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
723,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
724,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
725,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
726,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
727,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
728,"	public Configuration getConfiguration() {
		return configuration;
	}"
729,"	public void setConfiguration(Configuration configuration) {
		this.configuration = configuration;
	}"
730,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation : this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
731,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
732,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
733,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
734,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
735,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
736,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
737,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
738,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
739,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
740,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
741,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
742,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
743,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
744,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
745,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
746,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
747,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
748,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
749,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
750,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
751,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'sqlSessionFactory' defined in org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is java.lang.IllegalStateException: Property 'configuration' and 'configLocation' can not specified with together""));

		this.context.refresh();
	}"
752,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
753,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
754,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
755,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
756,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
757,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
758,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
759,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
760,"  public String getConfigLocation() {
    return this.configLocation;
  }"
761,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
762,"	public String getConfig() {
		return this.configLocation;
	}"
763,"	public void setConfig(String config) {
		this.configLocation = config;
	}"
764,"	public String[] getMapperLocations() {
		return this.mapperLocations;
	}"
765,"	public void setMapperLocations(String[] mapperLocations) {
		this.mapperLocations = mapperLocations;
	}"
766,"	public String getTypeHandlersPackage() {
		return this.typeHandlersPackage;
	}"
767,"	public void setTypeHandlersPackage(String typeHandlersPackage) {
		this.typeHandlersPackage = typeHandlersPackage;
	}"
768,"	public String getTypeAliasesPackage() {
		return this.typeAliasesPackage;
	}"
769,"	public void setTypeAliasesPackage(String typeAliasesPackage) {
		this.typeAliasesPackage = typeAliasesPackage;
	}"
770,"	public boolean isCheckConfigLocation() {
		return this.checkConfigLocation;
	}"
771,"	public void setCheckConfigLocation(boolean checkConfigLocation) {
		this.checkConfigLocation = checkConfigLocation;
	}"
772,"	public ExecutorType getExecutorType() {
		return this.executorType;
	}"
773,"	public void setExecutorType(ExecutorType executorType) {
		this.executorType = executorType;
	}"
774,"	public Configuration getConfiguration() {
		return configuration;
	}"
775,"	public void setConfiguration(Configuration configuration) {
		this.configuration = configuration;
	}"
776,"	public Resource[] resolveMapperLocations() {
		List<Resource> resources = new ArrayList<Resource>();
		if (this.mapperLocations != null) {
			for (String mapperLocation : this.mapperLocations) {
				Resource[] mappers;
				try {
					mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
					resources.addAll(Arrays.asList(mappers));
				} catch (IOException e) {

				}
			}
		}

		Resource[] mapperLocations = new Resource[resources.size()];
		mapperLocations = resources.toArray(mapperLocations);
		return mapperLocations;
	}"
777,"	public void checkConfigFileExists() {
		if (this.properties.isCheckConfigLocation()) {
			Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
778,"	public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
		SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
		factory.setDataSource(dataSource);
		factory.setVfs(SpringBootVFS.class);
		if (StringUtils.hasText(this.properties.getConfigLocation())) {
			factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
		}
		factory.setConfiguration(properties.getConfiguration());
		if (!ObjectUtils.isEmpty(this.interceptors)) {
			factory.setPlugins(this.interceptors);
		}
		if (this.databaseIdProvider != null) {
			factory.setDatabaseIdProvider(this.databaseIdProvider);
		}
		if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
			factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
		}
		if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
			factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
		}
		if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
			factory.setMapperLocations(this.properties.resolveMapperLocations());
		}

		return factory.getObject();
	}"
779,"	public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
		ExecutorType executorType = this.properties.getExecutorType();
		if (executorType != null) {
			return new SqlSessionTemplate(sqlSessionFactory, executorType);"
780,"		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

			log.debug(""Searching for mappers annotated with @Mapper'"");
			
			ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

			try {
				if (this.resourceLoader != null) {"
781,"		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			this.beanFactory = beanFactory;
		}"
782,"		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}"
783,"		public void afterPropertiesSet() {
			log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
		}"
784,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation()) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
785,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
786,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
787,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      log.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
788,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
789,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
790,"    public void afterPropertiesSet() {
      log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
    }"
791,"  public String getConfigLocation() {
    return this.configLocation;
  }"
792,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
793,"  public String getConfig() {
    return this.configLocation;
  }"
794,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
795,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
796,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
797,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
798,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
799,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
800,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
801,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
802,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
803,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
804,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
805,"  public Configuration getConfiguration() {
    return configuration;
  }"
806,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
807,"  public Resource[] resolveMapperLocations() {
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        Resource[] mappers;
        try {
          mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {

        }
      }
    }

    Resource[] mapperLocations = new Resource[resources.size()];
    mapperLocations = resources.toArray(mapperLocations);
    return mapperLocations;
  }"
808,"  public boolean isValid() {
    return true;
  }"
809,"  protected List<String> list(URL url, String path) throws IOException {
    ClassLoader cl = this.getClass().getClassLoader();
    ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(cl);
    Resource[] resources = resolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<Resource> resources1 = Arrays.asList(resources);
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources1) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
810,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start, uriStr.length());
  }"
811,"  public String getConfigLocation() {
    return this.configLocation;
  }"
812,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
813,"  public String getConfig() {
    return this.configLocation;
  }"
814,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
815,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
816,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
817,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
818,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
819,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
820,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
821,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
822,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
823,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
824,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
825,"  public Configuration getConfiguration() {
    return configuration;
  }"
826,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
827,"  public Resource[] resolveMapperLocations() {
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        Resource[] mappers;
        try {
          mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {

        }
      }
    }

    Resource[] mapperLocations = new Resource[resources.size()];
    mapperLocations = resources.toArray(mapperLocations);
    return mapperLocations;
  }"
828,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
829,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
830,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
831,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
832,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
833,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
834,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
835,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
836,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
837,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
838,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
839,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
840,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
841,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
842,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
843,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
844,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
845,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
846,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
847,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
848,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
849,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
850,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
851,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
852,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
853,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
854,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
855,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
856,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
857,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
858,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
859,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
860,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      log.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
861,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
862,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
863,"    public void afterPropertiesSet() {
      log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));
    }"
864,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
865,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
866,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
867,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
868,"	public void testWithConfigFile() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
869,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
870,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
871,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
872,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
873,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
874,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
875,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
876,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
877,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
878,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
879,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
880,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
881,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
882,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
883,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
884,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
885,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'sqlSessionFactory' defined in org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.apache.ibatis.session.SqlSessionFactory]: Factory method 'sqlSessionFactory' threw exception; nested exception is java.lang.IllegalStateException: Property 'configuration' and 'configLocation' can not specified with together""));

		this.context.refresh();
	}"
886,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
887,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
888,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
889,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
890,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
891,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
892,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
893,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
894,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
895,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
896,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
897,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
898,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
899,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
900,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
901,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
902,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
903,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
904,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
905,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
906,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
907,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
908,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
909,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
910,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
911,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
912,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
913,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
914,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
915,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
916,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
917,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
918,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
919,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
920,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
921,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
922,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
923,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
924,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
925,"  public String getConfigLocation() {
    return this.configLocation;
  }"
926,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
927,"  public String getConfig() {
    return this.configLocation;
  }"
928,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
929,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
930,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
931,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
932,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
933,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
934,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
935,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
936,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
937,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
938,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
939,"  public Configuration getConfiguration() {
    return configuration;
  }"
940,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
941,"  public Resource[] resolveMapperLocations() {
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        Resource[] mappers;
        try {
          mappers = new PathMatchingResourcePatternResolver().getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {

        }
      }
    }

    Resource[] mapperLocations = new Resource[resources.size()];
    mapperLocations = resources.toArray(mapperLocations);
    return mapperLocations;
  }"
942,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
943,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
944,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
945,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      log.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
946,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
947,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
948,"    public void afterPropertiesSet() {
      if (log.isDebugEnabled()) {
        log.debug(String.format(""No %s found."", MapperFactoryBean.class.getName()));"
949,"  public boolean isValid() {
    return true;
  }"
950,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
951,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
952,"  public String getConfigLocation() {
    return this.configLocation;
  }"
953,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
954,"  public String getConfig() {
    return this.configLocation;
  }"
955,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
956,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
957,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
958,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
959,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
960,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
961,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
962,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
963,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
964,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
965,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
966,"  public Configuration getConfiguration() {
    return configuration;
  }"
967,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
968,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
969,"	public Long getId() {
		return this.id;
	}"
970,"	public void setId(Long id) {
		this.id = id;
	}"
971,"	public String getName() {
		return this.name;
	}"
972,"	public void setName(String name) {
		this.name = name;
	}"
973,"	public String getState() {
		return this.state;
	}"
974,"	public void setState(String state) {
		this.state = state;
	}"
975,"	public String getCountry() {
		return this.country;
	}"
976,"	public void setCountry(String country) {
		this.country = country;
	}"
977,"	public String toString() {
		return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
	}"
978,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
979,"	public Long getId() {
		return this.id;
	}"
980,"	public void setId(Long id) {
		this.id = id;
	}"
981,"	public String getName() {
		return this.name;
	}"
982,"	public void setName(String name) {
		this.name = name;
	}"
983,"	public String getState() {
		return this.state;
	}"
984,"	public void setState(String state) {
		this.state = state;
	}"
985,"	public String getCountry() {
		return this.country;
	}"
986,"	public void setCountry(String country) {
		this.country = country;
	}"
987,"	public String toString() {
		return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
	}"
988,"	public Long getCity() {
		return city;
	}"
989,"	public void setCity(Long city) {
		this.city = city;
	}"
990,"	public String getName() {
		return name;
	}"
991,"	public void setName(String name) {
		this.name = name;
	}"
992,"	public String getAddress() {
		return address;
	}"
993,"	public void setAddress(String address) {
		this.address = address;
	}"
994,"	public String getZip() {
		return zip;
	}"
995,"	public void setZip(String zip) {
		this.zip = zip;
	}"
996,"	public String toString() {
		return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
	}"
997,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
		assertTrue(""Wrong output: "" + output, output.contains(""1,Conrad Treasury Place,William & George Streets,4001""));
	}"
998,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
999,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1000,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1001,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1002,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1003,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1004,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1005,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1006,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1007,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1008,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1009,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1010,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1011,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1012,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1013,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1014,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1015,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
1016,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
1017,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
1018,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
1019,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
1020,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
1021,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1022,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
1023,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1024,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1025,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1026,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
1027,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1028,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1029,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1030,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1031,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1032,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1033,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
1034,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1035,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1036,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1037,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
		assertTrue(""Wrong output: "" + output, output.contains(""1,Conrad Treasury Place,William & George Streets,4001""));
	}"
1038,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1039,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1040,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1041,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1042,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1043,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1044,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1045,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1046,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1047,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1048,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1049,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1050,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1051,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1052,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1053,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1054,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1055,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1056,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1057,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1058,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1059,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1060,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    factory.setConfiguration(properties.getConfiguration());
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1061,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1062,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper'"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1063,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1064,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1065,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1066,"  public String getConfigLocation() {
    return this.configLocation;
  }"
1067,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
1068,"  public String getConfig() {
    return this.configLocation;
  }"
1069,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
1070,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
1071,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
1072,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
1073,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
1074,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
1075,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
1076,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
1077,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
1078,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
1079,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
1080,"  public Properties getConfigurationProperties() {
    return configurationProperties;
  }"
1081,"  public void setConfigurationProperties(Properties configurationProperties) {
    this.configurationProperties = configurationProperties;
  }"
1082,"  public Configuration getConfiguration() {
    return configuration;
  }"
1083,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
1084,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
1085,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1086,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1087,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1088,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1089,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1090,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1091,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1092,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1093,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1094,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1095,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
1096,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
1097,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
1098,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
1099,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
1100,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
1101,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1102,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
1103,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1104,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1105,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1106,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
1107,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1108,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertNull(variables);
	}"
1109,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
	}"
1110,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key2""));
	}"
1111,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(2, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
		assertEquals(""value2"", variables.get(""key2""));
	}"
1112,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key""));
	}"
1113,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1114,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1115,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1116,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1117,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1118,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

}"
1119,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1120,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1121,"  public boolean isValid() {
    return true;
  }"
1122,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1123,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1124,"  public String getConfigLocation() {
    return this.configLocation;
  }"
1125,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
1126,"  public String getConfig() {
    return this.configLocation;
  }"
1127,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
1128,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
1129,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
1130,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
1131,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
1132,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
1133,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
1134,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
1135,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
1136,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
1137,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
1138,"  public Properties getConfigurationProperties() {
    return configurationProperties;
  }"
1139,"  public void setConfigurationProperties(Properties configurationProperties) {
    this.configurationProperties = configurationProperties;
  }"
1140,"  public Configuration getConfiguration() {
    return configuration;
  }"
1141,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
1142,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
1143,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1144,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1145,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1146,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1147,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1148,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1149,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1150,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1151,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1152,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1153,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
1154,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
1155,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
1156,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
1157,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
1158,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
1159,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1160,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
1161,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1162,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1163,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1164,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
1165,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1166,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertNull(variables);
	}"
1167,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
	}"
1168,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key2""));
	}"
1169,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(2, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
		assertEquals(""value2"", variables.get(""key2""));
	}"
1170,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key""));
	}"
1171,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().get(""key""), ""value"");
	}"
1172,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertTrue(this.context.getBean(SqlSessionFactory.class).getClass() == MySqlSessionFactory.class);
	}"
1173,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertEquals(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), ExecutorType.BATCH);
	}"
1174,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertTrue(this.context.getBean(SqlSessionTemplate.class).getClass() == MySqlSessionTemplate.class);
	}"
1175,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1176,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1177,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1178,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1179,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1180,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1181,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1182,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1183,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1184,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1185,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}"
1186,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}"
1187,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
1188,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1189,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1190,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1191,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1192,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1193,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1194,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1195,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1196,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1197,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1198,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1199,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1200,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1201,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1202,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
1203,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
1204,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
1205,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
1206,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
1207,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
1208,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1209,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
1210,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1211,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1212,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1213,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
1214,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1215,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1216,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
	}"
1217,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key2""));
	}"
1218,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(2, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
		assertEquals(""value2"", variables.get(""key2""));
	}"
1219,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key""));
	}"
1220,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().get(""key""), ""value"");
	}"
1221,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertTrue(this.context.getBean(SqlSessionFactory.class).getClass() == MySqlSessionFactory.class);
	}"
1222,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertEquals(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), ExecutorType.BATCH);
	}"
1223,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertTrue(this.context.getBean(SqlSessionTemplate.class).getClass() == MySqlSessionTemplate.class);
	}"
1224,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1225,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1226,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1227,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1228,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1229,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1230,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1231,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1232,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1233,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1234,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}"
1235,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}"
1236,"  void customize(Configuration configuration);

}"
1237,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1238,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1239,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1240,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1241,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1242,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1243,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1244,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1245,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1246,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(0, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1247,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(ExecutorType.SIMPLE, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1248,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1249,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapperImpl.class).length);
		assertEquals(ExecutorType.BATCH, this.context.getBean(SqlSessionTemplate.class).getExecutorType());
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1250,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1251,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
	}"
1252,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1253,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1254,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(2, this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size());
	}"
1255,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());"
1256,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
	}"
1257,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size());
		this.context.close();
	}"
1258,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertEquals(""h2"", this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId());
	}"
1259,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());"
1260,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1261,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());"
1262,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1263,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionTemplate.class).length);
		assertEquals(1, this.context.getBeanNamesForType(CityMapper.class).length);
		assertEquals(Integer.valueOf(1000), configuration.getDefaultFetchSize());
		assertEquals(DummyTypeHandler.class, configuration.getTypeHandlerRegistry()
				.getTypeHandler(BigInteger.class).getClass());
		assertEquals(4, configuration.getMappedStatementNames().size());
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertEquals(ExecutorType.REUSE, this.context.getBean(SqlSessionTemplate.class)
				.getExecutorType());
		assertEquals(1, configuration.getInterceptors().size());
		assertEquals(MyInterceptor.class, configuration.getInterceptors().get(0)
				.getClass());
		assertEquals(""h2"", configuration.getDatabaseId());
	}"
1264,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1265,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertEquals(100, sqlSessionFactory.getConfiguration().getDefaultFetchSize()
				.intValue());
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
				.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());"
1266,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertEquals(DummyTypeHandler.class, sqlSessionFactory.getConfiguration()
			.getTypeHandlerRegistry().getTypeHandler(BigInteger.class).getClass());
		assertNotNull(sqlSessionFactory.getConfiguration().getCache(""test""));
	}"
1267,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1268,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1269,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
	}"
1270,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key2""));
	}"
1271,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(2, variables.size());
		assertEquals(""value1"", variables.get(""key1""));
		assertEquals(""value2"", variables.get(""key2""));
	}"
1272,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertEquals(1, variables.size());
		assertEquals(""value2"", variables.get(""key""));
	}"
1273,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertEquals(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().get(""key""), ""value"");
	}"
1274,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertEquals(1, this.context.getBeanNamesForType(SqlSessionFactory.class).length);
		assertTrue(this.context.getBean(SqlSessionFactory.class).getClass() == MySqlSessionFactory.class);
	}"
1275,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertEquals(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), ExecutorType.BATCH);
	}"
1276,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertEquals(1,
				this.context.getBeanNamesForType(SqlSessionTemplate.class).length);

		assertTrue(this.context.getBean(SqlSessionTemplate.class).getClass() == MySqlSessionTemplate.class);
	}"
1277,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1278,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1279,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1280,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1281,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1282,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1283,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1284,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1285,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1286,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1287,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1288,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1289,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1290,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1291,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}"
1292,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}"
1293,"  public String getConfigLocation() {
    return this.configLocation;
  }"
1294,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
1295,"  public String getConfig() {
    return this.configLocation;
  }"
1296,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
1297,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
1298,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
1299,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
1300,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
1301,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
1302,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
1303,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
1304,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
1305,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
1306,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
1307,"  public Properties getConfigurationProperties() {
    return configurationProperties;
  }"
1308,"  public void setConfigurationProperties(Properties configurationProperties) {
    this.configurationProperties = configurationProperties;
  }"
1309,"  public Configuration getConfiguration() {
    return configuration;
  }"
1310,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
1311,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
1312,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1313,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1314,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(0));
	}"
1315,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.SIMPLE));
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1316,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1317,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1318,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1319,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1320,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1321,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1322,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size(), is(2));
	}"
1323,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
	}"
1324,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
	}"
1325,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size(), is(1));
		this.context.close();
	}"
1326,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId(), is(""h2""));
	}"
1327,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
	}"
1328,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1329,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1330,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1331,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertThat(configuration.getMappedStatementNames().size(), is(4));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1332,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1333,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize(), is(100));
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1334,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertNotNull(sqlSessionFactory.getConfiguration().getCache(""test""));
	}"
1335,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1336,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1337,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key1""), is(""value1""));
	}"
1338,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1339,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(2));
		assertThat(variables.getProperty(""key1""), is(""value1""));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1340,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key""), is(""value2""));
	}"
1341,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""), is(""value""));
	}"
1342,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class), is(instanceOf(MySqlSessionFactory.class)));
	}"
1343,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
	}"
1344,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class), is(instanceOf(MySqlSessionTemplate.class)));
	}"
1345,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1346,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1347,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1348,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1349,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1350,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1351,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1352,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1353,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1354,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1355,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1356,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1357,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1358,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1359,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			SqlSessionTemplate sessionTemplate = new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
			return sessionTemplate;
		}"
1360,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			MySqlSessionTemplate sessionTemplate = new MySqlSessionTemplate(sqlSessionFactory);
			return sessionTemplate;
		}"
1361,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1362,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1363,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(0));
	}"
1364,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.SIMPLE));
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1365,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1366,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1367,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1368,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1369,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1370,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1371,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size(), is(2));
	}"
1372,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
	}"
1373,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
	}"
1374,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size(), is(1));
		this.context.close();
	}"
1375,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId(), is(""h2""));
	}"
1376,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
	}"
1377,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1378,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1379,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1380,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertThat(configuration.getMappedStatementNames().size(), is(4));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1381,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1382,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize(), is(100));
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1383,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertNotNull(sqlSessionFactory.getConfiguration().getCache(""test""));
	}"
1384,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1385,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1386,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key1""), is(""value1""));
	}"
1387,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1388,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(2));
		assertThat(variables.getProperty(""key1""), is(""value1""));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1389,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key""), is(""value2""));
	}"
1390,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""), is(""value""));
	}"
1391,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class), is(instanceOf(MySqlSessionFactory.class)));
	}"
1392,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
	}"
1393,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class), is(instanceOf(MySqlSessionTemplate.class)));
	}"
1394,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1395,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1396,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1397,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1398,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1399,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1400,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1401,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1402,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1403,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1404,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1405,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1406,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1407,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1408,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1409,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1410,"  public void mapperIsNotNullTest() {
    assertThat(cityMapper).isNotNull();
  }"
1411,"  public void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
1412,"  public void sqlSessionIsNotNullTest() {
    assertThat(sqlSession).isNotNull();
  }"
1413,"  public void selectCityByIdTest() {
    City city = sqlSession.selectOne(""selectCityById"", 1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
1414,"    public CityDao cityDao(SqlSession sqlSession) {
      return new CityDao(sqlSession);
    }"
1415,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
1416,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:
        return this.annotation.includeFilters();
      case EXCLUDE:
        return this.annotation.excludeFilters();
    }
    throw new IllegalStateException(""Unsupported type "" + type);
  }"
1417,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
1418,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
1419,"  public void sqlSessionIsNotNullTest() {
    assertThat(sqlSession).isNotNull();
  }"
1420,"  public void mapperIsNotNullTest() {
    assertThat(sampleMapper).isNotNull();
  }"
1421,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1422,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByname(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1423,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
1424,"  public Long getId() {
    return id;
  }"
1425,"  public void setId(Long id) {
    this.id = id;
  }"
1426,"  public String getName() {
    return name;
  }"
1427,"  public void setName(String name) {
    this.name = name;
  }"
1428,"  Sample findByname(String name);
}"
1429,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
1430,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:
        return this.annotation.includeFilters();
      case EXCLUDE:
        return this.annotation.excludeFilters();
    }
    throw new IllegalStateException(""Unsupported type "" + type);
  }"
1431,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
1432,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
1433,"  public void sqlSessionIsNotNullTest() {
    assertThat(sqlSession).isNotNull();
  }"
1434,"  public void mapperIsNotNullTest() {
    assertThat(sampleMapper).isNotNull();
  }"
1435,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1436,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByname(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1437,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
1438,"  public Long getId() {
    return id;
  }"
1439,"  public void setId(Long id) {
    this.id = id;
  }"
1440,"  public String getName() {
    return name;
  }"
1441,"  public void setName(String name) {
    this.name = name;
  }"
1442,"  Sample findByname(String name);
}"
1443,"  public String getConfigLocation() {
    return this.configLocation;
  }"
1444,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
1445,"  public String getConfig() {
    return this.configLocation;
  }"
1446,"  public void setConfig(String config) {
    this.configLocation = config;
  }"
1447,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
1448,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
1449,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
1450,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
1451,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
1452,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
1453,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
1454,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
1455,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
1456,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
1457,"  public Properties getConfigurationProperties() {
    return configurationProperties;
  }"
1458,"  public void setConfigurationProperties(Properties configurationProperties) {
    this.configurationProperties = configurationProperties;
  }"
1459,"  public Configuration getConfiguration() {
    return configuration;
  }"
1460,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
1461,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
1462,"  public boolean isValid() {
    return true;
  }"
1463,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1464,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1465,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1466,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1467,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(0));
	}"
1468,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.SIMPLE));
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1469,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1470,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1471,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1472,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1473,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1474,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1475,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size(), is(2));
	}"
1476,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
	}"
1477,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
	}"
1478,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size(), is(1));
		this.context.close();
	}"
1479,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId(), is(""h2""));
	}"
1480,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
	}"
1481,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1482,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1483,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1484,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertThat(configuration.getMappedStatementNames().size(), is(4));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1485,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1486,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize(), is(100));
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1487,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertNotNull(sqlSessionFactory.getConfiguration().getCache(""test""));
	}"
1488,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1489,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1490,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key1""), is(""value1""));
	}"
1491,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1492,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(2));
		assertThat(variables.getProperty(""key1""), is(""value1""));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1493,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key""), is(""value2""));
	}"
1494,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""), is(""value""));
	}"
1495,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class), is(instanceOf(MySqlSessionFactory.class)));
	}"
1496,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
	}"
1497,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class), is(instanceOf(MySqlSessionTemplate.class)));
	}"
1498,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1499,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1500,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1501,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1502,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1503,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1504,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1505,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1506,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1507,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1508,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1509,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1510,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1511,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1512,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1513,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1514,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
1515,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
1516,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
1517,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
1518,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
1519,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1520,"	City findByState(@Param(""state"") String state);

}"
1521,"  public void mapperIsNotNullTest() {
    assertThat(cityMapper).isNotNull();
  }"
1522,"  public void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
1523,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1524,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1525,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1526,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1527,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
1528,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:
        return this.annotation.includeFilters();
      case EXCLUDE:
        return this.annotation.excludeFilters();
    }
    throw new IllegalStateException(""Unsupported type "" + type);
  }"
1529,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
1530,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
1531,"  public void sqlSessionIsNotNullTest() {
    assertThat(sqlSession).isNotNull();
  }"
1532,"  public void mapperIsNotNullTest() {
    assertThat(sampleMapper).isNotNull();
  }"
1533,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1534,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByname(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1535,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
1536,"  public void sqlSessionIsNotNullTest() {
    assertThat(sqlSession).isNotNull();
  }"
1537,"  public void mapperIsNotNullTest() {
    assertThat(sampleMapper).isNotNull();
  }"
1538,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1539,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByname(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1540,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
1541,"  public Long getId() {
    return id;
  }"
1542,"  public void setId(Long id) {
    this.id = id;
  }"
1543,"  public String getName() {
    return name;
  }"
1544,"  public void setName(String name) {
    this.name = name;
  }"
1545,"  Sample findByname(String name);

}"
1546,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
1547,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:
        return this.annotation.includeFilters();
      case EXCLUDE:
        return this.annotation.excludeFilters();
    }
    throw new IllegalStateException(""Unsupported type "" + type);
  }"
1548,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
1549,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
1550,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
1551,"  public boolean isValid() {
    return true;
  }"
1552,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1553,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1554,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1555,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1556,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(0));
	}"
1557,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.SIMPLE));
		assertFalse(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1558,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1559,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase());
	}"
1560,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1561,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
	}"
1562,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(is(""Error creating bean with name 'mybatisAutoConfiguration': Invocation of init method failed; nested exception is java.lang.IllegalStateException: Cannot find config location: class path resource [foo.xml] (please add config file or check your Mybatis configuration)""));

		this.context.refresh();
	}"
1563,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertTrue(typeHandlerRegistry.hasTypeHandler(BigInteger.class));
	}"
1564,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames().size(), is(2));
	}"
1565,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
	}"
1566,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
	}"
1567,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().size(), is(1));
		this.context.close();
	}"
1568,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId(), is(""h2""));
	}"
1569,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
	}"
1570,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1571,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1572,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()"
1573,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBeanNamesForType(CityMapper.class).length, is(1));
		assertThat(configuration.getDefaultFetchSize(), is(1000));
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertThat(configuration.getMappedStatementNames().size(), is(4));
		assertTrue(configuration.getMappedStatementNames().contains(""selectCityById""));
		assertTrue(configuration
				.getMappedStatementNames()
				.contains(
						""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById""));
		assertTrue(configuration.getMappedStatementNames().contains(""findById""));
		assertTrue(configuration.getMappedStatementNames().contains(
				""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById""));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.REUSE));
		assertThat(configuration.getInterceptors().size(), is(1));
		assertThat(configuration.getInterceptors().get(0), is(instanceOf(MyInterceptor.class)));
		assertThat(configuration.getDatabaseId(), is(""h2""));
	}"
1574,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertTrue(this.context.getBean(SqlSessionFactory.class).getConfiguration()
				.isMapUnderscoreToCamelCase());"
1575,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize(), is(100));
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
	}"
1576,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class), is(instanceOf(DummyTypeHandler.class)));
		assertNotNull(sqlSessionFactory.getConfiguration().getCache(""test""));
	}"
1577,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		expectedException.expect(isA(BeanCreationException.class));
		expectedException
				.expectMessage(""Property 'configuration' and 'configLocation' can not specified with together"");

		this.context.refresh();
	}"
1578,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertTrue(variables.isEmpty());
	}"
1579,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key1""), is(""value1""));
	}"
1580,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1581,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(2));
		assertThat(variables.getProperty(""key1""), is(""value1""));
		assertThat(variables.getProperty(""key2""), is(""value2""));
	}"
1582,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables.size(), is(1));
		assertThat(variables.getProperty(""key""), is(""value2""));
	}"
1583,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""), is(""value""));
	}"
1584,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionFactory.class), is(instanceOf(MySqlSessionFactory.class)));
	}"
1585,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType(), is(ExecutorType.BATCH));
	}"
1586,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class).length, is(1));
		assertThat(this.context.getBean(SqlSessionTemplate.class), is(instanceOf(MySqlSessionTemplate.class)));
	}"
1587,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1588,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1589,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1590,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1591,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1592,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1593,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1594,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1595,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1596,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1597,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1598,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1599,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1600,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1601,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1602,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1603,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
1604,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
1605,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
1606,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
1607,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
1608,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1609,"	City findByState(@Param(""state"") String state);

}"
1610,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1611,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1612,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1613,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1614,"  public boolean isValid() {
    return true;
  }"
1615,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1616,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1617,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
1618,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
1619,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
1620,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
1621,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
1622,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1623,"	City findByState(@Param(""state"") String state);

}"
1624,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1625,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1626,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1627,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1628,"  public String getMessage() {
    return ""Hello!"";
  }"
1629,"  public String getMessage() {
    return ""Goodbye!"";
  }"
1630,"  public void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
1631,"  public void testExcludeFilter() {
    assertThat(service).isNull();
  }"
1632,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1633,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
1634,"  public void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
1635,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
1636,"  public Long getId() {
    return id;
  }"
1637,"  public void setId(Long id) {
    this.id = id;
  }"
1638,"  public String getName() {
    return name;
  }"
1639,"  public void setName(String name) {
    this.name = name;
  }"
1640,"  Sample findByName(String name);

}"
1641,"  public boolean isValid() {
    return true;
  }"
1642,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1643,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1644,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
1645,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
1646,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
1647,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
1648,"	public static void main(String[] args) {
		SpringApplication.run(SampleMapperApplication.class, args);
	}"
1649,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1650,"	City findByState(@Param(""state"") String state);

}"
1651,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1652,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1653,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1654,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1655,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
1656,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1657,"  public void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
1658,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
1659,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1660,"  public void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
1661,"  public void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
1662,"  public boolean isValid() {
    return true;
  }"
1663,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    List<String> resourcePaths = new ArrayList<String>();
    for (Resource resource : resources) {
      resourcePaths.add(preserveSubpackageName(resource.getURI(), path));
    }
    return resourcePaths;
  }"
1664,"  private static String preserveSubpackageName(final URI uri, final String rootPath) {
    final String uriStr = uri.toString();
    final int start = uriStr.indexOf(rootPath);
    return uriStr.substring(start);
  }"
1665,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations().length, is(0));
    }"
1666,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations().length, is(2));
    }"
1667,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations().length, is(1));
	}"
1668,"	public City findById(long id) {
		return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
	}"
1669,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
1670,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1671,"	City findByState(@Param(""state"") String state);

}"
1672,"	public void test() {
		String output = out.toString();
		assertTrue(""Wrong output: "" + output, output.contains(""1,San Francisco,CA,US""));
	}"
1673,"	public static void main(String[] args) {
		SpringApplication.run(SampleMybatisApplication.class, args);
	}"
1674,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1675,"	public City selectCityById(long id) {
		return this.sqlSession.selectOne(""selectCityById"", id);
	}"
1676,"	public static void main(String[] args) {
		SpringApplication.run(SampleAnnotationApplication.class, args);
	}"
1677,"	public void run(String... args) throws Exception {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
1678,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
1679,"	public void run(String... args) throws Exception {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
1680,"	public void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, String>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size(), is(1));

		// assert for default-scripting-language
		{
			Map<String, String> element = properties.get(0);"
1681,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1682,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1683,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
	}"
1684,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
1685,"	public void testWithConfigLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1686,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config:mybatis-config.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1687,"	public void testWithCheckConfigLocationFileExists() {
		EnvironmentTestUtils
				.addEnvironment(this.context, ""mybatis.config-location:mybatis-config.xml"",
						""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1688,"	public void testWithCheckConfigLocationFileNotSpecify() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1689,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		EnvironmentTestUtils.addEnvironment(this.context, ""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1690,"	public void testWithTypeHandlersPackage() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
1691,"	public void testWithMapperLocation() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
1692,"	public void testWithExecutorType() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
1693,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
1694,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
1695,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
1696,"	public void testMixedWithConfigurationFileAndInterceptor() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
1697,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config-settings-only.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1698,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		EnvironmentTestUtils
				.addEnvironment(this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1699,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
	}"
1700,"	public void testMixedWithFullConfigurations() {
		EnvironmentTestUtils
				.addEnvironment(
						this.context,
						""mybatis.config-location:mybatis-config-settings-only.xml"",
						""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
						""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
						""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""mybatis.executor-type=REUSE"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1701,"	public void testWithMyBatisConfiguration() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.map-underscore-to-camel-case:true"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1702,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.default-fetch-size:100"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1703,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
1704,"	public void testConfigFileAndConfigurationWithTogether() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1705,"	public void testWithoutConfigurationVariablesAndProperties() {
		EnvironmentTestUtils.addEnvironment(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
1706,"	public void testWithConfigurationVariablesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
1707,"	public void testWithConfigurationPropertiesOnly() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1708,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1709,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		EnvironmentTestUtils.addEnvironment(this.context,
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
1710,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
1711,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
1712,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
1713,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
1714,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1715,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1716,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1717,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1718,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1719,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1720,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1721,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1722,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1723,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1724,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1725,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1726,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1727,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1728,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1729,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1730,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations()).isEmpty();
    }"
1731,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations()).hasSize(2);
    }"
1732,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations()).hasSize(1);
	}"
1733,"	public void test() {
		String output = out.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
1734,"	public void test() {
		String output = out.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
1735,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1736,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1737,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
	}"
1738,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
1739,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1740,"	public void testWithConfig() {
		// test for compatibility with 1.0.x
		TestPropertyValues.of(""mybatis.config:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1741,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1742,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1743,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1744,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
1745,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
1746,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
1747,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
1748,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
1749,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
1750,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
1751,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1752,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1753,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
	}"
1754,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1755,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1756,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1757,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
1758,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1759,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
1760,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
1761,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1762,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1763,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
1764,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
1765,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
1766,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
1767,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
1768,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1769,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1770,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1771,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1772,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1773,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1774,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1775,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1776,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1777,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1778,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1779,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1780,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1781,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1782,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1783,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1784,"	public void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, String>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size(), is(2));

		// assert for default-scripting-language
		{
			Map<String, String> element = properties.get(0);
			assertThat(element.get(""sourceType""), is(""org.apache.ibatis.session.Configuration""));
			assertThat(element.get(""defaultValue""), is(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver""));
			assertThat(element.get(""name""), is(""mybatis.configuration.default-scripting-language""));
			assertThat(element.get(""type""), is(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>""));
		}

		// assert for default-enum-type-handler
		{
		  Map<String, String> element = properties.get(1);"
1785,"  public String getConfigLocation() {
    return this.configLocation;
  }"
1786,"  public void setConfigLocation(String configLocation) {
    this.configLocation = configLocation;
  }"
1787,"  public String[] getMapperLocations() {
    return this.mapperLocations;
  }"
1788,"  public void setMapperLocations(String[] mapperLocations) {
    this.mapperLocations = mapperLocations;
  }"
1789,"  public String getTypeHandlersPackage() {
    return this.typeHandlersPackage;
  }"
1790,"  public void setTypeHandlersPackage(String typeHandlersPackage) {
    this.typeHandlersPackage = typeHandlersPackage;
  }"
1791,"  public String getTypeAliasesPackage() {
    return this.typeAliasesPackage;
  }"
1792,"  public void setTypeAliasesPackage(String typeAliasesPackage) {
    this.typeAliasesPackage = typeAliasesPackage;
  }"
1793,"  public boolean isCheckConfigLocation() {
    return this.checkConfigLocation;
  }"
1794,"  public void setCheckConfigLocation(boolean checkConfigLocation) {
    this.checkConfigLocation = checkConfigLocation;
  }"
1795,"  public ExecutorType getExecutorType() {
    return this.executorType;
  }"
1796,"  public void setExecutorType(ExecutorType executorType) {
    this.executorType = executorType;
  }"
1797,"  public Properties getConfigurationProperties() {
    return configurationProperties;
  }"
1798,"  public void setConfigurationProperties(Properties configurationProperties) {
    this.configurationProperties = configurationProperties;
  }"
1799,"  public Configuration getConfiguration() {
    return configuration;
  }"
1800,"  public void setConfiguration(Configuration configuration) {
    this.configuration = configuration;
  }"
1801,"  public Resource[] resolveMapperLocations() {
    ResourcePatternResolver resourceResolver = new PathMatchingResourcePatternResolver();
    List<Resource> resources = new ArrayList<Resource>();
    if (this.mapperLocations != null) {
      for (String mapperLocation : this.mapperLocations) {
        try {
          Resource[] mappers = resourceResolver.getResources(mapperLocation);
          resources.addAll(Arrays.asList(mappers));
        } catch (IOException e) {
          // ignore
        }
      }
    }
    return resources.toArray(new Resource[resources.size()]);
  }"
1802,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1803,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1804,"	public void testNoDataSource() throws Exception {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
	}"
1805,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
1806,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1807,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1808,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1809,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1810,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
1811,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
1812,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
1813,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
1814,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
1815,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
1816,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
1817,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1818,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1819,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
	}"
1820,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1821,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1822,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1823,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
1824,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1825,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
1826,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
1827,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1828,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1829,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
1830,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
1831,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
1832,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
1833,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
1834,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1835,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1836,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1837,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1838,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1839,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1840,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1841,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1842,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1843,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1844,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1845,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1846,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1847,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1848,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1849,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1850,"  void customize(Configuration configuration);

}"
1851,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1852,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1853,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1854,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1855,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1856,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1857,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1858,"  public boolean isValid() {
    return true;
  }"
1859,"  protected List<String> list(URL url, String path) throws IOException {
    Resource[] resources = resourceResolver.getResources(""classpath*:"" + path + ""/**/*.class"");
    return Stream.of(resources)
        .map(resource -> preserveSubpackageName(resource, path))"
1860,"  private static String preserveSubpackageName(final Resource resource, final String rootPath) {
    try {
      final String uriStr = resource.getURI().toString();"
1861,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1862,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1863,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
1864,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1865,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1866,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1867,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1868,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1869,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1870,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1871,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
1872,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1873,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1874,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1875,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1876,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1877,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1878,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1879,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
1880,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
1881,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
1882,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
1883,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1884,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1885,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1886,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1887,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
1888,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
1889,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
1890,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
1891,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
1892,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
1893,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
1894,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1895,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1896,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
	}"
1897,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1898,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1899,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1900,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
1901,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1902,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
1903,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
1904,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1905,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1906,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
1907,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
1908,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
1909,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
1910,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
1911,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
1912,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
1913,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
1914,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
1915,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1916,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1917,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1918,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1919,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1920,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1921,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1922,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1923,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1924,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1925,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1926,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
1927,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
1928,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
1929,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
1930,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
1931,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1932,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1933,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
1934,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1935,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1936,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1937,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1938,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1939,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: : "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output direcrory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);"
1940,"    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }"
1941,"  public void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
1942,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
1943,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
1944,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
1945,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
1946,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
1947,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
1948,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
1949,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
1950,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
1951,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
1952,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
1953,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
1954,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
1955,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1956,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1957,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
1958,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1959,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
1960,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
1961,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
1962,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
1963,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
1964,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
1965,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
1966,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1967,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1968,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
1969,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
1970,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
1971,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
1972,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
1973,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
1974,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
1975,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
1976,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1977,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
1978,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
1979,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
1980,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
1981,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
1982,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
1983,"	public void testTypeAliasesSuperTypeIsSpecify() {
		EnvironmentTestUtils
			.addEnvironment(
				this.context,
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"");
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
1984,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
1985,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
1986,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
1987,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
1988,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
1989,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
1990,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
1991,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1992,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
1993,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
1994,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
1995,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
1996,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
1997,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
1998,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
1999,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2000,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2001,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2002,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2003,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2004,"	public Long getId() {
		return this.id;
	}"
2005,"	public void setId(Long id) {
		this.id = id;
	}"
2006,"	public String getName() {
		return this.name;
	}"
2007,"	public void setName(String name) {
		this.name = name;
	}"
2008,"	public Long getFirst() {
		return first;
	}"
2009,"	public void setFirst(Long first) {
		this.first = first;
	}"
2010,"	public String getLast() {
		return last;
	}"
2011,"	public void setLast(String last) {
		this.last = last;
	}"
2012,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2013,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
2014,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2015,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2016,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2017,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2018,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2019,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2020,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2021,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2022,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2023,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2024,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2025,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2026,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2027,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2028,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2029,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2030,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2031,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2032,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2033,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2034,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2035,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2036,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2037,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2038,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2039,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2040,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2041,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2042,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2043,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2044,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2045,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2046,"	public void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2047,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2048,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2049,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2050,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2051,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2052,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2053,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2054,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2055,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
2056,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2057,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
2058,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
2059,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2060,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2061,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2062,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2063,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2064,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2065,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2066,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2067,"	public Long getId() {
		return this.id;
	}"
2068,"	public void setId(Long id) {
		this.id = id;
	}"
2069,"	public String getName() {
		return this.name;
	}"
2070,"	public void setName(String name) {
		this.name = name;
	}"
2071,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: : "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output direcrory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);"
2072,"    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }"
2073,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2074,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2075,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2076,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2077,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2078,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      logger.debug(""Searching for mappers annotated with @Mapper"");

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);

      try {
        if (this.resourceLoader != null) {"
2079,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
2080,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
2081,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2082,"	public void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, String>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size(), is(2));

		// assert for default-scripting-language
		{
			Map<String, String> element = properties.get(0);
			assertThat(element.get(""sourceType""), is(""org.apache.ibatis.session.Configuration""));
			assertThat(element.get(""defaultValue""), is(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver""));
			assertThat(element.get(""name""), is(""mybatis.configuration.default-scripting-language""));
			assertThat(element.get(""type""), is(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>""));
		}

		// assert for default-enum-type-handler
		{
		  Map<String, String> element = properties.get(1);"
2083,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2084,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
2085,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2086,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2087,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2088,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2089,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2090,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2091,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2092,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2093,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2094,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2095,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2096,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2097,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2098,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2099,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2100,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2101,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2102,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2103,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2104,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2105,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2106,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2107,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2108,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2109,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2110,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2111,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2112,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2113,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2114,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2115,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2116,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2117,"	public void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2118,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2119,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2120,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2121,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2122,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2123,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2124,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2125,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2126,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
2127,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2128,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
2129,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
2130,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2131,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2132,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2133,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2134,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2135,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2136,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2137,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2138,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations()).isEmpty();
    }"
2139,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations()).hasSize(2);
    }"
2140,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations()).hasSize(1);
	}"
2141,"	public void test() {
		String output = out.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
2142,"  public void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2143,"	public void test() {
		String output = out.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
2144,"  public void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2145,"  public void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
2146,"  public void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
2147,"  public void testExcludeFilter() {
    assertThat(service).isNull();
  }"
2148,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2149,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2150,"  public void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2151,"  public void didNotInjectExampleComponent() {
    this.thrown.expect(NoSuchBeanDefinitionException.class);
    this.applicationContext.getBean(ExampleComponent.class);
  }"
2152,"	public void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, String>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size()).isEqualTo(2);

		// assert for default-scripting-language
		{
			Map<String, String> element = properties.get(0);
			assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
			assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
			assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
			assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
		}

		// assert for default-enum-type-handler
		{
		  Map<String, String> element = properties.get(1);"
2153,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations()).isEmpty();
    }"
2154,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations()).hasSize(2);
    }"
2155,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations()).hasSize(1);
	}"
2156,"  public void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2157,"  public void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2158,"  public void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
2159,"  public void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
2160,"  public void testExcludeFilter() {
    assertThat(service).isNull();
  }"
2161,"  public void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2162,"  public void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2163,"  public void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2164,"  public void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -> {
      this.applicationContext.getBean(ExampleComponent.class);"
2165,"    public void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations()).isEmpty();
    }"
2166,"    public void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations()).hasSize(2);
    }"
2167,"	public void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations()).hasSize(1);
	}"
2168,"  public void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2169,"  public void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
2170,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2171,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
2172,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2173,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2174,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2175,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2176,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2177,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2178,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2179,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2180,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2181,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2182,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2183,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2184,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2185,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2186,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2187,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2188,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2189,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2190,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2191,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2192,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2193,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2194,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2195,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2196,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2197,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2198,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2199,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2200,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2201,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2202,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2203,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2204,"	public void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2205,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2206,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2207,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2208,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2209,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2210,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2211,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2212,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2213,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
2214,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2215,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
2216,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
2217,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2218,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2219,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2220,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2221,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2222,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2223,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2224,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2225,"        public void beforeEach(ExtensionContext context) throws Exception {
            getOutputCapture(context).captureOutput();
        }"
2226,"        public void afterEach(ExtensionContext context) throws Exception {
            OutputCapture outputCapture = getOutputCapture(context);
            try {
                if (!outputCapture.matchers.isEmpty()) {"
2227,"        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
            boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
            return isTestMethodLevel && isOutputCapture;
        }"
2228,"        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            return getOutputCapture(extensionContext);
        }"
2229,"        private OutputCapture getOutputCapture(ExtensionContext context) {
            return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
        }"
2230,"        private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
            return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
        }"
2231,"        private Store getStore(ExtensionContext context) {
            return context.getStore(Namespace.create(getClass(), context.getRequiredTestMethod()));
        }"
2232,"        void captureOutput() {
            this.copy = new ByteArrayOutputStream();
            this.captureOut = new CaptureOutputStream(System.out, this.copy);
            this.captureErr = new CaptureOutputStream(System.err, this.copy);
            System.setOut(new PrintStream(this.captureOut));
            System.setErr(new PrintStream(this.captureErr));
        }"
2233,"        void releaseOutput() {
            System.setOut(this.captureOut.getOriginal());
            System.setErr(this.captureErr.getOriginal());
            this.copy = null;
        }"
2234,"        private void flush() {
            try {
                this.captureOut.flush();"
2235,"        public void expect(Matcher<? super String> matcher) {
            this.matchers.add(matcher);
        }"
2236,"        public String toString() {
            flush();
            return this.copy.toString();
        }"
2237,"            PrintStream getOriginal() {
                return this.original;
            }"
2238,"            public void write(int b) throws IOException {
                this.copy.write(b);
                this.original.write(b);
                this.original.flush();
            }"
2239,"            public void write(byte[] b) throws IOException {
                write(b, 0, b.length);
            }"
2240,"            public void write(byte[] b, int off, int len) throws IOException {
                this.copy.write(b, off, len);
                this.original.write(b, off, len);
            }"
2241,"            public void flush() throws IOException {
                this.copy.flush();
                this.original.flush();
            }"
2242,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
2243,"        public void beforeEach(ExtensionContext context) throws Exception {
            getOutputCapture(context).captureOutput();
        }"
2244,"        public void afterEach(ExtensionContext context) throws Exception {
            OutputCapture outputCapture = getOutputCapture(context);
            try {
                if (!outputCapture.matchers.isEmpty()) {"
2245,"        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
            boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
            return isTestMethodLevel && isOutputCapture;
        }"
2246,"        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            return getOutputCapture(extensionContext);
        }"
2247,"        private OutputCapture getOutputCapture(ExtensionContext context) {
            return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
        }"
2248,"        private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
            return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
        }"
2249,"        private Store getStore(ExtensionContext context) {
            return context.getStore(Namespace.create(getClass(), context.getRequiredTestMethod()));
        }"
2250,"        void captureOutput() {
            this.copy = new ByteArrayOutputStream();
            this.captureOut = new CaptureOutputStream(System.out, this.copy);
            this.captureErr = new CaptureOutputStream(System.err, this.copy);
            System.setOut(new PrintStream(this.captureOut));
            System.setErr(new PrintStream(this.captureErr));
        }"
2251,"        void releaseOutput() {
            System.setOut(this.captureOut.getOriginal());
            System.setErr(this.captureErr.getOriginal());
            this.copy = null;
        }"
2252,"        private void flush() {
            try {
                this.captureOut.flush();"
2253,"        public void expect(Matcher<? super String> matcher) {
            this.matchers.add(matcher);
        }"
2254,"        public String toString() {
            flush();
            return this.copy.toString();
        }"
2255,"            PrintStream getOriginal() {
                return this.original;
            }"
2256,"            public void write(int b) throws IOException {
                this.copy.write(b);
                this.original.write(b);
                this.original.flush();
            }"
2257,"            public void write(byte[] b) throws IOException {
                write(b, 0, b.length);
            }"
2258,"            public void write(byte[] b, int off, int len) throws IOException {
                this.copy.write(b, off, len);
                this.original.write(b, off, len);
            }"
2259,"            public void flush() throws IOException {
                this.copy.flush();
                this.original.flush();
            }"
2260,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
2261,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
2262,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
2263,"        public void beforeAll(ExtensionContext context) throws Exception {
            getOutputCapture(context).captureOutput();
        }"
2264,"        public void afterAll(ExtensionContext context) throws Exception {
            getOutputCapture(context).releaseOutput();
        }"
2265,"        public void afterEach(ExtensionContext context) throws Exception {
            OutputCapture outputCapture = getOutputCapture(context);
            try {
                if (!outputCapture.matchers.isEmpty()) {"
2266,"        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
            boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
            return isTestMethodLevel && isOutputCapture;
        }"
2267,"        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            return getOutputCapture(extensionContext);
        }"
2268,"        private OutputCapture getOutputCapture(ExtensionContext context) {
            return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
        }"
2269,"        private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
            return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
        }"
2270,"        private Store getStore(ExtensionContext context) {
            return context.getStore(Namespace.create(getClass()));
        }"
2271,"        void captureOutput() {
            this.copy = new ByteArrayOutputStream();
            this.captureOut = new CaptureOutputStream(System.out, this.copy);
            this.captureErr = new CaptureOutputStream(System.err, this.copy);
            System.setOut(new PrintStream(this.captureOut));
            System.setErr(new PrintStream(this.captureErr));
        }"
2272,"        void releaseOutput() {
            System.setOut(this.captureOut.getOriginal());
            System.setErr(this.captureErr.getOriginal());
            this.copy = null;
        }"
2273,"        private void flush() {
            try {
                this.captureOut.flush();"
2274,"        public void expect(Matcher<? super String> matcher) {
            this.matchers.add(matcher);
        }"
2275,"        public String toString() {
            flush();
            return this.copy.toString();
        }"
2276,"        void reset() {
            this.matchers.clear();
            this.copy.reset();
        }"
2277,"            PrintStream getOriginal() {
                return this.original;
            }"
2278,"            public void write(int b) throws IOException {
                this.copy.write(b);
                this.original.write(b);
                this.original.flush();
            }"
2279,"            public void write(byte[] b) throws IOException {
                write(b, 0, b.length);
            }"
2280,"            public void write(byte[] b, int off, int len) throws IOException {
                this.copy.write(b, off, len);
                this.original.write(b, off, len);
            }"
2281,"            public void flush() throws IOException {
                this.copy.flush();
                this.original.flush();
            }"
2282,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
2283,"        public void beforeAll(ExtensionContext context) throws Exception {
            getOutputCapture(context).captureOutput();
        }"
2284,"        public void afterAll(ExtensionContext context) throws Exception {
            getOutputCapture(context).releaseOutput();
        }"
2285,"        public void afterEach(ExtensionContext context) throws Exception {
            OutputCapture outputCapture = getOutputCapture(context);
            try {
                if (!outputCapture.matchers.isEmpty()) {"
2286,"        public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
            boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
            return isTestMethodLevel && isOutputCapture;
        }"
2287,"        public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
            return getOutputCapture(extensionContext);
        }"
2288,"        private OutputCapture getOutputCapture(ExtensionContext context) {
            return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
        }"
2289,"        private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
            return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
        }"
2290,"        private Store getStore(ExtensionContext context) {
            return context.getStore(Namespace.create(getClass()));
        }"
2291,"        void captureOutput() {
            this.copy = new ByteArrayOutputStream();
            this.captureOut = new CaptureOutputStream(System.out, this.copy);
            this.captureErr = new CaptureOutputStream(System.err, this.copy);
            System.setOut(new PrintStream(this.captureOut));
            System.setErr(new PrintStream(this.captureErr));
        }"
2292,"        void releaseOutput() {
            System.setOut(this.captureOut.getOriginal());
            System.setErr(this.captureErr.getOriginal());
            this.copy = null;
        }"
2293,"        private void flush() {
            try {
                this.captureOut.flush();"
2294,"        public void expect(Matcher<? super String> matcher) {
            this.matchers.add(matcher);
        }"
2295,"        public String toString() {
            flush();
            return this.copy.toString();
        }"
2296,"        void reset() {
            this.matchers.clear();
            this.copy.reset();
        }"
2297,"            PrintStream getOriginal() {
                return this.original;
            }"
2298,"            public void write(int b) throws IOException {
                this.copy.write(b);
                this.original.write(b);
                this.original.flush();
            }"
2299,"            public void write(byte[] b) throws IOException {
                write(b, 0, b.length);
            }"
2300,"            public void write(byte[] b, int off, int len) throws IOException {
                this.copy.write(b, off, len);
                this.original.write(b, off, len);
            }"
2301,"            public void flush() throws IOException {
                this.copy.flush();
                this.original.flush();
            }"
2302,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
2303,"	public void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2304,"	public void closeContext() {
		if (this.context != null) {
			this.context.close();"
2305,"	public void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2306,"	public void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2307,"	public void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2308,"	public void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2309,"	public void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2310,"	public void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2311,"	public void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2312,"	public void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2313,"	public void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2314,"	public void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2315,"	public void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2316,"	public void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2317,"	public void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2318,"	public void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2319,"	public void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2320,"	public void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2321,"	public void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2322,"	public void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2323,"	public void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2324,"	public void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2325,"	public void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2326,"	public void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2327,"	public void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2328,"	public void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2329,"	public void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2330,"	public void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2331,"	public void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2332,"	public void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2333,"	public void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2334,"	public void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2335,"	public void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2336,"	public void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2337,"	public void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2338,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2339,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2340,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2341,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2342,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2343,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2344,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2345,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2346,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
2347,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2348,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
2349,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
2350,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2351,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2352,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2353,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2354,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2355,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2356,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2357,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2358,"	void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, String>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size()).isEqualTo(2);

		// assert for default-scripting-language
		{
			Map<String, String> element = properties.get(0);
			assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
			assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
			assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
			assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
		}

		// assert for default-enum-type-handler
		{
		  Map<String, String> element = properties.get(1);"
2359,"	void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2360,"	void closeContext() {
		if (this.context != null) {
			this.context.close();"
2361,"	void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2362,"	void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2363,"	void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2364,"	void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2365,"	void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2366,"	void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2367,"	void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2368,"	void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2369,"	void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2370,"	void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2371,"	void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2372,"	void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2373,"	void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2374,"	void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2375,"	void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2376,"	void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2377,"	void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2378,"	void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2379,"	void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2380,"	void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2381,"	void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2382,"	void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2383,"	void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2384,"	void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2385,"	void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2386,"	void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2387,"	void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2388,"	void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2389,"	void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2390,"	void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2391,"	void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2392,"	void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2393,"	void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2394,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2395,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2396,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2397,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2398,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2399,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2400,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2401,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2402,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.getTypeHandlerRegistry()
						.register(new DummyTypeHandler());"
2403,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return new ConfigurationCustomizer() {
				@Override"
2404,"				public void customize(org.apache.ibatis.session.Configuration configuration) {
					configuration.addCache(new PerpetualCache(""test""));
				}"
2405,"		public Object intercept(Invocation invocation) throws Throwable {
			return ""Test"";
		}"
2406,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2407,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		public MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		public MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2408,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2409,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2410,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2411,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2412,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2413,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2414,"    void emptyMapperLocations() {
        MybatisProperties properties = new MybatisProperties();
        assertThat(properties.resolveMapperLocations()).isEmpty();
    }"
2415,"    void twoLocations() {
        MybatisProperties properties = new MybatisProperties();
        properties
                .setMapperLocations(new String[] {
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
                        ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
        assertThat(properties.resolveMapperLocations()).hasSize(2);
    }"
2416,"	void twoLocationsWithOneIncorrectLocation() {
		MybatisProperties properties = new MybatisProperties();
		properties
				.setMapperLocations(new String[] {
						""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
						""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
		assertThat(properties.resolveMapperLocations()).hasSize(1);
	}"
2417,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
	}"
2418,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2419,"	void test(OutputCapture outputCapture) {
		String output = outputCapture.toString();
		assertThat(output).contains(""1,San Francisco,CA,US"");
		assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
	}"
2420,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2421,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
2422,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
2423,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
2424,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2425,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<String, Object>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2426,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2427,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -> {
      this.applicationContext.getBean(ExampleComponent.class);"
2428,"	void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2429,"	void closeContext() {
		if (this.context != null) {
			this.context.close();"
2430,"	void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2431,"	void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2432,"	void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2433,"	void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2434,"	void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2435,"	void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2436,"	void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2437,"	void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2438,"	void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2439,"	void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2440,"	void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2441,"	void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2442,"	void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2443,"	void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2444,"	void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2445,"	void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2446,"	void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2447,"	void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2448,"	void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2449,"	void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2450,"	void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2451,"	void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2452,"	void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2453,"	void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2454,"	void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2455,"	void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2456,"	void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2457,"	void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2458,"	void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2459,"	void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2460,"	void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2461,"	void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2462,"	void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2463,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2464,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2465,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2466,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2467,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2468,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2469,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2470,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
		}"
2471,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return configuration -> configuration.addCache(new PerpetualCache(""test""));
		}"
2472,"		public Object intercept(Invocation invocation) {
			return ""Test"";
		}"
2473,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2474,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2475,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2476,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2477,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2478,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2479,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2480,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2481,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2482,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2483,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2484,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () ->
      this.applicationContext.getBean(ExampleComponent.class)"
2485,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2486,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2487,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2488,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2489,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2490,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
      if (this.resourceLoader != null) {
        scanner.setResourceLoader(this.resourceLoader);
      }
      scanner.setAnnotationClass(Mapper.class);
      scanner.registerFilters();
      scanner.doScan(StringUtils.toStringArray(packages));
"
2491,"    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
    }"
2492,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
2493,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2494,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2495,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2496,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2497,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2498,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2499,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
      if (this.resourceLoader != null) {
        scanner.setResourceLoader(this.resourceLoader);
      }
      scanner.setAnnotationClass(Mapper.class);
      scanner.registerFilters();
      scanner.doScan(StringUtils.toStringArray(packages));
"
2500,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
2501,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
2502,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2503,"	public static void main(String[] args) {
		SpringApplication.run(SampleAnnotationApplication.class, args);
	}"
2504,"	public void run(String... args) {
		System.out.println(this.cityMapper.findByState(""CA""));
	}"
2505,"	public static void main(String[] args) {
		SpringApplication.run(SampleXmlApplication.class, args);
	}"
2506,"	public void run(String... args) {
		System.out.println(this.cityDao.selectCityById(1));
		System.out.println(this.hotelMapper.selectByCityId(1));
	}"
2507,"	Hotel selectByCityId(int cityId);

}"
2508,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
2509,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:"
2510,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
2511,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
2512,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
2513,"	City findByState(@Param(""state"") String state);

}"
2514,"  public boolean isValid() {
    return true;
  }"
2515,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = url.toString();
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources)
        .map(resource -> preserveSubpackageName(baseUrlString, resource, path))"
2516,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource, final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" :  ""/"")"
2517,"	void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2518,"	void closeContext() {
		if (this.context != null) {
			this.context.close();"
2519,"	void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2520,"	void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2521,"	void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2522,"	void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2523,"	void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2524,"	void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2525,"	void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2526,"	void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2527,"	void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2528,"	void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2529,"	void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2530,"	void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2531,"	void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2532,"	void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2533,"	void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2534,"	void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2535,"	void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2536,"	void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2537,"	void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2538,"	void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2539,"	void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2540,"	void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2541,"	void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2542,"	void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2543,"	void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2544,"	void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2545,"	void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2546,"	void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2547,"	void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2548,"	void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2549,"	void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2550,"	void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2551,"	void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2552,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2553,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2554,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2555,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2556,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2557,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2558,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2559,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
		}"
2560,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return configuration -> configuration.addCache(new PerpetualCache(""test""));
		}"
2561,"		public Object intercept(Invocation invocation) {
			return ""Test"";
		}"
2562,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2563,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

}"
2564,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2565,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2566,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2567,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2568,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2569,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2570,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
2571,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
2572,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2573,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2574,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2575,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () ->
      this.applicationContext.getBean(ExampleComponent.class)"
2576,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2577,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2578,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2579,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2580,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2581,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      ClassPathMapperScanner scanner = new ClassPathMapperScanner(registry);
      if (this.resourceLoader != null) {
        scanner.setResourceLoader(this.resourceLoader);
      }
      scanner.setAnnotationClass(Mapper.class);
      scanner.registerFilters();
      scanner.doScan(StringUtils.toStringArray(packages));
"
2582,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
2583,"    public void setResourceLoader(ResourceLoader resourceLoader) {
      this.resourceLoader = resourceLoader;
    }"
2584,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2585,"	void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2586,"	void closeContext() {
		if (this.context != null) {
			this.context.close();"
2587,"	void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2588,"	void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2589,"	void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2590,"	void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2591,"	void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2592,"	void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2593,"	void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2594,"	void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2595,"	void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2596,"	void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2597,"	void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2598,"	void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2599,"	void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2600,"	void testWithTypeHandlers() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisTypeHandlerConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
				.getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
		this.context.close();
	}"
2601,"	void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2602,"	void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2603,"	void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2604,"	void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2605,"	void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2606,"	void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2607,"	void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2608,"	void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2609,"	void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2610,"	void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2611,"	void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2612,"	void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2613,"	void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2614,"	void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2615,"	void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2616,"	void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2617,"	void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2618,"	void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2619,"	void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2620,"	void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2621,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2622,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2623,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2624,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2625,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2626,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2627,"		public MyTypeHandler myTypeHandler() {
			return new MyTypeHandler();
		}"
2628,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2629,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
		}"
2630,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return configuration -> configuration.addCache(new PerpetualCache(""test""));
		}"
2631,"		public Object intercept(Invocation invocation) {
			return ""Test"";
		}"
2632,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2633,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

	static class MyTypeHandler extends BaseTypeHandler<UUID> {

		@Override
		public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) throws SQLException {

		}

		@Override
		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}

	}

}"
2634,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2635,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2636,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2637,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2638,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2639,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2640,"		public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) throws SQLException {

		}

		@Override
		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}

	}

}"
2641,"		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}"
2642,"		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}"
2643,"		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}"
2644,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2645,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2646,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2647,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2648,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2649,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper =  new BeanWrapperImpl(MapperScannerConfigurer.class);
      Stream.of(beanWrapper.getPropertyDescriptors())
          // Need to mybatis-spring 2.0.2+
          .filter(x -> x.getName().equals(""lazyInitialization"")).findAny()
          .ifPresent(x -> builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}""));
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
2650,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
2651,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2652,"	void testProperties() throws IOException {

		DocumentContext documentContext = JsonPath
				.parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
						.getInputStream());

		List<Map<String, Object>> properties = documentContext.read(""$.properties"");

		assertThat(properties.size()).isEqualTo(3);

		// assert for default-scripting-language
		{
			Map<String, Object> element = properties.get(0);
			assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
			assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
			assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
			assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
		}

		// assert for default-enum-type-handler
		{
		  Map<String, Object> element = properties.get(1);
		  assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
		  assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.type.EnumTypeHandler"");
		  assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-enum-type-handler"");
		  assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.type.TypeHandler>"");
		}

		// assert for lazy-initialization
		{
			Map<String, Object> element = properties.get(2);"
2653,"	void init() {
		this.context = new AnnotationConfigApplicationContext();
	}"
2654,"	void closeContext() {
		if (this.context != null) {
			this.context.close();"
2655,"	void testNoDataSource() {
		this.context.register(MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2656,"	void testMultipleDataSource() {
		this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
	}"
2657,"	void testSingleCandidateDataSource() {
		this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
	}"
2658,"	void testDefaultConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class, MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
	}"
2659,"	void testScanWithLazy() {
		TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisScanMapperConfiguration.class,
				MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
		this.context.getBean(CityMapper.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
	}"
2660,"	void testAutoScanWithLazy() {
		TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
		this.context.getBean(CityMapper.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
	}"
2661,"	void testWithConfigLocation() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2662,"	void testWithCheckConfigLocationFileExists() {
		TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"",
				""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2663,"	void testWithCheckConfigLocationFileNotSpecify() {
		TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
	}"
2664,"	void testWithCheckConfigLocationFileDoesNotExists() {

		TestPropertyValues.of(""mybatis.config-location:foo.xml"",
				""mybatis.check-config-location=true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2665,"	void testWithTypeHandlersPackage() {
		TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry();
		assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
	}"
2666,"	void testWithMapperLocation() {
		TestPropertyValues.of(
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
	}"
2667,"	void testWithExecutorType() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MybatisMapperConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
	}"
2668,"	void testDefaultBootConfiguration() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
	}"
2669,"	void testWithInterceptors() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
		this.context.close();
	}"
2670,"	void testWithTypeHandlers() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisTypeHandlerConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
				.getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
		this.context.close();
	}"
2671,"	void testWithDatabaseIdProvider() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				DatabaseProvidersConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
	}"
2672,"	void testMixedWithConfigurationFileAndInterceptor() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisInterceptorConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
	}"
2673,"	void testMixedWithConfigurationFileAndDatabaseIdProvider() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2674,"	void testMixedWithConfigurationFileAndTypeHandlersPackage() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2675,"	void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
	}"
2676,"	void testMixedWithFullConfigurations() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config-settings-only.xml"",
				""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
				""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
				""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
				""mybatis.executor-type=REUSE"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisBootMapperScanAutoConfiguration.class,
				MybatisInterceptorConfiguration.class,
				DatabaseProvidersConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
				SqlSessionFactory.class).getConfiguration();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
		assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
		assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(configuration.getMappedStatementNames()).hasSize(4);
		assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
		assertThat(configuration.getMappedStatementNames()).contains(""findById"");
		assertThat(configuration.getMappedStatementNames()).contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
		assertThat(configuration.getInterceptors()).hasSize(1);
		assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
		assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
	}"
2677,"	void testWithMyBatisConfiguration() {
		TestPropertyValues.of(
				""mybatis.configuration.map-underscore-to-camel-case:true"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
	}"
2678,"	void testWithMyBatisConfigurationCustomizeByJavaConfig() {
		TestPropertyValues.of(
				""mybatis.configuration.default-fetch-size:100"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				MybatisPropertiesConfigurationCustomizer.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
				.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
	}"
2679,"	void testWithMyBatisConfigurationCustomizer() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisAutoConfiguration.class,
			MyBatisConfigurationCustomizerConfiguration.class);
		this.context.refresh();
		SqlSessionFactory sqlSessionFactory = this.context
			.getBean(SqlSessionFactory.class);
		assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class)).isInstanceOf(DummyTypeHandler.class);
		assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
	}"
2680,"	void testConfigFileAndConfigurationWithTogether() {
		TestPropertyValues.of(
				""mybatis.config-location:mybatis-config.xml"",
				""mybatis.configuration.default-statement-timeout:30"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class);

		try {
			this.context.refresh();"
2681,"	void testWithoutConfigurationVariablesAndProperties() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).isEmpty();
	}"
2682,"	void testWithConfigurationVariablesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
	}"
2683,"	void testWithConfigurationPropertiesOnly() {
		TestPropertyValues.of(
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2684,"	void testWithConfigurationVariablesAndPropertiesOtherKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key1:value1"",
				""mybatis.configuration-properties.key2:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(2);
		assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
		assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
	}"
2685,"	void testWithConfigurationVariablesAndPropertiesSameKey() {
		TestPropertyValues.of(
				""mybatis.configuration.variables.key:value1"",
				""mybatis.configuration-properties.key:value2"")
				.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();

		Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
		assertThat(variables).hasSize(1);
		assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
	}"
2686,"	void testCustomSqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key"")).isEqualTo(""value"");
	}"
2687,"	void testMySqlSessionFactory() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionFactoryConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
	}"
2688,"	void testCustomSqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, CustomSqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
	}"
2689,"	void testMySqlSessionTemplate() {
		this.context.register(EmbeddedDataSourceConfiguration.class,
				MybatisAutoConfiguration.class, MySqlSessionTemplateConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
		assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
	}"
2690,"	void testTypeAliasesSuperTypeIsSpecify() {
		TestPropertyValues.of(
			""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
			""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
			.applyTo(this.context);
		this.context.register(EmbeddedDataSourceConfiguration.class,
			MybatisBootMapperScanAutoConfiguration.class);
		this.context.refresh();

		org.apache.ibatis.session.Configuration configuration = this.context.getBean(
			SqlSessionFactory.class).getConfiguration();
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
		assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
	}"
2691,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2692,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2693,"		DataSource dataSourceMaster() {
			return Mockito.mock(DataSource.class);
		}"
2694,"		DataSource dataSourceSlave() {
			return Mockito.mock(DataSource.class);
		}"
2695,"		public CityMapperImpl cityMapper() {
			return new CityMapperImpl();
		}"
2696,"		public MyInterceptor myInterceptor() {
			return new MyInterceptor();
		}"
2697,"		public MyTypeHandler myTypeHandler() {
			return new MyTypeHandler();
		}"
2698,"		void customize(MybatisProperties properties) {
			properties.getConfiguration().getTypeHandlerRegistry()
					.register(new DummyTypeHandler());"
2699,"		ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
			return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
		}"
2700,"		ConfigurationCustomizer cacheConfigurationCustomizer() {
			return configuration -> configuration.addCache(new PerpetualCache(""test""));
		}"
2701,"		public Object intercept(Invocation invocation) {
			return ""Test"";
		}"
2702,"		public Object plugin(Object target) {
			return Plugin.wrap(target, this);
		}"
2703,"		public void setProperties(Properties properties) {

		}
	}

	@Configuration
	static class DatabaseProvidersConfiguration {

		@Bean
		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}

		@Bean
		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}

	}

	@Configuration
	static class CustomSqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}
	}

	@Configuration
	static class MySqlSessionFactoryConfiguration {
		@Bean
		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}
	}

	@Configuration
	static class CustomSqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}
	}

	@Configuration
	static class MySqlSessionTemplateConfiguration {
		@Bean
		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}
	}

	static class MySqlSessionFactory extends DefaultSqlSessionFactory {
		MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
			super(configuration);
		}
	}

	static class MySqlSessionTemplate extends SqlSessionTemplate {
		MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
			super(sqlSessionFactory);
		}
	}

	static class MyTypeHandler extends BaseTypeHandler<UUID> {

		@Override
		public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) throws SQLException {

		}

		@Override
		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}

	}

}"
2704,"		public PropertiesFactoryBean vendorProperties() {
			Properties properties = new Properties();
			properties.put(""SQL Server"", ""sqlserver"");
			properties.put(""DB2"", ""db2"");
			properties.put(""H2"", ""h2"");

			PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
			propertiesFactoryBean.setProperties(properties);
			return propertiesFactoryBean;
		}"
2705,"		public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
			VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
			databaseIdProvider.setProperties(vendorProperties);
			return databaseIdProvider;
		}"
2706,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
			sqlSessionFactoryBean.setDataSource(dataSource);
			Properties props = new Properties();
			props.setProperty(""key"", ""value"");
			sqlSessionFactoryBean.setConfigurationProperties(props);
			return sqlSessionFactoryBean.getObject();
		}"
2707,"		public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
			MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
			sqlSessionFactory.getConfiguration().setEnvironment(new Environment("""",new SpringManagedTransactionFactory(),dataSource));
			return sqlSessionFactory;
		}"
2708,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
		}"
2709,"		public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory){
			return new MySqlSessionTemplate(sqlSessionFactory);
		}"
2710,"		public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) throws SQLException {

		}

		@Override
		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}

		@Override
		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}

	}

}"
2711,"		public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
			return null;
		}"
2712,"		public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
			return null;
		}"
2713,"		public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
			return null;
		}"
2714,"  void customize(Configuration configuration);

}"
2715,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2716,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2717,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2718,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2719,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2720,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Stream.of(beanWrapper.getPropertyDescriptors())
          // Need to mybatis-spring 2.0.2+
          .filter(x -> x.getName().equals(""lazyInitialization"")).findAny()
          .ifPresent(x -> builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}""));
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
2721,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
2722,"    public void afterPropertiesSet() {
      logger.debug(""No {} found."", MapperFactoryBean.class.getName());
    }"
2723,"  public boolean isValid() {
    return true;
  }"
2724,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = url.toString();
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
2725,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
2726,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertThat(properties.size()).isEqualTo(3);

    // assert for default-scripting-language
    {
      Map<String, Object> element = properties.get(0);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
      assertThat(element.get(""type""))
          .isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
    }

    // assert for default-enum-type-handler
    {
      Map<String, Object> element = properties.get(1);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.type.EnumTypeHandler"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-enum-type-handler"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.type.TypeHandler>"");
    }

    // assert for lazy-initialization
    {
      Map<String, Object> element = properties.get(2);"
2727,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
2728,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
2729,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
2730,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
2731,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
2732,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
2733,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
2734,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
2735,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
2736,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
2737,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
2738,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
2739,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
  }"
2740,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
2741,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
2742,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
2743,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
2744,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
2745,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
2746,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
2747,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
2748,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
2749,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
2750,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
2751,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
2752,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
2753,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
2754,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
2755,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
2756,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
2757,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
2758,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
2759,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
2760,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
2761,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
2762,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
2763,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
2764,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
2765,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
2766,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
2767,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
2768,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
2769,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
2770,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
2771,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
2772,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
2773,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
2774,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
2775,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
2776,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
2777,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType)
        throws SQLException {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
      return null;
    }

  }

}"
2778,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
2779,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
2780,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
2781,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
2782,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
2783,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
2784,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType)
        throws SQLException {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
      return null;
    }

  }

}"
2785,"    public UUID getNullableResult(ResultSet rs, String columnName) throws SQLException {
      return null;
    }"
2786,"    public UUID getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
      return null;
    }"
2787,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
      return null;
    }"
2788,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
2789,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
2790,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
2791,"  public Long getId() {
    return this.id;
  }"
2792,"  public void setId(Long id) {
    this.id = id;
  }"
2793,"  public String getName() {
    return this.name;
  }"
2794,"  public void setName(String name) {
    this.name = name;
  }"
2795,"  public Long getFirst() {
    return first;
  }"
2796,"  public void setFirst(Long first) {
    this.first = first;
  }"
2797,"  public String getLast() {
    return last;
  }"
2798,"  public void setLast(String last) {
    this.last = last;
  }"
2799,"  public void setParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException {
  }

  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

}"
2800,"  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
2801,"  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
2802,"  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
2803,"  City findById(@Param(""cityId"") Long cityId);

}"
2804,"  public City findById(long id) {
    return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
  }"
2805,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
2806,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
2807,"  public Long getId() {
    return this.id;
  }"
2808,"  public void setId(Long id) {
    this.id = id;
  }"
2809,"  public String getName() {
    return this.name;
  }"
2810,"  public void setName(String name) {
    this.name = name;
  }"
2811,"  public String getState() {
    return this.state;
  }"
2812,"  public void setState(String state) {
    this.state = state;
  }"
2813,"  public String getCountry() {
    return this.country;
  }"
2814,"  public void setCountry(String country) {
    this.country = country;
  }"
2815,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
2816,"  City findByState(@Param(""state"") String state);

}"
2817,"    public void beforeAll(ExtensionContext context) throws Exception {
      getOutputCapture(context).captureOutput();
    }"
2818,"    public void afterAll(ExtensionContext context) throws Exception {
      getOutputCapture(context).releaseOutput();
    }"
2819,"    public void afterEach(ExtensionContext context) throws Exception {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
2820,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
2821,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
2822,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
2823,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
2824,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
2825,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
2826,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
2827,"    private void flush() {
      try {
        this.captureOut.flush();"
2828,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
2829,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
2830,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
2831,"      PrintStream getOriginal() {
        return this.original;
      }"
2832,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
2833,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
2834,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
2835,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
2836,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
2837,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2838,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
2839,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
2840,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
2841,"  public Long getId() {
    return this.id;
  }"
2842,"  public void setId(Long id) {
    this.id = id;
  }"
2843,"  public String getName() {
    return this.name;
  }"
2844,"  public void setName(String name) {
    this.name = name;
  }"
2845,"  public String getState() {
    return this.state;
  }"
2846,"  public void setState(String state) {
    this.state = state;
  }"
2847,"  public String getCountry() {
    return this.country;
  }"
2848,"  public void setCountry(String country) {
    this.country = country;
  }"
2849,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
2850,"  public Long getCity() {
    return city;
  }"
2851,"  public void setCity(Long city) {
    this.city = city;
  }"
2852,"  public String getName() {
    return name;
  }"
2853,"  public void setName(String name) {
    this.name = name;
  }"
2854,"  public String getAddress() {
    return address;
  }"
2855,"  public void setAddress(String address) {
    this.address = address;
  }"
2856,"  public String getZip() {
    return zip;
  }"
2857,"  public void setZip(String zip) {
    this.zip = zip;
  }"
2858,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
2859,"  Hotel selectByCityId(int cityId);

}"
2860,"    public void beforeAll(ExtensionContext context) throws Exception {
      getOutputCapture(context).captureOutput();
    }"
2861,"    public void afterAll(ExtensionContext context) throws Exception {
      getOutputCapture(context).releaseOutput();
    }"
2862,"    public void afterEach(ExtensionContext context) throws Exception {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
2863,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
2864,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
2865,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
2866,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
2867,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
2868,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
2869,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
2870,"    private void flush() {
      try {
        this.captureOut.flush();"
2871,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
2872,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
2873,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
2874,"      PrintStream getOriginal() {
        return this.original;
      }"
2875,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
2876,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
2877,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
2878,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
2879,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
2880,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
2881,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
2882,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
2883,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:"
2884,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
2885,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
2886,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
2887,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
2888,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
2889,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2890,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
2891,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
2892,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
2893,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
2894,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
2895,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
2896,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
2897,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
2898,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
2899,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
2900,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
2901,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
2902,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
2903,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
2904,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
2905,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
  }"
2906,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
2907,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
2908,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
2909,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
2910,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
2911,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
2912,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
2913,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
2914,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
2915,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
2916,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
2917,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
2918,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
2919,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
2920,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
2921,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
2922,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
2923,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
2924,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
2925,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
2926,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
2927,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
2928,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
2929,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
2930,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
2931,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
2932,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
2933,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
2934,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
2935,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
2936,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
2937,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
2938,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
2939,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
2940,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
2941,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
2942,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
2943,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
2944,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
2945,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
2946,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
2947,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
2948,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
2949,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
2950,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
2951,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
2952,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
2953,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
2954,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
2955,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
2956,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
2957,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
2958,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
2959,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
2960,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
2961,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
2962,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
2963,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
2964,"    private void flush() {
      try {
        this.captureOut.flush();"
2965,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
2966,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
2967,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
2968,"      PrintStream getOriginal() {
        return this.original;
      }"
2969,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
2970,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
2971,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
2972,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
2973,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
2974,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
2975,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
2976,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
2977,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
2978,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
2979,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
2980,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
2981,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
2982,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
2983,"    private void flush() {
      try {
        this.captureOut.flush();"
2984,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
2985,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
2986,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
2987,"      PrintStream getOriginal() {
        return this.original;
      }"
2988,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
2989,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
2990,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
2991,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
2992,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
2993,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
2994,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }

    return factory.getObject();
  }"
2995,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
2996,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
2997,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Stream.of(beanWrapper.getPropertyDescriptors())
          // Need to mybatis-spring 2.0.2+
          .filter(x -> x.getName().equals(""lazyInitialization"")).findAny()
          .ifPresent(x -> builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}""));
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
2998,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
2999,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
3000,"  LocalDateTime now();

}"
3001,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3002,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3003,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3004,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3005,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
3006,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3007,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3008,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3009,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3010,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3011,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3012,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3013,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
  }"
3014,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
3015,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
3016,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
3017,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
3018,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
3019,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
3020,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
3021,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3022,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3023,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
3024,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3025,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3026,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3027,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
3028,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3029,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
3030,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
3031,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3032,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3033,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
3034,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
3035,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
3036,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
3037,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
3038,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
3039,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3040,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3041,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3042,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3043,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3044,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3045,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
3046,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
3047,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
3048,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
3049,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
3050,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3051,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3052,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
3053,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
3054,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
3055,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3056,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
3057,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
3058,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
3059,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
3060,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
3061,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
3062,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3063,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
3064,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
3065,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
3066,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
3067,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
3068,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }

    return factory.getObject();
  }"
3069,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
3070,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
3071,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Stream.of(beanWrapper.getPropertyDescriptors())
          // Need to mybatis-spring 2.0.2+
          .filter(x -> x.getName().equals(""lazyInitialization"")).findAny()
          .ifPresent(x -> builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}""));
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
3072,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
3073,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
3074,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3075,"    Driver velocityLanguageDriver() {
      return new Driver();
    }"
3076,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ObjectProvider<ThymeleafLanguageDriverConfig> configProvider) {
      return new ThymeleafLanguageDriver(configProvider.getIfAvailable(ThymeleafLanguageDriverConfig::newInstance));
    }"
3077,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3078,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3079,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3080,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3081,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
3082,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(Driver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(Driver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3083,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3084,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3085,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3086,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3087,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3088,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3089,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
  }"
3090,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
3091,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
3092,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
3093,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
3094,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
3095,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
3096,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
3097,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3098,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3099,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
3100,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3101,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3102,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3103,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
3104,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3105,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
3106,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
3107,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3108,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3109,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
3110,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
3111,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
3112,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
3113,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
3114,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
3115,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3116,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3117,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3118,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3119,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3120,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3121,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3122,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3123,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3124,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3125,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
3126,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
3127,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
3128,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
3129,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
3130,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3131,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3132,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
3133,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3134,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
3135,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
3136,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3137,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
3138,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
3139,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
3140,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
3141,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
3142,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
3143,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3144,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
3145,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
3146,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
3147,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3148,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3149,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(Driver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
  }"
3150,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3151,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
  }"
3152,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3153,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3154,"    Driver myVelocityLanguageDriver() {
      return new Driver();
    }"
3155,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3156,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3157,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3158,"    Driver velocityLanguageDriver() {
      return new Driver();
    }"
3159,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
3160,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
3161,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3162,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3163,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(Driver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3164,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3165,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3166,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3167,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3168,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3169,"    Driver myVelocityLanguageDriver() {
      return new Driver();
    }"
3170,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3171,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3172,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

}"
3173,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3174,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
3175,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
3176,"    Driver velocityLanguageDriver() {
      return new Driver();
    }"
3177,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
3178,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
3179,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3180,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3181,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(Driver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);"
3182,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3183,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3184,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_22);
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3185,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3186,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.default-encoding="" + StandardCharsets.ISO_8859_1.name(),
            ""mybatis.scripting-language-driver.freemarker.incompatible-improvements-version=2.3.28"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.ISO_8859_1);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_28);
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3187,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3188,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3189,"    Driver myVelocityLanguageDriver() {
      return new Driver();
    }"
3190,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3191,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3192,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3193,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

}"
3194,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3195,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
3196,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
3197,"    Driver velocityLanguageDriver() {
      return new Driver();
    }"
3198,"    Driver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new Driver(config);
    }"
3199,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
3200,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
3201,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
3202,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertThat(properties.size()).isEqualTo(4);

    // assert for mybatis.configuration.default-scripting-language
    {
      Map<String, Object> element = properties.get(0);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
      assertThat(element.get(""type""))
          .isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
      @SuppressWarnings(""unchecked"")
      Map<String, Object> deprecation = (Map<String, Object>) element.get(""deprecation"");
      assertThat(deprecation.get(""reason"")).isEqualTo(
          ""Because when this configuration property is used, there is case that custom language driver cannot be registered correctly."");
      assertThat(deprecation.get(""replacement"")).isEqualTo(""mybatis.default-scripting-language-driver"");
    }

    // assert for mybatis.configuration.default-enum-type-handler
    {
      Map<String, Object> element = properties.get(1);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.type.EnumTypeHandler"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-enum-type-handler"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.type.TypeHandler>"");
    }

    // assert for mybatis.lazy-initialization
    {
      Map<String, Object> element = properties.get(2);
      assertThat(element.get(""defaultValue"")).isEqualTo(false);
      assertThat(element.get(""name"")).isEqualTo(""mybatis.lazy-initialization"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Boolean"");
    }

    // assert for mybatis.scripting-language-driver.velocity.userdirective
    {
      Map<String, Object> element = properties.get(3);"
3203,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3204,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3205,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(Driver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getIncompatibleImprovementsVersion())
          .isEqualTo(freemarker.template.Configuration.VERSION_2_3_22);
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3206,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3207,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3208,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_22);
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3209,"  void testCustomVelocityConfig() {
    this.context.register(VelocityMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Driver driver = this.context.getBean(Driver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    assertThat(config.getUserdirective()).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3210,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3211,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.default-encoding="" + StandardCharsets.ISO_8859_1.name(),
            ""mybatis.scripting-language-driver.freemarker.incompatible-improvements-version=2.3.28"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.ISO_8859_1);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_28);
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3212,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Driver driver = this.context.getBean(Driver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    assertThat(config.getUserdirective()).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3213,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3214,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3215,"    Driver myVelocityLanguageDriver() {
      return new Driver();
    }"
3216,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3217,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3218,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3219,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3220,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3221,"    public String getName() {
      return ""now"";
    }"
3222,"    public int getType() {
      return LINE;
    }"
3223,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3224,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3225,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
3226,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
3227,"    org.mybatis.scripting.velocity.Driver velocityLanguageDriver() {
      return new org.mybatis.scripting.velocity.Driver();
    }"
3228,"    VelocityLanguageDriver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new VelocityLanguageDriver(config);
    }"
3229,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
3230,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
3231,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
3232,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3233,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3234,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3235,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3236,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
3237,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3238,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3239,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3240,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3241,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3242,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3243,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3244,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
  }"
3245,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
3246,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
3247,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
3248,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
3249,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
3250,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
3251,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
3252,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3253,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3254,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
3255,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3256,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3257,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3258,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
3259,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3260,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
3261,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
3262,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3263,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3264,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
3265,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
3266,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
3267,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
3268,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
3269,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
3270,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3271,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3272,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3273,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3274,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3275,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3276,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3277,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3278,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3279,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3280,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
3281,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
3282,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
3283,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
3284,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
3285,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3286,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3287,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
3288,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3289,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
3290,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
3291,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3292,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
3293,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
3294,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
3295,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
3296,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
3297,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
3298,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3299,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
3300,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
3301,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
3302,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3303,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3304,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getIncompatibleImprovementsVersion())
          .isEqualTo(freemarker.template.Configuration.VERSION_2_3_22);
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3305,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3306,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3307,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_22);
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3308,"  void testCustomVelocityConfig() {
    this.context.register(VelocityMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3309,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3310,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.default-encoding="" + StandardCharsets.ISO_8859_1.name(),
            ""mybatis.scripting-language-driver.freemarker.incompatible-improvements-version=2.3.28"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getDefaultEncoding()).isEqualTo(StandardCharsets.ISO_8859_1);
    assertThat(config.getIncompatibleImprovementsVersion()).isEqualTo(freemarker.template.Configuration.VERSION_2_3_28);
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3311,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3312,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3313,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3314,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3315,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3316,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3317,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3318,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3319,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3320,"    public String getName() {
      return ""now"";
    }"
3321,"    public int getType() {
      return LINE;
    }"
3322,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3323,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
3324,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
3325,"  public Long getId() {
    return this.id;
  }"
3326,"  public void setId(Long id) {
    this.id = id;
  }"
3327,"  public String getName() {
    return this.name;
  }"
3328,"  public void setName(String name) {
    this.name = name;
  }"
3329,"  public String getState() {
    return this.state;
  }"
3330,"  public void setState(String state) {
    this.state = state;
  }"
3331,"  public String getCountry() {
    return this.country;
  }"
3332,"  public void setCountry(String country) {
    this.country = country;
  }"
3333,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3334,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3335,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3336,"  City findByName(@Param(""name"") String name);

}"
3337,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3338,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3339,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3340,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3341,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3342,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3343,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3344,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3345,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3346,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3347,"    private void flush() {
      try {
        this.captureOut.flush();"
3348,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3349,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3350,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3351,"      PrintStream getOriginal() {
        return this.original;
      }"
3352,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3353,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3354,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3355,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3356,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3357,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3358,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3359,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3360,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
3361,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
3362,"  public Long getId() {
    return this.id;
  }"
3363,"  public void setId(Long id) {
    this.id = id;
  }"
3364,"  public String getName() {
    return this.name;
  }"
3365,"  public void setName(String name) {
    this.name = name;
  }"
3366,"  public String getState() {
    return this.state;
  }"
3367,"  public void setState(String state) {
    this.state = state;
  }"
3368,"  public String getCountry() {
    return this.country;
  }"
3369,"  public void setCountry(String country) {
    this.country = country;
  }"
3370,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3371,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3372,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3373,"  City findByName(@Param(""name"") String name);

}"
3374,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3375,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3376,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3377,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3378,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3379,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3380,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3381,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3382,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3383,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3384,"    private void flush() {
      try {
        this.captureOut.flush();"
3385,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3386,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3387,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3388,"      PrintStream getOriginal() {
        return this.original;
      }"
3389,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3390,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3391,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3392,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3393,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3394,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3395,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3396,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3397,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
3398,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
3399,"  public Long getId() {
    return this.id;
  }"
3400,"  public void setId(Long id) {
    this.id = id;
  }"
3401,"  public String getName() {
    return this.name;
  }"
3402,"  public void setName(String name) {
    this.name = name;
  }"
3403,"  public String getState() {
    return this.state;
  }"
3404,"  public void setState(String state) {
    this.state = state;
  }"
3405,"  public String getCountry() {
    return this.country;
  }"
3406,"  public void setCountry(String country) {
    this.country = country;
  }"
3407,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3408,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3409,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3410,"  City findByName(@Param(""name"") String name);

}"
3411,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3412,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3413,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3414,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3415,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3416,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3417,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3418,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3419,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3420,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3421,"    private void flush() {
      try {
        this.captureOut.flush();"
3422,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3423,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3424,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3425,"      PrintStream getOriginal() {
        return this.original;
      }"
3426,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3427,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3428,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3429,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3430,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3431,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3432,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3433,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3434,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
3435,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
3436,"  public Long getId() {
    return this.id;
  }"
3437,"  public void setId(Long id) {
    this.id = id;
  }"
3438,"  public String getName() {
    return this.name;
  }"
3439,"  public void setName(String name) {
    this.name = name;
  }"
3440,"  public String getState() {
    return this.state;
  }"
3441,"  public void setState(String state) {
    this.state = state;
  }"
3442,"  public String getCountry() {
    return this.country;
  }"
3443,"  public void setCountry(String country) {
    this.country = country;
  }"
3444,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3445,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3446,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3447,"  City findByName(@Param(""name"") String name);

}"
3448,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3449,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3450,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3451,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3452,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3453,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3454,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3455,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3456,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3457,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3458,"    private void flush() {
      try {
        this.captureOut.flush();"
3459,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3460,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3461,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3462,"      PrintStream getOriginal() {
        return this.original;
      }"
3463,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3464,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3465,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3466,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3467,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3468,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3469,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3470,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3471,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
3472,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
3473,"  public Long getId() {
    return this.id;
  }"
3474,"  public void setId(Long id) {
    this.id = id;
  }"
3475,"  public String getName() {
    return this.name;
  }"
3476,"  public void setName(String name) {
    this.name = name;
  }"
3477,"  public String getState() {
    return this.state;
  }"
3478,"  public void setState(String state) {
    this.state = state;
  }"
3479,"  public String getCountry() {
    return this.country;
  }"
3480,"  public void setCountry(String country) {
    this.country = country;
  }"
3481,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3482,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3483,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3484,"  City findByName(@Param(""name"") String name);

}"
3485,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3486,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3487,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3488,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3489,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3490,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3491,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3492,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3493,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3494,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3495,"    private void flush() {
      try {
        this.captureOut.flush();"
3496,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3497,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3498,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3499,"      PrintStream getOriginal() {
        return this.original;
      }"
3500,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3501,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3502,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3503,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3504,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3505,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3506,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3507,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3508,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3509,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3510,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
3511,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3512,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getCity()).isEqualTo(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
3513,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3514,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3515,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3516,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3517,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3518,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3519,"  void testCustomVelocityConfig() {
    this.context.register(VelocityMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3520,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3521,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3522,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3523,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3524,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3525,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3526,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3527,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3528,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3529,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3530,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3531,"    public String getName() {
      return ""now"";
    }"
3532,"    public int getType() {
      return LINE;
    }"
3533,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3534,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3535,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3536,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3537,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3538,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3539,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3540,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3541,"  void testCustomVelocityConfig() {
    this.context.register(VelocityMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3542,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3543,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3544,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3545,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3546,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3547,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3548,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3549,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3550,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3551,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3552,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3553,"    public String getName() {
      return ""now"";
    }"
3554,"    public int getType() {
      return LINE;
    }"
3555,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3556,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3557,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3558,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3559,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3560,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3561,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3562,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3563,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3564,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3565,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3566,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3567,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3568,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3569,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3570,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3571,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3572,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3573,"    private void flush() {
      try {
        this.captureOut.flush();"
3574,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3575,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3576,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3577,"      PrintStream getOriginal() {
        return this.original;
      }"
3578,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3579,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3580,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3581,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3582,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3583,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3584,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3585,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3586,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3587,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3588,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3589,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3590,"  void testCustomVelocityConfig() {
    this.context.register(VelocityMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3591,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3592,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3593,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3594,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3595,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3596,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3597,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3598,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3599,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3600,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3601,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3602,"    public String getName() {
      return ""now"";
    }"
3603,"    public int getType() {
      return LINE;
    }"
3604,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3605,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3606,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3607,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3608,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3609,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3610,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3611,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3612,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3613,"  void testCustomVelocityConfig() {
    this.context.register(VelocityCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3614,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3615,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3616,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3617,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3618,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3619,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3620,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3621,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3622,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3623,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3624,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3625,"    public String getName() {
      return ""now"";
    }"
3626,"    public int getType() {
      return LINE;
    }"
3627,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3628,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3629,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3630,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3631,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3632,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3633,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3634,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3635,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3636,"  void testCustomVelocityConfig() {
    this.context.register(VelocityCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3637,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3638,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3639,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3640,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3641,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3642,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3643,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3644,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3645,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3646,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3647,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3648,"    public String getName() {
      return ""now"";
    }"
3649,"    public int getType() {
      return LINE;
    }"
3650,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3651,"  protected String[] getProperties(Class<?> testClass) {
    MybatisTest annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, MybatisTest.class);
    return (annotation != null) ? annotation.properties() : null;
  }"
3652,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
3653,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
3654,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
3655,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
3656,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output directory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);"
3657,"    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv(""MVNW_USERNAME"") != null && System.getenv(""MVNW_PASSWORD"") != null) {
            String username = System.getenv(""MVNW_USERNAME"");
            char[] password = System.getenv(""MVNW_PASSWORD"").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }"
3658,"                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }"
3659,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output directory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);"
3660,"    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv(""MVNW_USERNAME"") != null && System.getenv(""MVNW_PASSWORD"") != null) {
            String username = System.getenv(""MVNW_USERNAME"");
            char[] password = System.getenv(""MVNW_PASSWORD"").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }"
3661,"                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }"
3662,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3663,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3664,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3665,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3666,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
3667,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3668,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3669,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3670,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3671,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3672,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3673,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3674,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
3675,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
3676,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
3677,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
3678,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
3679,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
3680,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
3681,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
3682,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3683,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
3684,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
3685,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3686,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3687,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3688,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
3689,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3690,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
3691,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
3692,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3693,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3694,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
3695,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
3696,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
3697,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
3698,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
3699,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
3700,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3701,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3702,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3703,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3704,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3705,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3706,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3707,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3708,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3709,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3710,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
3711,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
3712,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
3713,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
3714,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
3715,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3716,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3717,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
3718,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3719,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
3720,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
3721,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3722,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
3723,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
3724,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
3725,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
3726,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
3727,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
3728,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3729,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
3730,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
3731,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
3732,"  public void setParameter(PreparedStatement ps, int i, Number parameter, JdbcType jdbcType) throws SQLException {
  }

  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

  @Override
  public String toString() {
    return ""type="" + type;
  }

}"
3733,"  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
3734,"  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
3735,"  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
3736,"  public String toString() {
    return ""type="" + type;
  }"
3737,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
3738,"  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebApplication.class);
  }"
3739,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
3740,"  public Long getId() {
    return this.id;
  }"
3741,"  public void setId(Long id) {
    this.id = id;
  }"
3742,"  public String getName() {
    return this.name;
  }"
3743,"  public void setName(String name) {
    this.name = name;
  }"
3744,"  public String getState() {
    return this.state;
  }"
3745,"  public void setState(String state) {
    this.state = state;
  }"
3746,"  public String getCountry() {
    return this.country;
  }"
3747,"  public void setCountry(String country) {
    this.country = country;
  }"
3748,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3749,"  City findByState(@Param(""state"") String state);

}"
3750,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate.getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
3751,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
3752,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3753,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
3754,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
3755,"  public Long getId() {
    return this.id;
  }"
3756,"  public void setId(Long id) {
    this.id = id;
  }"
3757,"  public String getName() {
    return this.name;
  }"
3758,"  public void setName(String name) {
    this.name = name;
  }"
3759,"  public String getState() {
    return this.state;
  }"
3760,"  public void setState(String state) {
    this.state = state;
  }"
3761,"  public String getCountry() {
    return this.country;
  }"
3762,"  public void setCountry(String country) {
    this.country = country;
  }"
3763,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
3764,"  City findByState(@Param(""state"") String state);

}"
3765,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
3766,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3767,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
3768,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3769,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3770,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3771,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3772,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3773,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3774,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3775,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3776,"  void testCustomVelocityConfig() {
    this.context.register(VelocityCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3777,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.prefix=sql/"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-package-path=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.separate-directory-per-mapper=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-mapper-name-when-separate-directory=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getTemplateFile().getPathProvider().getPrefix()).isEqualTo(""sql/"");
    assertThat(config.getTemplateFile().getPathProvider().isIncludesPackagePath()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isSeparateDirectoryPerMapper()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isIncludesMapperNameWhenSeparateDirectory()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isCacheEnabled()).isFalse();
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3778,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3779,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3780,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3781,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3782,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3783,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3784,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3785,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3786,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3787,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3788,"    public String getName() {
      return ""now"";
    }"
3789,"    public int getType() {
      return LINE;
    }"
3790,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3791,"    public static void main(String args[]) {
        System.out.println(""- Downloader started"");
        File baseDirectory = new File(args[0]);
        System.out.println(""- Using base directory: "" + baseDirectory.getAbsolutePath());

        // If the maven-wrapper.properties exists, read it and check if it contains a custom
        // wrapperUrl parameter.
        File mavenWrapperPropertyFile = new File(baseDirectory, MAVEN_WRAPPER_PROPERTIES_PATH);
        String url = DEFAULT_DOWNLOAD_URL;
        if(mavenWrapperPropertyFile.exists()) {
            FileInputStream mavenWrapperPropertyFileInputStream = null;
            try {
                mavenWrapperPropertyFileInputStream = new FileInputStream(mavenWrapperPropertyFile);
                Properties mavenWrapperProperties = new Properties();
                mavenWrapperProperties.load(mavenWrapperPropertyFileInputStream);
                url = mavenWrapperProperties.getProperty(PROPERTY_NAME_WRAPPER_URL, url);
            } catch (IOException e) {
                System.out.println(""- ERROR loading '"" + MAVEN_WRAPPER_PROPERTIES_PATH + ""'"");
            } finally {
                try {
                    if(mavenWrapperPropertyFileInputStream != null) {
                        mavenWrapperPropertyFileInputStream.close();
                    }
                } catch (IOException e) {
                    // Ignore ...
                }
            }
        }
        System.out.println(""- Downloading from: "" + url);

        File outputFile = new File(baseDirectory.getAbsolutePath(), MAVEN_WRAPPER_JAR_PATH);
        if(!outputFile.getParentFile().exists()) {
            if(!outputFile.getParentFile().mkdirs()) {
                System.out.println(
                        ""- ERROR creating output directory '"" + outputFile.getParentFile().getAbsolutePath() + ""'"");
            }
        }
        System.out.println(""- Downloading to: "" + outputFile.getAbsolutePath());
        try {
            downloadFileFromURL(url, outputFile);"
3792,"    private static void downloadFileFromURL(String urlString, File destination) throws Exception {
        if (System.getenv(""MVNW_USERNAME"") != null && System.getenv(""MVNW_PASSWORD"") != null) {
            String username = System.getenv(""MVNW_USERNAME"");
            char[] password = System.getenv(""MVNW_PASSWORD"").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        URL website = new URL(urlString);
        ReadableByteChannel rbc;
        rbc = Channels.newChannel(website.openStream());
        FileOutputStream fos = new FileOutputStream(destination);
        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);
        fos.close();
        rbc.close();
    }"
3793,"                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }"
3794,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
3795,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
3796,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3797,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3798,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3799,"  City findByCountry(@Param(""country"") String country);

}"
3800,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
3801,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
3802,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3803,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3804,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3805,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
3806,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
3807,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
3808,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3809,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3810,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3811,"  City findByCountry(@Param(""country"") String country);

}"
3812,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
3813,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
3814,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3815,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3816,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3817,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
3818,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3819,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
3820,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
3821,"    org.mybatis.scripting.velocity.Driver velocityLanguageDriver() {
      return new org.mybatis.scripting.velocity.Driver();
    }"
3822,"    VelocityLanguageDriver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new VelocityLanguageDriver(config);
    }"
3823,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
3824,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
3825,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
3826,"      public DialectConfig getDialect() {
        return super.getDialect();
      }"
3827,"      public TemplateFileConfig getTemplateFile() {
        return super.getTemplateFile();
      }"
3828,"  void customize(Configuration configuration);

}"
3829,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
3830,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
3831,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }

    return factory.getObject();
  }"
3832,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
3833,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
3834,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Stream.of(beanWrapper.getPropertyDescriptors())
          // Need to mybatis-spring 2.0.2+
          .filter(x -> x.getName().equals(""lazyInitialization"")).findAny()
          .ifPresent(x -> builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}""));
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
3835,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
3836,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
3837,"  public boolean isValid() {
    return true;
  }"
3838,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = url.toString();
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
3839,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
3840,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
3841,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
3842,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3843,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
3844,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
3845,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3846,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3847,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
3848,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3849,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3850,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
3851,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3852,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
3853,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
3854,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
3855,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
3856,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
3857,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
3858,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
3859,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
3860,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3861,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
3862,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
3863,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
3864,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
3865,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
3866,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
3867,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
3868,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
3869,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
3870,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3871,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
3872,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
3873,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
3874,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
3875,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
3876,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
3877,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
3878,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3879,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
3880,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3881,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3882,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3883,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
3884,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3885,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3886,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
3887,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
3888,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
3889,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
3890,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
3891,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
3892,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
3893,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3894,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
3895,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
3896,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3897,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
3898,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
3899,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3900,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
3901,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
3902,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
3903,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
3904,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
3905,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
3906,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
3907,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
3908,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
3909,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
3910,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
3911,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
3912,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
3913,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
3914,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
3915,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
3916,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
3917,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
3918,"  void testCustomVelocityConfig() {
    this.context.register(VelocityCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
3919,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.prefix=sql/"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-package-path=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.separate-directory-per-mapper=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-mapper-name-when-separate-directory=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getTemplateFile().getPathProvider().getPrefix()).isEqualTo(""sql/"");
    assertThat(config.getTemplateFile().getPathProvider().isIncludesPackagePath()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isSeparateDirectoryPerMapper()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isIncludesMapperNameWhenSeparateDirectory()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isCacheEnabled()).isFalse();
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
3920,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
3921,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
3922,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
3923,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
3924,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
3925,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
3926,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
3927,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
3928,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
3929,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
3930,"    public String getName() {
      return ""now"";
    }"
3931,"    public int getType() {
      return LINE;
    }"
3932,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
3933,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
3934,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
3935,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
3936,"  public City findById(long id) {
    return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
  }"
3937,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
3938,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
3939,"  City findByState(@Param(""state"") String state);

}"
3940,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3941,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3942,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3943,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3944,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3945,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3946,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3947,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3948,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3949,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3950,"    private void flush() {
      try {
        this.captureOut.flush();"
3951,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3952,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3953,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3954,"      PrintStream getOriginal() {
        return this.original;
      }"
3955,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3956,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3957,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3958,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3959,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3960,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3961,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3962,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
3963,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
3964,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3965,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
3966,"  City findByName(@Param(""name"") String name);

}"
3967,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3968,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3969,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
3970,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
3971,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
3972,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
3973,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
3974,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
3975,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
3976,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
3977,"    private void flush() {
      try {
        this.captureOut.flush();"
3978,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
3979,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
3980,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
3981,"      PrintStream getOriginal() {
        return this.original;
      }"
3982,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
3983,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
3984,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
3985,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
3986,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3987,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
3988,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3989,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3990,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
3991,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
3992,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
3993,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3994,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3995,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
3996,"  City findByCountry(@Param(""country"") String country);

}"
3997,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
3998,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
3999,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4000,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4001,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4002,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4003,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4004,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4005,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4006,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4007,"    private void flush() {
      try {
        this.captureOut.flush();"
4008,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4009,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4010,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4011,"      PrintStream getOriginal() {
        return this.original;
      }"
4012,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4013,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4014,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4015,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4016,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4017,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4018,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4019,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4020,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4021,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4022,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4023,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4024,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4025,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4026,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4027,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4028,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4029,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4030,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4031,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4032,"    private void flush() {
      try {
        this.captureOut.flush();"
4033,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4034,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4035,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4036,"      PrintStream getOriginal() {
        return this.original;
      }"
4037,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4038,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4039,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4040,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4041,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
4042,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
4043,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4044,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4045,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4046,"  City findByCountry(@Param(""country"") String country);

}"
4047,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4048,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4049,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4050,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4051,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4052,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4053,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4054,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4055,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4056,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4057,"    private void flush() {
      try {
        this.captureOut.flush();"
4058,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4059,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4060,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4061,"      PrintStream getOriginal() {
        return this.original;
      }"
4062,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4063,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4064,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4065,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4066,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4067,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4068,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4069,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4070,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4071,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4072,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
4073,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
4074,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4075,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4076,"  City findByName(@Param(""name"") String name);

}"
4077,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4078,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4079,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4080,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4081,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4082,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4083,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4084,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4085,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4086,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4087,"    private void flush() {
      try {
        this.captureOut.flush();"
4088,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4089,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4090,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4091,"      PrintStream getOriginal() {
        return this.original;
      }"
4092,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4093,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4094,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4095,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4096,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4097,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4098,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4099,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4100,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4101,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
4102,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
4103,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4104,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4105,"  City findByName(@Param(""name"") String name);

}"
4106,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4107,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4108,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4109,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4110,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4111,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4112,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4113,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4114,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4115,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4116,"    private void flush() {
      try {
        this.captureOut.flush();"
4117,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4118,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4119,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4120,"      PrintStream getOriginal() {
        return this.original;
      }"
4121,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4122,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4123,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4124,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4125,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4126,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4127,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4128,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4129,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4130,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
4131,"  City findByState(@Param(""state"") String state);

}"
4132,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4133,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4134,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4135,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
4136,"  City findByState(@Param(""state"") String state);

}"
4137,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4138,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4139,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
4140,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
4141,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
4142,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4143,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4144,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4145,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4146,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4147,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4148,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4149,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4150,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4151,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4152,"    private void flush() {
      try {
        this.captureOut.flush();"
4153,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4154,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4155,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4156,"      PrintStream getOriginal() {
        return this.original;
      }"
4157,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4158,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4159,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4160,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4161,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4162,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
4163,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4164,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getCity()).isEqualTo(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
4165,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
4166,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
4167,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
4168,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
4169,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }

    return factory.getObject();
  }"
4170,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
4171,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
4172,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
4173,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
4174,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
4175,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertThat(properties.size()).isEqualTo(5);

    // assert for mybatis.configuration.default-scripting-language
    {
      Map<String, Object> element = properties.get(0);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
      assertThat(element.get(""type""))
          .isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
      @SuppressWarnings(""unchecked"")
      Map<String, Object> deprecation = (Map<String, Object>) element.get(""deprecation"");
      assertThat(deprecation.get(""reason"")).isEqualTo(
          ""Because when this configuration property is used, there is case that custom language driver cannot be registered correctly."");
      assertThat(deprecation.get(""replacement"")).isEqualTo(""mybatis.default-scripting-language-driver"");
    }

    // assert for mybatis.configuration.default-enum-type-handler
    {
      Map<String, Object> element = properties.get(1);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.type.EnumTypeHandler"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-enum-type-handler"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.type.TypeHandler>"");
    }

    // assert for mybatis.lazy-initialization
    {
      Map<String, Object> element = properties.get(2);
      assertThat(element.get(""defaultValue"")).isEqualTo(false);
      assertThat(element.get(""name"")).isEqualTo(""mybatis.lazy-initialization"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Boolean"");
    }

    // assert for mybatis.mapper-default-scope
    {
      Map<String, Object> element = properties.get(3);
      assertThat(element.get(""defaultValue"")).isEqualTo("""");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.mapper-default-scope"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.String"");
    }

    // assert for mybatis.scripting-language-driver.velocity.userdirective
    {
      Map<String, Object> element = properties.get(4);"
4176,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
4177,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
4178,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4179,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4180,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
4181,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4182,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4183,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4184,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4185,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4186,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4187,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4188,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4189,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4190,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
4191,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
4192,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
4193,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
4194,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
4195,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
4196,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
4197,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
4198,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4199,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
4200,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
4201,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4202,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4203,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
4204,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
4205,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4206,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
4207,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
4208,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4209,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4210,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
4211,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
4212,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
4213,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
4214,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
4215,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
4216,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4217,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4218,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4219,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
4220,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4221,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4222,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
4223,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
4224,"    DataSource dataSourceMaster() {
      return Mockito.mock(DataSource.class);
    }"
4225,"    DataSource dataSourceSlave() {
      return Mockito.mock(DataSource.class);
    }"
4226,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
4227,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
4228,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
4229,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
4230,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
4231,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
4232,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4233,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4234,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
4235,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
4236,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
4237,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
4238,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4239,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
4240,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
4241,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
4242,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
4243,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
4244,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
4245,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4246,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
4247,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
4248,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
4249,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
4250,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
4251,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4252,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4253,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
4254,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4255,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4256,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4257,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4258,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4259,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4260,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4261,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4262,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4263,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
4264,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
4265,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
4266,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
4267,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
4268,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
4269,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
4270,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
4271,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4272,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
4273,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
4274,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4275,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4276,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
4277,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
4278,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4279,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
4280,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
4281,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4282,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4283,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
4284,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
4285,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
4286,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
4287,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
4288,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
4289,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4290,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4291,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4292,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
4293,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4294,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4295,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
4296,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
4297,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
4298,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
4299,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
4300,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
4301,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
4302,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
4303,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
4304,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
4305,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4306,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4307,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
4308,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
4309,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
4310,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
4311,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4312,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
4313,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
4314,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
4315,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
4316,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
4317,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
4318,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4319,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
4320,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
4321,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
4322,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertAll(
            () -> assertThat(properties.size()).isEqualTo(5),"
4323,"  void customize(Configuration configuration);

}"
4324,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
4325,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
4326,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }

    return factory.getObject();
  }"
4327,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
4328,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
4329,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }
      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
4330,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
4331,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
4332,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
4333,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
4334,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
4335,"    org.mybatis.scripting.velocity.Driver velocityLanguageDriver() {
      return new org.mybatis.scripting.velocity.Driver();
    }"
4336,"    VelocityLanguageDriver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new VelocityLanguageDriver(config);
    }"
4337,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
4338,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
4339,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
4340,"      public DialectConfig getDialect() {
        return super.getDialect();
      }"
4341,"      public TemplateFileConfig getTemplateFile() {
        return super.getTemplateFile();
      }"
4342,"  public boolean isValid() {
    return true;
  }"
4343,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = url.toString();
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
4344,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
4345,"  LocalDateTime now();

}"
4346,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertThat(properties.size()).isEqualTo(5);

    // assert for mybatis.configuration.default-scripting-language
    {
      Map<String, Object> element = properties.get(0);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-scripting-language"");
      assertThat(element.get(""type""))
          .isEqualTo(""java.lang.Class<? extends org.apache.ibatis.scripting.LanguageDriver>"");
      @SuppressWarnings(""unchecked"")
      Map<String, Object> deprecation = (Map<String, Object>) element.get(""deprecation"");
      assertThat(deprecation.get(""reason"")).isEqualTo(
          ""Because when this configuration property is used, there is case that custom language driver cannot be registered correctly."");
      assertThat(deprecation.get(""replacement"")).isEqualTo(""mybatis.default-scripting-language-driver"");
    }

    // assert for mybatis.configuration.default-enum-type-handler
    {
      Map<String, Object> element = properties.get(1);
      assertThat(element.get(""sourceType"")).isEqualTo(""org.apache.ibatis.session.Configuration"");
      assertThat(element.get(""defaultValue"")).isEqualTo(""org.apache.ibatis.type.EnumTypeHandler"");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.configuration.default-enum-type-handler"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Class<? extends org.apache.ibatis.type.TypeHandler>"");
    }

    // assert for mybatis.lazy-initialization
    {
      Map<String, Object> element = properties.get(2);
      assertThat(element.get(""defaultValue"")).isEqualTo(false);
      assertThat(element.get(""name"")).isEqualTo(""mybatis.lazy-initialization"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.Boolean"");
    }

    // assert for mybatis.mapper-default-scope
    {
      Map<String, Object> element = properties.get(3);
      assertThat(element.get(""defaultValue"")).isEqualTo("""");
      assertThat(element.get(""name"")).isEqualTo(""mybatis.mapper-default-scope"");
      assertThat(element.get(""type"")).isEqualTo(""java.lang.String"");
    }

    // assert for mybatis.scripting-language-driver.velocity.userdirective
    {
      Map<String, Object> element = properties.get(4);"
4347,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
4348,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
4349,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4350,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
4351,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
4352,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4353,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4354,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
4355,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4356,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
4357,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4358,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4359,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
4360,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4361,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
4362,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
4363,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
4364,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
4365,"  void testWithInterceptors() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(1);
    this.context.close();
  }"
4366,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
4367,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
4368,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
  }"
4369,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4370,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
4371,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
4372,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(1);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
4373,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
4374,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
4375,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
4376,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
4377,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
4378,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
4379,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4380,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
4381,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
4382,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
4383,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
4384,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
4385,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
4386,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
4387,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4388,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
4389,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4390,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
4391,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4392,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
4393,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
4394,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
4395,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
4396,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
4397,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
4398,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
4399,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
4400,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
4401,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
4402,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
4403,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4404,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
4405,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
4406,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
4407,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
4408,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
4409,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4410,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
4411,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
4412,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
4413,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
4414,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
4415,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
4416,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
4417,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
4418,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
4419,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
4420,"  void init() {
    VelocityFacade.destroy();
    this.context = new AnnotationConfigApplicationContext();
  }"
4421,"  void closeContext() {
    if (this.context != null) {
      this.context.close();
    }
    VelocityFacade.destroy();
  }"
4422,"  void testDefaultConfiguration() {
    this.context.register(MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    {
      ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
      assertThat(config.isUse2way()).isEqualTo(true);
      assertThat(config.getDialect().getPrefix()).isEqualTo(""mb"");
      assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
      assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
      assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
      assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
      assertThat(config.getTemplateFile().getCacheTtl()).isNull();
      assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
      assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
      assertThat(config.getCustomizer()).isNull();
    }
    {
      FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
      assertThat(config.getBasePackage()).isEqualTo("""");
      assertThat(config.getFreemarkerSettings()).isEmpty();
    }
    {
      VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);"
4423,"  void testCustomConfiguration() {
    this.context.register(MyLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""myFreeMarkerLanguageDriver"", ""myVelocityLanguageDriver"",
        ""myThymeleafLanguageDriver"");"
4424,"  void testLegacyConfiguration() {
    this.context.register(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class);
    this.context.refresh();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(2).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"");
    assertThat(this.context.getBean(org.mybatis.scripting.velocity.Driver.class)).isNotNull();
    assertThat(this.context.getBean(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(this.context.getBeanNamesForType(VelocityLanguageDriverConfig.class)).hasSize(0);
    assertThat(this.context.getBeanNamesForType(FreeMarkerLanguageDriverConfig.class)).hasSize(0);
  }"
4425,"  void testCustomThymeleafConfig() {
    this.context.register(ThymeleafCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = /*[# m:p='id']*/ 1 /*[/]*/"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(true);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""m"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).isNull();
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('\\');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""ESCAPE '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo("""");
    assertThat(config.getTemplateFile().getCacheTtl()).isNull();
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(StandardCharsets.UTF_8);
    assertThat(config.getTemplateFile().getPatterns()).hasSize(1).contains(""*.sql"");
    assertThat(config.getCustomizer()).isNull();
  }"
4426,"  void test() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
  }"
4427,"  void testCustomFreeMarkerConfig() {
    this.context.register(FreeMarkerCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo("""");
    assertThat(config.getFreemarkerSettings()).hasSize(1);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
  }"
4428,"  void testCustomVelocityConfig() {
    this.context.register(VelocityCustomLanguageDriverConfig.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(0);
    assertThat(config.getAdditionalContextAttributes()).hasSize(0);
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");"
4429,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    TestPropertyValues.of(""mybatis.scripting-language-driver.thymeleaf.use2way=false"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-additional-escape-target-chars=*,?"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-char=~"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.like-escape-clause-format=escape '%s'"",
        ""mybatis.scripting-language-driver.thymeleaf.dialect.prefix=mybatis"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.base-dir=sqls"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.cache-ttl=1234"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.encoding=Windows-31J"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.patterns=*.sql,*.sqlf"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.prefix=sql/"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-package-path=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.separate-directory-per-mapper=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.includes-mapper-name-when-separate-directory=false"",
        ""mybatis.scripting-language-driver.thymeleaf.template-file.path-provider.cache-enabled=false"",
        ""mybatis.scripting-language-driver.thymeleaf.customizer=org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfigurationTest$MyTemplateEngineCustomizer"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    ThymeleafLanguageDriver driver = this.context.getBean(ThymeleafLanguageDriver.class);
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = [# mybatis:p='id' /]"", Integer.class);
    BoundSql boundSql = sqlSource.getBoundSql(10);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ?"");
    assertThat(boundSql.getParameterObject()).isEqualTo(10);
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    ThymeleafLanguageDriverConfig config = this.context.getBean(ThymeleafLanguageDriverConfig.class);
    assertThat(config.isUse2way()).isEqualTo(false);
    assertThat(config.getDialect().getPrefix()).isEqualTo(""mybatis"");
    assertThat(config.getDialect().getLikeAdditionalEscapeTargetChars()).hasSize(2).contains('*', '?');
    assertThat(config.getDialect().getLikeEscapeChar()).isEqualTo('~');
    assertThat(config.getDialect().getLikeEscapeClauseFormat()).isEqualTo(""escape '%s'"");
    assertThat(config.getTemplateFile().getBaseDir()).isEqualTo(""sqls"");
    assertThat(config.getTemplateFile().getCacheTtl()).isEqualTo(1234);
    assertThat(config.getTemplateFile().getEncoding()).isEqualTo(Charset.forName(""Windows-31J""));
    assertThat(config.getTemplateFile().getPatterns()).hasSize(2).contains(""*.sql"", ""*.sqlf"");
    assertThat(config.getTemplateFile().getPathProvider().getPrefix()).isEqualTo(""sql/"");
    assertThat(config.getTemplateFile().getPathProvider().isIncludesPackagePath()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isSeparateDirectoryPerMapper()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isIncludesMapperNameWhenSeparateDirectory()).isFalse();
    assertThat(config.getTemplateFile().getPathProvider().isCacheEnabled()).isFalse();
    assertThat(config.getCustomizer()).isEqualTo(MyTemplateEngineCustomizer.class);
  }"
4430,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.freemarker.base-package=sqls"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.interpolation_syntax=dollar"",
            ""mybatis.scripting-language-driver.freemarker.freemarker-settings.whitespace_stripping=yes"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    FreeMarkerLanguageDriver driver = this.context.getBean(FreeMarkerLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(),
        ""SELECT * FROM users WHERE id = #{id} and version = <@p name='version'/>"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT * FROM users WHERE id = ? and version = ?"");
    assertThat(boundSql.getParameterMappings().get(0).getProperty()).isEqualTo(""id"");
    assertThat(boundSql.getParameterMappings().get(0).getJavaType()).isEqualTo(Integer.class);
    assertThat(boundSql.getParameterMappings().get(1).getProperty()).isEqualTo(""version"");
    assertThat(boundSql.getParameterMappings().get(1).getJavaType()).isEqualTo(Integer.class);
    FreeMarkerLanguageDriverConfig config = this.context.getBean(FreeMarkerLanguageDriverConfig.class);
    assertThat(config.getBasePackage()).isEqualTo(""sqls"");
    assertThat(config.getFreemarkerSettings()).hasSize(2);
    assertThat(config.getFreemarkerSettings().get(""interpolation_syntax"")).isEqualTo(""dollar"");
    assertThat(config.getFreemarkerSettings().get(""whitespace_stripping"")).isEqualTo(""yes"");
  }"
4431,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    TestPropertyValues
        .of(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),
            ""mybatis.scripting-language-driver.velocity.velocity-settings."" + RuntimeConstants.INPUT_ENCODING + ""=""
                + RuntimeConstants.ENCODING_DEFAULT,
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute1=java.lang.String"",
            ""mybatis.scripting-language-driver.velocity.additional-context-attributes.attribute2=java.util.HashMap"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class, MybatisLanguageDriverAutoConfiguration.class);
    this.context.refresh();
    VelocityLanguageDriver driver = this.context.getBean(VelocityLanguageDriver.class);
    @SuppressWarnings(""unused"")
    class Param {
      private Integer id;
      private Integer version;
    }
    Param params = new Param();
    params.id = 10;
    params.version = 20;
    SqlSource sqlSource = driver.createSqlSource(new Configuration(), ""#now()"", Param.class);
    BoundSql boundSql = sqlSource.getBoundSql(params);
    assertThat(boundSql.getSql()).isEqualTo(""SELECT CURRENT_TIMESTAMP"");
    VelocityLanguageDriverConfig config = this.context.getBean(VelocityLanguageDriverConfig.class);
    @SuppressWarnings(""deprecation"")
    String[] userDirective = config.getUserdirective();
    assertThat(userDirective).hasSize(1).contains(NowDirective.class.getName());
    assertThat(config.getAdditionalContextAttributes()).hasSize(2);
    assertThat(config.getAdditionalContextAttributes().get(""attribute1"")).isEqualTo(""java.lang.String"");
    assertThat(config.getAdditionalContextAttributes().get(""attribute2"")).isEqualTo(""java.util.HashMap"");
    assertThat(config.getVelocitySettings()).hasSize(3);
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADERS)).isEqualTo(""class"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.RESOURCE_LOADER + "".class.class""))
        .isEqualTo(""org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"");
    assertThat(config.generateCustomDirectivesString()).isEqualTo(NowDirective.class.getName()
        + "",org.mybatis.scripting.velocity.TrimDirective,org.mybatis.scripting.velocity.WhereDirective,org.mybatis.scripting.velocity.SetDirective,org.mybatis.scripting.velocity.InDirective,org.mybatis.scripting.velocity.RepeatDirective"");
    assertThat(config.getVelocitySettings().get(RuntimeConstants.INPUT_ENCODING))
        .isEqualTo(RuntimeConstants.ENCODING_DEFAULT);"
4432,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(MyAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
4433,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
4434,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
4435,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
4436,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
4437,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
4438,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
4439,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
4440,"    public String getName() {
      return ""now"";
    }"
4441,"    public int getType() {
      return LINE;
    }"
4442,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
4443,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
4444,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
4445,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
4446,"  public Long getId() {
    return this.id;
  }"
4447,"  public void setId(Long id) {
    this.id = id;
  }"
4448,"  public String getName() {
    return this.name;
  }"
4449,"  public void setName(String name) {
    this.name = name;
  }"
4450,"  public Long getFirst() {
    return first;
  }"
4451,"  public void setFirst(Long first) {
    this.first = first;
  }"
4452,"  public String getLast() {
    return last;
  }"
4453,"  public void setLast(String last) {
    this.last = last;
  }"
4454,"  public void setParameter(PreparedStatement ps, int i, Number parameter, JdbcType jdbcType) throws SQLException {
  }

  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

  @Override
  public String toString() {
    return ""type="" + type;
  }

}"
4455,"  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
4456,"  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
4457,"  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
4458,"  public String toString() {
    return ""type="" + type;
  }"
4459,"  public void setParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException {
  }

  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

}"
4460,"  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
4461,"  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
4462,"  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
4463,"  City findById(@Param(""cityId"") Long cityId);

}"
4464,"  public City findById(long id) {
    return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
  }"
4465,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
4466,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
4467,"  public Long getId() {
    return this.id;
  }"
4468,"  public void setId(Long id) {
    this.id = id;
  }"
4469,"  public String getName() {
    return this.name;
  }"
4470,"  public void setName(String name) {
    this.name = name;
  }"
4471,"  public String getState() {
    return this.state;
  }"
4472,"  public void setState(String state) {
    this.state = state;
  }"
4473,"  public String getCountry() {
    return this.country;
  }"
4474,"  public void setCountry(String country) {
    this.country = country;
  }"
4475,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4476,"  City findByState(@Param(""state"") String state);

}"
4477,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4478,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4479,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4480,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4481,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4482,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4483,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4484,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4485,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4486,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4487,"    private void flush() {
      try {
        this.captureOut.flush();"
4488,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4489,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4490,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4491,"      PrintStream getOriginal() {
        return this.original;
      }"
4492,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4493,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4494,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4495,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4496,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4497,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4498,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4499,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
4500,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
4501,"  public Long getId() {
    return this.id;
  }"
4502,"  public void setId(Long id) {
    this.id = id;
  }"
4503,"  public String getName() {
    return this.name;
  }"
4504,"  public void setName(String name) {
    this.name = name;
  }"
4505,"  public String getState() {
    return this.state;
  }"
4506,"  public void setState(String state) {
    this.state = state;
  }"
4507,"  public String getCountry() {
    return this.country;
  }"
4508,"  public void setCountry(String country) {
    this.country = country;
  }"
4509,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4510,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4511,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4512,"  City findByName(@Param(""name"") String name);

}"
4513,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4514,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4515,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4516,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4517,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4518,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4519,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4520,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4521,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4522,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4523,"    private void flush() {
      try {
        this.captureOut.flush();"
4524,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4525,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4526,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4527,"      PrintStream getOriginal() {
        return this.original;
      }"
4528,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4529,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4530,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4531,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4532,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4533,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4534,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4535,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4536,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4537,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
4538,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
4539,"  public Long getId() {
    return this.id;
  }"
4540,"  public void setId(Long id) {
    this.id = id;
  }"
4541,"  public String getName() {
    return this.name;
  }"
4542,"  public void setName(String name) {
    this.name = name;
  }"
4543,"  public String getState() {
    return this.state;
  }"
4544,"  public void setState(String state) {
    this.state = state;
  }"
4545,"  public String getCountry() {
    return this.country;
  }"
4546,"  public void setCountry(String country) {
    this.country = country;
  }"
4547,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4548,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4549,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4550,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4551,"  City findByCountry(@Param(""country"") String country);

}"
4552,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4553,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4554,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4555,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4556,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4557,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4558,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4559,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4560,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4561,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4562,"    private void flush() {
      try {
        this.captureOut.flush();"
4563,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4564,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4565,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4566,"      PrintStream getOriginal() {
        return this.original;
      }"
4567,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4568,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4569,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4570,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4571,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4572,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4573,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4574,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4575,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4576,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4577,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4578,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4579,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4580,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4581,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4582,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4583,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4584,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4585,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4586,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4587,"    private void flush() {
      try {
        this.captureOut.flush();"
4588,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4589,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4590,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4591,"      PrintStream getOriginal() {
        return this.original;
      }"
4592,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4593,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4594,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4595,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4596,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
4597,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
4598,"  public Long getId() {
    return this.id;
  }"
4599,"  public void setId(Long id) {
    this.id = id;
  }"
4600,"  public String getName() {
    return this.name;
  }"
4601,"  public void setName(String name) {
    this.name = name;
  }"
4602,"  public String getState() {
    return this.state;
  }"
4603,"  public void setState(String state) {
    this.state = state;
  }"
4604,"  public String getCountry() {
    return this.country;
  }"
4605,"  public void setCountry(String country) {
    this.country = country;
  }"
4606,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4607,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4608,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4609,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4610,"  City findByCountry(@Param(""country"") String country);

}"
4611,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4612,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4613,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4614,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4615,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4616,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4617,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4618,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4619,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4620,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4621,"    private void flush() {
      try {
        this.captureOut.flush();"
4622,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4623,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4624,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4625,"      PrintStream getOriginal() {
        return this.original;
      }"
4626,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4627,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4628,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4629,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4630,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4631,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4632,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4633,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4634,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4635,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4636,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
4637,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
4638,"  public Long getId() {
    return this.id;
  }"
4639,"  public void setId(Long id) {
    this.id = id;
  }"
4640,"  public String getName() {
    return this.name;
  }"
4641,"  public void setName(String name) {
    this.name = name;
  }"
4642,"  public String getState() {
    return this.state;
  }"
4643,"  public void setState(String state) {
    this.state = state;
  }"
4644,"  public String getCountry() {
    return this.country;
  }"
4645,"  public void setCountry(String country) {
    this.country = country;
  }"
4646,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4647,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4648,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4649,"  City findByName(@Param(""name"") String name);

}"
4650,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4651,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4652,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4653,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4654,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4655,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4656,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4657,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4658,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4659,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4660,"    private void flush() {
      try {
        this.captureOut.flush();"
4661,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4662,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4663,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4664,"      PrintStream getOriginal() {
        return this.original;
      }"
4665,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4666,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4667,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4668,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4669,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4670,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4671,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4672,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4673,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4674,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
4675,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
4676,"  public Long getId() {
    return this.id;
  }"
4677,"  public void setId(Long id) {
    this.id = id;
  }"
4678,"  public String getName() {
    return this.name;
  }"
4679,"  public void setName(String name) {
    this.name = name;
  }"
4680,"  public String getState() {
    return this.state;
  }"
4681,"  public void setState(String state) {
    this.state = state;
  }"
4682,"  public String getCountry() {
    return this.country;
  }"
4683,"  public void setCountry(String country) {
    this.country = country;
  }"
4684,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4685,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4686,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4687,"  City findByName(@Param(""name"") String name);

}"
4688,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4689,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4690,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4691,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4692,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4693,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4694,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4695,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4696,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4697,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4698,"    private void flush() {
      try {
        this.captureOut.flush();"
4699,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4700,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4701,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4702,"      PrintStream getOriginal() {
        return this.original;
      }"
4703,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4704,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4705,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4706,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4707,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4708,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4709,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4710,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4711,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4712,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
4713,"  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebApplication.class);
  }"
4714,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
4715,"  public Long getId() {
    return this.id;
  }"
4716,"  public void setId(Long id) {
    this.id = id;
  }"
4717,"  public String getName() {
    return this.name;
  }"
4718,"  public void setName(String name) {
    this.name = name;
  }"
4719,"  public String getState() {
    return this.state;
  }"
4720,"  public void setState(String state) {
    this.state = state;
  }"
4721,"  public String getCountry() {
    return this.country;
  }"
4722,"  public void setCountry(String country) {
    this.country = country;
  }"
4723,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4724,"  City findByState(@Param(""state"") String state);

}"
4725,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4726,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4727,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4728,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
4729,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
4730,"  public Long getId() {
    return this.id;
  }"
4731,"  public void setId(Long id) {
    this.id = id;
  }"
4732,"  public String getName() {
    return this.name;
  }"
4733,"  public void setName(String name) {
    this.name = name;
  }"
4734,"  public String getState() {
    return this.state;
  }"
4735,"  public void setState(String state) {
    this.state = state;
  }"
4736,"  public String getCountry() {
    return this.country;
  }"
4737,"  public void setCountry(String country) {
    this.country = country;
  }"
4738,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4739,"  City findByState(@Param(""state"") String state);

}"
4740,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
4741,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4742,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
4743,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
4744,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
4745,"  public Long getId() {
    return this.id;
  }"
4746,"  public void setId(Long id) {
    this.id = id;
  }"
4747,"  public String getName() {
    return this.name;
  }"
4748,"  public void setName(String name) {
    this.name = name;
  }"
4749,"  public String getState() {
    return this.state;
  }"
4750,"  public void setState(String state) {
    this.state = state;
  }"
4751,"  public String getCountry() {
    return this.country;
  }"
4752,"  public void setCountry(String country) {
    this.country = country;
  }"
4753,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4754,"  public Long getCity() {
    return city;
  }"
4755,"  public void setCity(Long city) {
    this.city = city;
  }"
4756,"  public String getName() {
    return name;
  }"
4757,"  public void setName(String name) {
    this.name = name;
  }"
4758,"  public String getAddress() {
    return address;
  }"
4759,"  public void setAddress(String address) {
    this.address = address;
  }"
4760,"  public String getZip() {
    return zip;
  }"
4761,"  public void setZip(String zip) {
    this.zip = zip;
  }"
4762,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
4763,"  Hotel selectByCityId(int cityId);

}"
4764,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4765,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4766,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4767,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4768,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4769,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4770,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4771,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4772,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4773,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4774,"    private void flush() {
      try {
        this.captureOut.flush();"
4775,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4776,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4777,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4778,"      PrintStream getOriginal() {
        return this.original;
      }"
4779,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4780,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4781,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4782,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4783,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4784,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
4785,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4786,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getCity()).isEqualTo(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
4787,"  protected String[] getProperties(Class<?> testClass) {
    MybatisTest annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, MybatisTest.class);
    return (annotation != null) ? annotation.properties() : null;
  }"
4788,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
4789,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:"
4790,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
4791,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
4792,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
4793,"  public String getMessage() {
    return ""Hello!"";
  }"
4794,"  public String getMessage() {
    return ""Goodbye!"";
  }"
4795,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
4796,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
4797,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
4798,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
4799,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
4800,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
4801,"  public Long getId() {
    return id;
  }"
4802,"  public void setId(Long id) {
    this.id = id;
  }"
4803,"  public String getName() {
    return name;
  }"
4804,"  public void setName(String name) {
    this.name = name;
  }"
4805,"  Sample findByName(String name);

}"
4806,"  protected String[] getProperties(Class<?> testClass) {
    MybatisTest annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, MybatisTest.class);
    return (annotation != null) ? annotation.properties() : null;
  }"
4807,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
4808,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:"
4809,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
4810,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
4811,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
4812,"  public String getMessage() {
    return ""Hello!"";
  }"
4813,"  public String getMessage() {
    return ""Goodbye!"";
  }"
4814,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
4815,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
4816,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
4817,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
4818,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
4819,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
4820,"  public Long getId() {
    return id;
  }"
4821,"  public void setId(Long id) {
    this.id = id;
  }"
4822,"  public String getName() {
    return name;
  }"
4823,"  public void setName(String name) {
    this.name = name;
  }"
4824,"  Sample findByName(String name);

}"
4825,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
4826,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
4827,"  public Long getId() {
    return this.id;
  }"
4828,"  public void setId(Long id) {
    this.id = id;
  }"
4829,"  public String getName() {
    return this.name;
  }"
4830,"  public void setName(String name) {
    this.name = name;
  }"
4831,"  public String getState() {
    return this.state;
  }"
4832,"  public void setState(String state) {
    this.state = state;
  }"
4833,"  public String getCountry() {
    return this.country;
  }"
4834,"  public void setCountry(String country) {
    this.country = country;
  }"
4835,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4836,"  City findByState(@Param(""state"") String state);

}"
4837,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4838,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4839,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4840,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4841,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4842,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4843,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4844,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4845,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4846,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4847,"    private void flush() {
      try {
        this.captureOut.flush();"
4848,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4849,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4850,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4851,"      PrintStream getOriginal() {
        return this.original;
      }"
4852,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4853,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4854,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4855,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4856,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4857,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4858,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4859,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
4860,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
4861,"  public Long getId() {
    return this.id;
  }"
4862,"  public void setId(Long id) {
    this.id = id;
  }"
4863,"  public String getName() {
    return this.name;
  }"
4864,"  public void setName(String name) {
    this.name = name;
  }"
4865,"  public String getState() {
    return this.state;
  }"
4866,"  public void setState(String state) {
    this.state = state;
  }"
4867,"  public String getCountry() {
    return this.country;
  }"
4868,"  public void setCountry(String country) {
    this.country = country;
  }"
4869,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4870,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4871,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4872,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4873,"  City findByCountry(@Param(""country"") String country);

}"
4874,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4875,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4876,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4877,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4878,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4879,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4880,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4881,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4882,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4883,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4884,"    private void flush() {
      try {
        this.captureOut.flush();"
4885,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4886,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4887,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4888,"      PrintStream getOriginal() {
        return this.original;
      }"
4889,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4890,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4891,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4892,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4893,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4894,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4895,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4896,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4897,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4898,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4899,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
4900,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
4901,"  public Long getId() {
    return this.id;
  }"
4902,"  public void setId(Long id) {
    this.id = id;
  }"
4903,"  public String getName() {
    return this.name;
  }"
4904,"  public void setName(String name) {
    this.name = name;
  }"
4905,"  public String getState() {
    return this.state;
  }"
4906,"  public void setState(String state) {
    this.state = state;
  }"
4907,"  public String getCountry() {
    return this.country;
  }"
4908,"  public void setCountry(String country) {
    this.country = country;
  }"
4909,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4910,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4911,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
4912,"  City findByName(@Param(""name"") String name);

}"
4913,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4914,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4915,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4916,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4917,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4918,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4919,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4920,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4921,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4922,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4923,"    private void flush() {
      try {
        this.captureOut.flush();"
4924,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4925,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4926,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4927,"      PrintStream getOriginal() {
        return this.original;
      }"
4928,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4929,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4930,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4931,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4932,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4933,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
4934,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4935,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4936,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4937,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4938,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4939,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4940,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4941,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4942,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4943,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4944,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4945,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4946,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4947,"    private void flush() {
      try {
        this.captureOut.flush();"
4948,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4949,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4950,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4951,"      PrintStream getOriginal() {
        return this.original;
      }"
4952,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4953,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4954,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4955,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4956,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
4957,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
4958,"  public Long getId() {
    return this.id;
  }"
4959,"  public void setId(Long id) {
    this.id = id;
  }"
4960,"  public String getName() {
    return this.name;
  }"
4961,"  public void setName(String name) {
    this.name = name;
  }"
4962,"  public String getState() {
    return this.state;
  }"
4963,"  public void setState(String state) {
    this.state = state;
  }"
4964,"  public String getCountry() {
    return this.country;
  }"
4965,"  public void setCountry(String country) {
    this.country = country;
  }"
4966,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
4967,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4968,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4969,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
4970,"  City findByCountry(@Param(""country"") String country);

}"
4971,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
4972,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
4973,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
4974,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
4975,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
4976,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
4977,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
4978,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
4979,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
4980,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
4981,"    private void flush() {
      try {
        this.captureOut.flush();"
4982,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
4983,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
4984,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
4985,"      PrintStream getOriginal() {
        return this.original;
      }"
4986,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
4987,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
4988,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
4989,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
4990,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4991,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
4992,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4993,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4994,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
4995,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
4996,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
4997,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
4998,"  public Long getId() {
    return this.id;
  }"
4999,"  public void setId(Long id) {
    this.id = id;
  }"
5000,"  public String getName() {
    return this.name;
  }"
5001,"  public void setName(String name) {
    this.name = name;
  }"
5002,"  public String getState() {
    return this.state;
  }"
5003,"  public void setState(String state) {
    this.state = state;
  }"
5004,"  public String getCountry() {
    return this.country;
  }"
5005,"  public void setCountry(String country) {
    this.country = country;
  }"
5006,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
5007,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
5008,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
5009,"  City findByName(@Param(""name"") String name);

}"
5010,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
5011,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
5012,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
5013,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
5014,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
5015,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
5016,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
5017,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
5018,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
5019,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
5020,"    private void flush() {
      try {
        this.captureOut.flush();"
5021,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
5022,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
5023,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
5024,"      PrintStream getOriginal() {
        return this.original;
      }"
5025,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
5026,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
5027,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
5028,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
5029,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
5030,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
5031,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5032,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5033,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5034,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
5035,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
5036,"  public Long getId() {
    return this.id;
  }"
5037,"  public void setId(Long id) {
    this.id = id;
  }"
5038,"  public String getName() {
    return this.name;
  }"
5039,"  public void setName(String name) {
    this.name = name;
  }"
5040,"  public String getState() {
    return this.state;
  }"
5041,"  public void setState(String state) {
    this.state = state;
  }"
5042,"  public String getCountry() {
    return this.country;
  }"
5043,"  public void setCountry(String country) {
    this.country = country;
  }"
5044,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
5045,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
5046,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
5047,"  City findByName(@Param(""name"") String name);

}"
5048,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
5049,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
5050,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
5051,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
5052,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
5053,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
5054,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
5055,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
5056,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
5057,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
5058,"    private void flush() {
      try {
        this.captureOut.flush();"
5059,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
5060,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
5061,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
5062,"      PrintStream getOriginal() {
        return this.original;
      }"
5063,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
5064,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
5065,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
5066,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
5067,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
5068,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
5069,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5070,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5071,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5072,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
5073,"  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebApplication.class);
  }"
5074,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
5075,"  public Long getId() {
    return this.id;
  }"
5076,"  public void setId(Long id) {
    this.id = id;
  }"
5077,"  public String getName() {
    return this.name;
  }"
5078,"  public void setName(String name) {
    this.name = name;
  }"
5079,"  public String getState() {
    return this.state;
  }"
5080,"  public void setState(String state) {
    this.state = state;
  }"
5081,"  public String getCountry() {
    return this.country;
  }"
5082,"  public void setCountry(String country) {
    this.country = country;
  }"
5083,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
5084,"  City findByState(@Param(""state"") String state);

}"
5085,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
5086,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
5087,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5088,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
5089,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
5090,"  public Long getId() {
    return this.id;
  }"
5091,"  public void setId(Long id) {
    this.id = id;
  }"
5092,"  public String getName() {
    return this.name;
  }"
5093,"  public void setName(String name) {
    this.name = name;
  }"
5094,"  public String getState() {
    return this.state;
  }"
5095,"  public void setState(String state) {
    this.state = state;
  }"
5096,"  public String getCountry() {
    return this.country;
  }"
5097,"  public void setCountry(String country) {
    this.country = country;
  }"
5098,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
5099,"  City findByState(@Param(""state"") String state);

}"
5100,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
5101,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5102,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
5103,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
5104,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
5105,"  public Long getId() {
    return this.id;
  }"
5106,"  public void setId(Long id) {
    this.id = id;
  }"
5107,"  public String getName() {
    return this.name;
  }"
5108,"  public void setName(String name) {
    this.name = name;
  }"
5109,"  public String getState() {
    return this.state;
  }"
5110,"  public void setState(String state) {
    this.state = state;
  }"
5111,"  public String getCountry() {
    return this.country;
  }"
5112,"  public void setCountry(String country) {
    this.country = country;
  }"
5113,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
5114,"  public Long getCity() {
    return city;
  }"
5115,"  public void setCity(Long city) {
    this.city = city;
  }"
5116,"  public String getName() {
    return name;
  }"
5117,"  public void setName(String name) {
    this.name = name;
  }"
5118,"  public String getAddress() {
    return address;
  }"
5119,"  public void setAddress(String address) {
    this.address = address;
  }"
5120,"  public String getZip() {
    return zip;
  }"
5121,"  public void setZip(String zip) {
    this.zip = zip;
  }"
5122,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
5123,"  Hotel selectByCityId(int cityId);

}"
5124,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
5125,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
5126,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
5127,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
5128,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
5129,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
5130,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
5131,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
5132,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
5133,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
5134,"    private void flush() {
      try {
        this.captureOut.flush();"
5135,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
5136,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
5137,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
5138,"      PrintStream getOriginal() {
        return this.original;
      }"
5139,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
5140,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
5141,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
5142,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
5143,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
5144,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
5145,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
5146,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getCity()).isEqualTo(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
5147,"  City findByState(@Param(""state"") String state);

}"
5148,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertAll(() -> assertThat(properties.size()).isEqualTo(5), () -> {
      // assert for mybatis.configuration.default-scripting-language"
5149,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
5150,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
5151,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5152,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5153,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
5154,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5155,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5156,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5157,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5158,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5159,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5160,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5161,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5162,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5163,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
5164,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
5165,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
5166,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
5167,"  void testWithInterceptorsOrder1() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor2.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor.class);

    this.context.close();
  }"
5168,"  void testWithInterceptorsOrder2() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration2.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor2.class);

    this.context.close();
  }"
5169,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
5170,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
5171,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
  }"
5172,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5173,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
5174,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
5175,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5176,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5177,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
5178,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5179,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5180,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
5181,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
5182,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5183,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5184,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
5185,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");"
5186,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
5187,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
  }"
5188,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
5189,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
5190,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5191,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5192,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5193,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
5194,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5195,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5196,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5197,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5198,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5199,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5200,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5201,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5202,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5203,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5204,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5205,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5206,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5207,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5208,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5209,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5210,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5211,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5212,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5213,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5214,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5215,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5216,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5217,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5218,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5219,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5220,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5221,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5222,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5223,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5224,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5225,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5226,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5227,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5228,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5229,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
5230,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
5231,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }

    return factory.getObject();
  }"
5232,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
5233,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
5234,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
5235,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
5236,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
5237,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
5238,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
5239,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertAll(() -> assertThat(properties.size()).isEqualTo(6), () -> {
      // assert for mybatis.configuration.default-scripting-language"
5240,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
5241,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
5242,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5243,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5244,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
5245,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5246,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5247,"  void testAutoScanWithDefault() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""sqlSessionTemplate"");
    assertThat(
        this.context.getBeanDefinition(this.context.getBeanNamesForType(MapperScannerConfigurer.class)[0]).getRole())"
5248,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    TestPropertyValues.of(""mybatis.inject-sql-session-on-mapper-scan:false"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionTemplate""))
        .isNull();
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionFactory""))
        .isNull();"
5249,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5250,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5251,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5252,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5253,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5254,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5255,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5256,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
5257,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
5258,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
5259,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
5260,"  void testWithInterceptorsOrder1() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor2.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor.class);

    this.context.close();
  }"
5261,"  void testWithInterceptorsOrder2() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration2.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor2.class);

    this.context.close();
  }"
5262,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
5263,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
5264,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
  }"
5265,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5266,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
5267,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
5268,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5269,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5270,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
5271,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5272,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5273,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
5274,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
5275,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5276,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5277,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
5278,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionFactory"").getValue()).getBeanName()).isEqualTo(""customSqlSessionFactory"");"
5279,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
5280,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5281,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
5282,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, CustomSqlSessionTemplateConfiguration.class,
        MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5283,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
5284,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5285,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5286,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5287,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
5288,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5289,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5290,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5291,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5292,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5293,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5294,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5295,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5296,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5297,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5298,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5299,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5300,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5301,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5302,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5303,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5304,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5305,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5306,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5307,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5308,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5309,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5310,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5311,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5312,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5313,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5314,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5315,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5316,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5317,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5318,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5319,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5320,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5321,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5322,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5323,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
5324,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
5325,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) {
      factory.setMapperLocations(this.properties.resolveMapperLocations());
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }
    applySqlSessionFactoryBeanCustomizers(factory);
    return factory.getObject();
  }"
5326,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
5327,"  private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
      for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {"
5328,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
5329,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
5330,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
5331,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
5332,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
5333,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
5334,"  void customize(SqlSessionFactoryBean factoryBean);

}"
5335,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
5336,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
5337,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5338,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5339,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
5340,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5341,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5342,"  void testAutoScanWithDefault() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""sqlSessionTemplate"");
    assertThat(
        this.context.getBeanDefinition(this.context.getBeanNamesForType(MapperScannerConfigurer.class)[0]).getRole())"
5343,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    TestPropertyValues.of(""mybatis.inject-sql-session-on-mapper-scan:false"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionTemplate""))
        .isNull();
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionFactory""))
        .isNull();"
5344,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5345,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5346,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5347,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5348,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5349,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5350,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5351,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
5352,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
5353,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
5354,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
5355,"  void testWithInterceptorsOrder1() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor2.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor.class);

    this.context.close();
  }"
5356,"  void testWithInterceptorsOrder2() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration2.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor2.class);

    this.context.close();
  }"
5357,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
5358,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
5359,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
  }"
5360,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5361,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
5362,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
5363,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5364,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5365,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
5366,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5367,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5368,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5369,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
5370,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
5371,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5372,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5373,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
5374,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionFactory"").getValue()).getBeanName()).isEqualTo(""customSqlSessionFactory"");"
5375,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
5376,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5377,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
5378,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, CustomSqlSessionTemplateConfiguration.class,
        MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5379,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
5380,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5381,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5382,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5383,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
5384,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5385,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5386,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5387,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5388,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5389,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5390,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5391,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5392,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5393,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5394,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5395,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5396,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5397,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5398,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5399,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5400,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5401,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5402,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5403,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5404,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5405,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5406,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5407,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5408,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5409,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5410,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5411,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5412,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5413,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5414,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5415,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5416,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5417,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

}"
5418,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5419,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5420,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5421,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
5422,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
5423,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
5424,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
5425,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
5426,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
5427,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    Resource[] mapperLocations = this.properties.resolveMapperLocations();
    if (!ObjectUtils.isEmpty(mapperLocations)) {
      factory.setMapperLocations(mapperLocations);
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }
    applySqlSessionFactoryBeanCustomizers(factory);
    return factory.getObject();
  }"
5428,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
5429,"  private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
      for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {"
5430,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
5431,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
5432,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
5433,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
5434,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
5435,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
5436,"  protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
    return Collections.singleton(SqlSessionTemplate.class);
  }"
5437,"  void init() {
    this.context = new AnnotationConfigApplicationContext();
  }"
5438,"  void closeContext() {
    if (this.context != null) {
      this.context.close();"
5439,"  void testNoDataSource() {
    this.context.register(MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5440,"  void testMultipleDataSource() {
    this.context.register(MultipleDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).isEmpty();
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).isEmpty();
  }"
5441,"  void testSingleCandidateDataSource() {
    this.context.register(SingleCandidateDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(MybatisProperties.class)).hasSize(1);
  }"
5442,"  void testDefaultConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    Map<String, LanguageDriver> languageDriverBeans = this.context.getBeansOfType(LanguageDriver.class);
    assertThat(languageDriverBeans).hasSize(3).containsKeys(""freeMarkerLanguageDriver"", ""velocityLanguageDriver"",
        ""thymeleafLanguageDriver"");
    assertThat(languageDriverBeans.get(""freeMarkerLanguageDriver"")).isInstanceOf(FreeMarkerLanguageDriver.class);
    assertThat(languageDriverBeans.get(""velocityLanguageDriver"")).isInstanceOf(VelocityLanguageDriver.class);
    assertThat(languageDriverBeans.get(""thymeleafLanguageDriver"")).isInstanceOf(ThymeleafLanguageDriver.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(XMLLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(RawLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(FreeMarkerLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(VelocityLanguageDriver.class)).isNotNull();
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5443,"  void testScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(DateTimeMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5444,"  void testAutoScanWithDefault() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""sqlSessionTemplate"");
    assertThat(
        this.context.getBeanDefinition(this.context.getBeanNamesForType(MapperScannerConfigurer.class)[0]).getRole())"
5445,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    TestPropertyValues.of(""mybatis.inject-sql-session-on-mapper-scan:false"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionTemplate""))
        .isNull();
    assertThat(this.context.getBeanDefinition(""cityMapper"").getPropertyValues().getPropertyValue(""sqlSessionFactory""))
        .isNull();"
5446,"  void testAutoScanWithLazy() {
    TestPropertyValues.of(""mybatis.lazy-initialization:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(0);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    this.context.getBean(CityMapper.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
  }"
5447,"  void testAutoScanWithDefaultScope() {
    TestPropertyValues.of(""mybatis.mapper-default-scope:thread"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5448,"  void testAutoScanWithoutDefaultScope() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    {
      this.context.getBean(CityMapper.class);"
5449,"  void testWithConfigLocation() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapperImpl.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5450,"  void testWithCheckConfigLocationFileExists() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5451,"  void testWithCheckConfigLocationFileNotSpecify() {
    TestPropertyValues.of(""mybatis.check-config-location=true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
  }"
5452,"  void testWithCheckConfigLocationFileDoesNotExists() {

    TestPropertyValues.of(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5453,"  void testWithTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    TypeHandlerRegistry typeHandlerRegistry = this.context.getBean(SqlSessionFactory.class).getConfiguration()
        .getTypeHandlerRegistry();
    assertThat(typeHandlerRegistry.hasTypeHandler(BigInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicInteger.class)).isTrue();
    assertThat(typeHandlerRegistry.hasTypeHandler(AtomicLong.class)).isTrue();
  }"
5454,"  void testWithMapperLocation() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getMappedStatementNames()).hasSize(2);
  }"
5455,"  void testWithExecutorType() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.executor-type:REUSE"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisMapperConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
  }"
5456,"  void testDefaultBootConfiguration() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
  }"
5457,"  void testWithInterceptorsOrder1() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor2.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor.class);

    this.context.close();
  }"
5458,"  void testWithInterceptorsOrder2() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration2.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors()).hasSize(2);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(0))
        .isInstanceOf(MyInterceptor.class);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getInterceptors().get(1))
        .isInstanceOf(MyInterceptor2.class);

    this.context.close();
  }"
5459,"  void testWithTypeHandlers() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisTypeHandlerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getTypeHandlerRegistry()
        .getTypeHandler(UUID.class)).isInstanceOf(MyTypeHandler.class);
    this.context.close();
  }"
5460,"  void testWithDatabaseIdProvider() {
    this.context.register(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getDatabaseId()).isEqualTo(""h2"");
  }"
5461,"  void testMixedWithConfigurationFileAndInterceptor() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
  }"
5462,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5463,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.boot.autoconfigure.handler."").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class).toString())
        .isEqualTo(""type="" + AtomicInteger.class);"
5464,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config-settings-only.xml"",
            ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""name"");
  }"
5465,"  void testMixedWithFullConfigurations() {
    TestPropertyValues.of(""mybatis.config-location:mybatis-config-settings-only.xml"",
        ""mybatis.type-handlers-package:org.mybatis.spring.**.handler"",
        ""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
        ""mybatis.mapper-locations:classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
        ""mybatis.executor-type=REUSE"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        MybatisInterceptorConfiguration.class, DatabaseProvidersConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(configuration.getDefaultFetchSize()).isEqualTo(1000);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicInteger.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getTypeHandlerRegistry().getTypeHandler(AtomicLong.class))
        .isInstanceOf(AtomicNumberTypeHandler.class);
    assertThat(configuration.getMappedStatementNames()).hasSize(4);
    assertThat(configuration.getMappedStatementNames()).contains(""selectCityById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.repository.CityMapperImpl.selectCityById"");
    assertThat(configuration.getMappedStatementNames()).contains(""findById"");
    assertThat(configuration.getMappedStatementNames())
        .contains(""org.mybatis.spring.boot.autoconfigure.mapper.CityMapper.findById"");
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.REUSE);
    assertThat(configuration.getInterceptors()).hasSize(2);
    assertThat(configuration.getInterceptors().get(0)).isInstanceOf(MyInterceptor2.class);
    assertThat(configuration.getInterceptors().get(1)).isInstanceOf(MyInterceptor.class);
    assertThat(configuration.getDatabaseId()).isEqualTo(""h2"");
  }"
5466,"  void testWithMyBatisConfiguration() {
    TestPropertyValues.of(""mybatis.configuration.map-underscore-to-camel-case:true"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isTrue();
  }"
5467,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    TestPropertyValues.of(""mybatis.configuration.default-fetch-size:100"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MybatisPropertiesConfigurationCustomizer.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getDefaultFetchSize()).isEqualTo(100);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);"
5468,"  void testWithMyBatisConfigurationCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MyBatisConfigurationCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5469,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().getTypeHandler(BigInteger.class))
        .isInstanceOf(DummyTypeHandler.class);
    assertThat(sqlSessionFactory.getConfiguration().getCache(""test"")).isNotNull();
  }"
5470,"  void testConfigFileAndConfigurationWithTogether() {
    TestPropertyValues
        .of(""mybatis.config-location:mybatis-config.xml"", ""mybatis.configuration.default-statement-timeout:30"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class);

    try {
      this.context.refresh();"
5471,"  void testWithoutConfigurationVariablesAndProperties() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).isEmpty();
  }"
5472,"  void testWithConfigurationVariablesOnly() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
  }"
5473,"  void testWithConfigurationPropertiesOnly() {
    TestPropertyValues.of(""mybatis.configuration-properties.key2:value2"").applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5474,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key1:value1"", ""mybatis.configuration-properties.key2:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(2);
    assertThat(variables.getProperty(""key1"")).isEqualTo(""value1"");
    assertThat(variables.getProperty(""key2"")).isEqualTo(""value2"");
  }"
5475,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    TestPropertyValues.of(""mybatis.configuration.variables.key:value1"", ""mybatis.configuration-properties.key:value2"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();

    Properties variables = this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables();
    assertThat(variables).hasSize(1);
    assertThat(variables.getProperty(""key"")).isEqualTo(""value2"");
  }"
5476,"  void testCustomSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().getVariables().getProperty(""key""))
        .isEqualTo(""value"");
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionFactory"").getValue()).getBeanName()).isEqualTo(""customSqlSessionFactory"");"
5477,"  void testMySqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionFactoryConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionFactory.class)).isInstanceOf(MySqlSessionFactory.class);
  }"
5478,"  void testCustomSqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionTemplateConfiguration.class, MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5479,"  void testMySqlSessionTemplate() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class,
        MySqlSessionTemplateConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class)).isInstanceOf(MySqlSessionTemplate.class);
  }"
5480,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,
        CustomSqlSessionFactoryConfiguration.class, CustomSqlSessionTemplateConfiguration.class,
        MybatisAutoConfiguration.class);
    this.context.refresh();
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.BATCH);
    assertThat(this.context.getBeanNamesForType(CityMapper.class)).hasSize(1);
    assertThat(((RuntimeBeanReference) this.context.getBeanDefinition(""cityMapper"").getPropertyValues()
        .getPropertyValue(""sqlSessionTemplate"").getValue()).getBeanName()).isEqualTo(""customSqlSessionTemplate"");"
5481,"  void testTypeAliasesSuperTypeIsSpecify() {
    TestPropertyValues
        .of(""mybatis.type-aliases-package:org.mybatis.spring.boot.autoconfigure.domain"",
            ""mybatis.type-aliases-super-type:org.mybatis.spring.boot.autoconfigure.domain.Domain"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class);
    this.context.refresh();

    org.apache.ibatis.session.Configuration configuration = this.context.getBean(SqlSessionFactory.class)
        .getConfiguration();
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).containsKey(""city"");
    assertThat(configuration.getTypeAliasRegistry().getTypeAliases()).doesNotContainKey(""name"");
  }"
5482,"  void testMapperFactoryBean() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperFactoryBeanConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5483,"  void testMapperScannerConfigurer() {
    this.context.register(EmbeddedDataSourceConfiguration.class, MapperScannerConfigurerConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
  }"
5484,"  void testDefaultScriptingLanguageIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5485,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        MybatisAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    assertThat(sqlSessionFactory.getConfiguration().getMapperRegistry().getMappers()).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionFactory.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(SqlSessionTemplate.class)).hasSize(1);
    assertThat(this.context.getBeanNamesForType(DateTimeMapper.class)).hasSize(1);
    assertThat(this.context.getBean(SqlSessionTemplate.class).getExecutorType()).isEqualTo(ExecutorType.SIMPLE);
    assertThat(this.context.getBean(SqlSessionFactory.class).getConfiguration().isMapUnderscoreToCamelCase()).isFalse();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(0);
  }"
5486,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    TestPropertyValues
        .of(""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(ThymeleafLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5487,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    TestPropertyValues
        .of(""mybatis.default-scripting-language-driver:org.apache.ibatis.scripting.xmltags.XMLLanguageDriver"",
            ""spring.autoconfigure.exclude:org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration"")
        .applyTo(this.context);
    this.context.register(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,
        SingleLanguageDriverConfiguration.class, MybatisAutoConfiguration.class,
        PropertyPlaceholderAutoConfiguration.class);
    this.context.refresh();
    SqlSessionFactory sqlSessionFactory = this.context.getBean(SqlSessionFactory.class);
    LanguageDriverRegistry languageDriverRegistry = sqlSessionFactory.getConfiguration().getLanguageRegistry();
    assertThat(this.context.getBeanNamesForType(LanguageDriver.class)).hasSize(1);
    assertThat(languageDriverRegistry.getDefaultDriverClass()).isEqualTo(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDefaultDriver()).isInstanceOf(XMLLanguageDriver.class);
    assertThat(languageDriverRegistry.getDriver(ThymeleafLanguageDriver.class)).isNotNull();
  }"
5488,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5489,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
5490,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5491,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5492,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
5493,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5494,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5495,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5496,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5497,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5498,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5499,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5500,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5501,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5502,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5503,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5504,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5505,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5506,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5507,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5508,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5509,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5510,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5511,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5512,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5513,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5514,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5515,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5516,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5517,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5518,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5519,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5520,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5521,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5522,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5523,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5524,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5525,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5526,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5527,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5528,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
5529,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
5530,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
5531,"  protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
    return Collections.singleton(SqlSessionTemplate.class);
  }"
5532,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
5533,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5534,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5535,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
5536,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5537,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5538,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5539,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5540,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5541,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5542,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5543,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
5544,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
5545,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
5546,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5547,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5548,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5549,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5550,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5551,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5552,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5553,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
5554,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
5555,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5556,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5557,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5558,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5559,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
5560,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisPropertiesConfigurationCustomizer.class)"
5561,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
5562,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
5563,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
5564,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5565,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5566,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5567,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5568,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5569,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5570,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
5571,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5572,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
5573,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
5574,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5575,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5576,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5577,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5578,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5579,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5580,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5581,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5582,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
5583,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5584,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5585,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
5586,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5587,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5588,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5589,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5590,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5591,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5592,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5593,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5594,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5595,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5596,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5597,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5598,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5599,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5600,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5601,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5602,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5603,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5604,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5605,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5606,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5607,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5608,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5609,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5610,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5611,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5612,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5613,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5614,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5615,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5616,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5617,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5618,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5619,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5620,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5621,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
5622,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
5623,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
5624,"  void testDefaultConfiguration() {
    this.contextRunner.run(context -> {
      Map<String, LanguageDriver> languageDriverBeans = context.getBeansOfType(LanguageDriver.class);"
5625,"  void testCustomConfiguration() {
    this.contextRunner.withUserConfiguration(MyLanguageDriverConfig.class)
        .run(context -> {"
5626,"  void testLegacyConfiguration() {
    new ApplicationContextRunner()
        .withUserConfiguration(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class)"
5627,"  void testCustomThymeleafConfig() {
    this.contextRunner
        .withUserConfiguration(ThymeleafCustomLanguageDriverConfig.class)"
5628,"  void testCustomFreeMarkerConfig() {
    this.contextRunner
        .withUserConfiguration(FreeMarkerCustomLanguageDriverConfig.class)"
5629,"  void testCustomVelocityConfig() {
    this.contextRunner.withUserConfiguration(VelocityCustomLanguageDriverConfig.class).run(context -> {
      VelocityLanguageDriver driver = context.getBean(VelocityLanguageDriver.class);"
5630,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class).withPropertyValues(
        ""mybatis.scripting-language-driver.thymeleaf.use2way=false"","
5631,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.freemarker.base-package=sqls"","
5632,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),"
5633,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    new ApplicationContextRunner().withUserConfiguration(MyAutoConfiguration.class)
        .run(context -> assertThat(context.getBeanNamesForType(LanguageDriver.class)).isEmpty());"
5634,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
5635,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
5636,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5637,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
5638,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
5639,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
5640,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
5641,"    public String getName() {
      return ""now"";
    }"
5642,"    public int getType() {
      return LINE;
    }"
5643,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
5644,"  public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    AnnotationAttributes attributes = AnnotationAttributes
        .fromMap(metadata.getAnnotationAttributes(TestAutoConfigurationPackage.class.getName(), true));
    AutoConfigurationPackages.register(registry, ClassUtils.getPackageName(attributes.getString(""value"")));
  }"
5645,"  void initializeVelocity() {
    VelocityFacade.destroy();
  }"
5646,"  void testDefaultConfiguration() {
    this.contextRunner.run(context -> {
      Map<String, LanguageDriver> languageDriverBeans = context.getBeansOfType(LanguageDriver.class);"
5647,"  void testCustomConfiguration() {
    this.contextRunner.withUserConfiguration(MyLanguageDriverConfig.class).run(context -> {
      Map<String, LanguageDriver> languageDriverBeans = context.getBeansOfType(LanguageDriver.class);"
5648,"  void testLegacyConfiguration() {
    new ApplicationContextRunner()
        .withUserConfiguration(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class)"
5649,"  void testCustomThymeleafConfig() {
    this.contextRunner.withUserConfiguration(ThymeleafCustomLanguageDriverConfig.class).run(context -> {
      ThymeleafLanguageDriver driver = context.getBean(ThymeleafLanguageDriver.class);"
5650,"  void testCustomFreeMarkerConfig() {
    this.contextRunner.withUserConfiguration(FreeMarkerCustomLanguageDriverConfig.class).run(context -> {
      FreeMarkerLanguageDriver driver = context.getBean(FreeMarkerLanguageDriver.class);"
5651,"  void testCustomVelocityConfig() {
    this.contextRunner.withUserConfiguration(VelocityCustomLanguageDriverConfig.class).run(context -> {
      VelocityLanguageDriver driver = context.getBean(VelocityLanguageDriver.class);"
5652,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class).withPropertyValues(
        ""mybatis.scripting-language-driver.thymeleaf.use2way=false"","
5653,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.freemarker.base-package=sqls"","
5654,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),"
5655,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    new ApplicationContextRunner().withUserConfiguration(MyAutoConfiguration.class)
        .run(context -> assertThat(context.getBeanNamesForType(LanguageDriver.class)).isEmpty());"
5656,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
5657,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
5658,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5659,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
5660,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
5661,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
5662,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
5663,"    public String getName() {
      return ""now"";
    }"
5664,"    public int getType() {
      return LINE;
    }"
5665,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
5666,"  protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
    return Collections.singleton(SqlSessionTemplate.class);
  }"
5667,"  public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    AnnotationAttributes attributes = AnnotationAttributes
        .fromMap(metadata.getAnnotationAttributes(TestAutoConfigurationPackage.class.getName(), true));
    AutoConfigurationPackages.register(registry, ClassUtils.getPackageName(attributes.getString(""value"")));
  }"
5668,"  public boolean isValid() {
    return true;
  }"
5669,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = url.toString();
    urlString = URLDecoder.decode(urlString, Charset.defaultCharset().name());
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
5670,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
5671,"  public boolean isValid() {
    return true;
  }"
5672,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = URLDecoder.decode(url.toString(), urlDecodingCharset.name());
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
5673,"  public static void setUrlDecodingCharset(Charset charset) {
    urlDecodingCharset = charset;
  }"
5674,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
5675,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
5676,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5677,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5678,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
5679,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5680,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5681,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5682,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5683,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5684,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5685,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5686,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
5687,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
5688,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
5689,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5690,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5691,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5692,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5693,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5694,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5695,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5696,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
5697,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
5698,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5699,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5700,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5701,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5702,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
5703,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisPropertiesConfigurationCustomizer.class)"
5704,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
5705,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
5706,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
5707,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5708,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5709,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5710,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5711,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5712,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5713,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
5714,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5715,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
5716,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
5717,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5718,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5719,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5720,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5721,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5722,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5723,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5724,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5725,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
5726,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5727,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5728,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
5729,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5730,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5731,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5732,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5733,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5734,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5735,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5736,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5737,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5738,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5739,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5740,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5741,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5742,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5743,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5744,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5745,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5746,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5747,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5748,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5749,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5750,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5751,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5752,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5753,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5754,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5755,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5756,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5757,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5758,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5759,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5760,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5761,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5762,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5763,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5764,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5765,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
5766,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
5767,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
5768,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
5769,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5770,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5771,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
5772,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5773,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5774,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5775,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5776,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5777,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5778,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5779,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
5780,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
5781,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
5782,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5783,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5784,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5785,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5786,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5787,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5788,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5789,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
5790,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
5791,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5792,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5793,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5794,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5795,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
5796,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisPropertiesConfigurationCustomizer.class)"
5797,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
5798,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
5799,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
5800,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5801,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5802,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5803,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5804,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5805,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5806,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
5807,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5808,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
5809,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
5810,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5811,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5812,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5813,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5814,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5815,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5816,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5817,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5818,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
5819,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5820,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5821,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
5822,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5823,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5824,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5825,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5826,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5827,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5828,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5829,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5830,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5831,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5832,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5833,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5834,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5835,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5836,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5837,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5838,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5839,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5840,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5841,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5842,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5843,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5844,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5845,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5846,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5847,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5848,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5849,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5850,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5851,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5852,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5853,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5854,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5855,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5856,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5857,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5858,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
5859,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
5860,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
5861,"  void customize(Configuration configuration);

}"
5862,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
5863,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
5864,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    factory.setVfs(SpringBootVFS.class);
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    Resource[] mapperLocations = this.properties.resolveMapperLocations();
    if (!ObjectUtils.isEmpty(mapperLocations)) {
      factory.setMapperLocations(mapperLocations);
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }
    applySqlSessionFactoryBeanCustomizers(factory);
    return factory.getObject();
  }"
5865,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    Configuration configuration = this.properties.getConfiguration();
    if (configuration == null && !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
5866,"  private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
      for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {"
5867,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
5868,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
5869,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
5870,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
5871,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
5872,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
5873,"  protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
    return Collections.singleton(SqlSessionTemplate.class);
  }"
5874,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
5875,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
5876,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
5877,"    org.mybatis.scripting.velocity.Driver velocityLanguageDriver() {
      return new org.mybatis.scripting.velocity.Driver();
    }"
5878,"    VelocityLanguageDriver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new VelocityLanguageDriver(config);
    }"
5879,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
5880,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
5881,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
5882,"      public DialectConfig getDialect() {
        return super.getDialect();
      }"
5883,"      public TemplateFileConfig getTemplateFile() {
        return super.getTemplateFile();
      }"
5884,"  public boolean isValid() {
    return true;
  }"
5885,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = URLDecoder.decode(url.toString(), urlDecodingCharset.name());
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
5886,"  public static void setUrlDecodingCharset(Charset charset) {
    urlDecodingCharset = charset;
  }"
5887,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
5888,"  void customize(SqlSessionFactoryBean factoryBean);

}"
5889,"  LocalDateTime now();

}"
5890,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertAll(() -> assertThat(properties.size()).isEqualTo(6), () -> {
      // assert for mybatis.configuration.default-scripting-language"
5891,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
5892,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5893,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5894,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
5895,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5896,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5897,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5898,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5899,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5900,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5901,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5902,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
5903,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
5904,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
5905,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5906,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5907,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
5908,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5909,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5910,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5911,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5912,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
5913,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
5914,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5915,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5916,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5917,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5918,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
5919,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisPropertiesConfigurationCustomizer.class)"
5920,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
5921,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
5922,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
5923,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5924,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5925,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5926,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5927,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
5928,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5929,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
5930,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
5931,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
5932,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
5933,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5934,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5935,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
5936,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5937,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5938,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5939,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
5940,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5941,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
5942,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5943,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
5944,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
5945,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
5946,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5947,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5948,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
5949,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
5950,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
5951,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
5952,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
5953,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
5954,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5955,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5956,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
5957,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
5958,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
5959,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5960,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
5961,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
5962,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
5963,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
5964,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5965,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
5966,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5967,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5968,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
5969,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
5970,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5971,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
5972,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
5973,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
5974,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
5975,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
5976,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
5977,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
5978,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
5979,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
5980,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
5981,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
5982,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
5983,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
5984,"  void initializeVelocity() {
    VelocityFacade.destroy();
  }"
5985,"  void testDefaultConfiguration() {
    this.contextRunner.run(context -> {
      Map<String, LanguageDriver> languageDriverBeans = context.getBeansOfType(LanguageDriver.class);"
5986,"  void testCustomConfiguration() {
    this.contextRunner.withUserConfiguration(MyLanguageDriverConfig.class).run(context -> {
      Map<String, LanguageDriver> languageDriverBeans = context.getBeansOfType(LanguageDriver.class);"
5987,"  void testLegacyConfiguration() {
    new ApplicationContextRunner()
        .withUserConfiguration(TestingLegacyFreeMarkerConfiguration.class, TestingLegacyVelocityConfiguration.class)"
5988,"  void testCustomThymeleafConfig() {
    this.contextRunner.withUserConfiguration(ThymeleafCustomLanguageDriverConfig.class).run(context -> {
      ThymeleafLanguageDriver driver = context.getBean(ThymeleafLanguageDriver.class);"
5989,"  void testCustomFreeMarkerConfig() {
    this.contextRunner.withUserConfiguration(FreeMarkerCustomLanguageDriverConfig.class).run(context -> {
      FreeMarkerLanguageDriver driver = context.getBean(FreeMarkerLanguageDriver.class);"
5990,"  void testCustomVelocityConfig() {
    this.contextRunner.withUserConfiguration(VelocityCustomLanguageDriverConfig.class).run(context -> {
      VelocityLanguageDriver driver = context.getBean(VelocityLanguageDriver.class);"
5991,"  void testCustomThymeleafConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class).withPropertyValues(
        ""mybatis.scripting-language-driver.thymeleaf.use2way=false"","
5992,"  void testCustomFreeMarkerConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.freemarker.base-package=sqls"","
5993,"  void testCustomVelocityConfigUsingConfigurationProperty() {
    this.contextRunner.withUserConfiguration(MyAutoConfiguration.class)
        .withPropertyValues(""mybatis.scripting-language-driver.velocity.userdirective="" + NowDirective.class.getName(),"
5994,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    new ApplicationContextRunner().withUserConfiguration(MyAutoConfiguration.class)
        .run(context -> assertThat(context.getBeanNamesForType(LanguageDriver.class)).isEmpty());"
5995,"    FreeMarkerLanguageDriver myFreeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
5996,"    VelocityLanguageDriver myVelocityLanguageDriver() {
      return new VelocityLanguageDriver();
    }"
5997,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
5998,"    ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance(c -> c.getDialect().setPrefix(""m""));
    }"
5999,"    FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig
          .newInstance(c -> c.getFreemarkerSettings().put(""interpolation_syntax"", ""dollar""));"
6000,"    VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance(
          c -> c.getVelocitySettings().put(RuntimeConstants.CUSTOM_DIRECTIVES, NowDirective.class.getName()));"
6001,"    public void customize(TemplateEngine defaultTemplateEngine) {
    }
  }

  public static class NowDirective extends Directive {

    @Override
    public String getName() {
      return ""now"";
    }

    @Override
    public int getType() {
      return LINE;
    }

    @Override
    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }

  }
}"
6002,"    public String getName() {
      return ""now"";
    }"
6003,"    public int getType() {
      return LINE;
    }"
6004,"    public boolean render(InternalContextAdapter context, Writer writer, Node node)
        throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
      writer.append(""SELECT CURRENT_TIMESTAMP"");
      return true;
    }"
6005,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6006,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6007,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6008,"  public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
    AnnotationAttributes attributes = AnnotationAttributes
        .fromMap(metadata.getAnnotationAttributes(TestAutoConfigurationPackage.class.getName(), true));
    AutoConfigurationPackages.register(registry, ClassUtils.getPackageName(attributes.getString(""value"")));
  }"
6009,"  public Long getId() {
    return this.id;
  }"
6010,"  public void setId(Long id) {
    this.id = id;
  }"
6011,"  public String getName() {
    return this.name;
  }"
6012,"  public void setName(String name) {
    this.name = name;
  }"
6013,"  public Long getFirst() {
    return first;
  }"
6014,"  public void setFirst(Long first) {
    this.first = first;
  }"
6015,"  public String getLast() {
    return last;
  }"
6016,"  public void setLast(String last) {
    this.last = last;
  }"
6017,"  public void setParameter(PreparedStatement ps, int i, Number parameter, JdbcType jdbcType) throws SQLException {
  }

  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

  @Override
  public String toString() {
    return ""type="" + type;
  }

}"
6018,"  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
6019,"  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
6020,"  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
6021,"  public String toString() {
    return ""type="" + type;
  }"
6022,"  public void setParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException {
  }

  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

}"
6023,"  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
6024,"  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
6025,"  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
6026,"  City findById(@Param(""cityId"") Long cityId);

}"
6027,"  public City findById(long id) {
    return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
  }"
6028,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
6029,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
6030,"  public Long getId() {
    return this.id;
  }"
6031,"  public void setId(Long id) {
    this.id = id;
  }"
6032,"  public String getName() {
    return this.name;
  }"
6033,"  public void setName(String name) {
    this.name = name;
  }"
6034,"  public String getState() {
    return this.state;
  }"
6035,"  public void setState(String state) {
    this.state = state;
  }"
6036,"  public String getCountry() {
    return this.country;
  }"
6037,"  public void setCountry(String country) {
    this.country = country;
  }"
6038,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6039,"  City findByState(@Param(""state"") String state);

}"
6040,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6041,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6042,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6043,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6044,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6045,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6046,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6047,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6048,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6049,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6050,"    private void flush() {
      try {
        this.captureOut.flush();"
6051,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6052,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6053,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6054,"      PrintStream getOriginal() {
        return this.original;
      }"
6055,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6056,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6057,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6058,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6059,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6060,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6061,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6062,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
6063,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
6064,"  public Long getId() {
    return this.id;
  }"
6065,"  public void setId(Long id) {
    this.id = id;
  }"
6066,"  public String getName() {
    return this.name;
  }"
6067,"  public void setName(String name) {
    this.name = name;
  }"
6068,"  public String getState() {
    return this.state;
  }"
6069,"  public void setState(String state) {
    this.state = state;
  }"
6070,"  public String getCountry() {
    return this.country;
  }"
6071,"  public void setCountry(String country) {
    this.country = country;
  }"
6072,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6073,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6074,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6075,"  City findByName(@Param(""name"") String name);

}"
6076,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6077,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6078,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6079,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6080,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6081,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6082,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6083,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6084,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6085,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6086,"    private void flush() {
      try {
        this.captureOut.flush();"
6087,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6088,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6089,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6090,"      PrintStream getOriginal() {
        return this.original;
      }"
6091,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6092,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6093,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6094,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6095,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6096,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6097,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6098,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6099,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6100,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
6101,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
6102,"  public Long getId() {
    return this.id;
  }"
6103,"  public void setId(Long id) {
    this.id = id;
  }"
6104,"  public String getName() {
    return this.name;
  }"
6105,"  public void setName(String name) {
    this.name = name;
  }"
6106,"  public String getState() {
    return this.state;
  }"
6107,"  public void setState(String state) {
    this.state = state;
  }"
6108,"  public String getCountry() {
    return this.country;
  }"
6109,"  public void setCountry(String country) {
    this.country = country;
  }"
6110,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6111,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6112,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6113,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6114,"  City findByCountry(@Param(""country"") String country);

}"
6115,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6116,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6117,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6118,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6119,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6120,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6121,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6122,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6123,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6124,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6125,"    private void flush() {
      try {
        this.captureOut.flush();"
6126,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6127,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6128,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6129,"      PrintStream getOriginal() {
        return this.original;
      }"
6130,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6131,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6132,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6133,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6134,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6135,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6136,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6137,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6138,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6139,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
6140,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6141,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6142,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6143,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6144,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6145,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6146,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6147,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6148,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6149,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6150,"    private void flush() {
      try {
        this.captureOut.flush();"
6151,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6152,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6153,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6154,"      PrintStream getOriginal() {
        return this.original;
      }"
6155,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6156,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6157,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6158,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6159,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
6160,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
6161,"  public Long getId() {
    return this.id;
  }"
6162,"  public void setId(Long id) {
    this.id = id;
  }"
6163,"  public String getName() {
    return this.name;
  }"
6164,"  public void setName(String name) {
    this.name = name;
  }"
6165,"  public String getState() {
    return this.state;
  }"
6166,"  public void setState(String state) {
    this.state = state;
  }"
6167,"  public String getCountry() {
    return this.country;
  }"
6168,"  public void setCountry(String country) {
    this.country = country;
  }"
6169,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6170,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6171,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6172,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6173,"  City findByCountry(@Param(""country"") String country);

}"
6174,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6175,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6176,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6177,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6178,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6179,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6180,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6181,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6182,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6183,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6184,"    private void flush() {
      try {
        this.captureOut.flush();"
6185,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6186,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6187,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6188,"      PrintStream getOriginal() {
        return this.original;
      }"
6189,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6190,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6191,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6192,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6193,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6194,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6195,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6196,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6197,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6198,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
6199,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
6200,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
6201,"  public Long getId() {
    return this.id;
  }"
6202,"  public void setId(Long id) {
    this.id = id;
  }"
6203,"  public String getName() {
    return this.name;
  }"
6204,"  public void setName(String name) {
    this.name = name;
  }"
6205,"  public String getState() {
    return this.state;
  }"
6206,"  public void setState(String state) {
    this.state = state;
  }"
6207,"  public String getCountry() {
    return this.country;
  }"
6208,"  public void setCountry(String country) {
    this.country = country;
  }"
6209,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6210,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6211,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6212,"  City findByName(@Param(""name"") String name);

}"
6213,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6214,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6215,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6216,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6217,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6218,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6219,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6220,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6221,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6222,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6223,"    private void flush() {
      try {
        this.captureOut.flush();"
6224,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6225,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6226,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6227,"      PrintStream getOriginal() {
        return this.original;
      }"
6228,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6229,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6230,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6231,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6232,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6233,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6234,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6235,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6236,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6237,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
6238,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
6239,"  public Long getId() {
    return this.id;
  }"
6240,"  public void setId(Long id) {
    this.id = id;
  }"
6241,"  public String getName() {
    return this.name;
  }"
6242,"  public void setName(String name) {
    this.name = name;
  }"
6243,"  public String getState() {
    return this.state;
  }"
6244,"  public void setState(String state) {
    this.state = state;
  }"
6245,"  public String getCountry() {
    return this.country;
  }"
6246,"  public void setCountry(String country) {
    this.country = country;
  }"
6247,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6248,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6249,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6250,"  City findByName(@Param(""name"") String name);

}"
6251,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6252,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6253,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6254,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6255,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6256,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6257,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6258,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6259,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6260,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6261,"    private void flush() {
      try {
        this.captureOut.flush();"
6262,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6263,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6264,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6265,"      PrintStream getOriginal() {
        return this.original;
      }"
6266,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6267,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6268,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6269,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6270,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6271,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6272,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6273,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6274,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6275,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
6276,"  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebApplication.class);
  }"
6277,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
6278,"  public Long getId() {
    return this.id;
  }"
6279,"  public void setId(Long id) {
    this.id = id;
  }"
6280,"  public String getName() {
    return this.name;
  }"
6281,"  public void setName(String name) {
    this.name = name;
  }"
6282,"  public String getState() {
    return this.state;
  }"
6283,"  public void setState(String state) {
    this.state = state;
  }"
6284,"  public String getCountry() {
    return this.country;
  }"
6285,"  public void setCountry(String country) {
    this.country = country;
  }"
6286,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6287,"  City findByState(@Param(""state"") String state);

}"
6288,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6289,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6290,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6291,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
6292,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
6293,"  public Long getId() {
    return this.id;
  }"
6294,"  public void setId(Long id) {
    this.id = id;
  }"
6295,"  public String getName() {
    return this.name;
  }"
6296,"  public void setName(String name) {
    this.name = name;
  }"
6297,"  public String getState() {
    return this.state;
  }"
6298,"  public void setState(String state) {
    this.state = state;
  }"
6299,"  public String getCountry() {
    return this.country;
  }"
6300,"  public void setCountry(String country) {
    this.country = country;
  }"
6301,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6302,"  City findByState(@Param(""state"") String state);

}"
6303,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6304,"  void findByStateTest() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6305,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
6306,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
6307,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
6308,"  public Long getId() {
    return this.id;
  }"
6309,"  public void setId(Long id) {
    this.id = id;
  }"
6310,"  public String getName() {
    return this.name;
  }"
6311,"  public void setName(String name) {
    this.name = name;
  }"
6312,"  public String getState() {
    return this.state;
  }"
6313,"  public void setState(String state) {
    this.state = state;
  }"
6314,"  public String getCountry() {
    return this.country;
  }"
6315,"  public void setCountry(String country) {
    this.country = country;
  }"
6316,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6317,"  public Long getCity() {
    return city;
  }"
6318,"  public void setCity(Long city) {
    this.city = city;
  }"
6319,"  public String getName() {
    return name;
  }"
6320,"  public void setName(String name) {
    this.name = name;
  }"
6321,"  public String getAddress() {
    return address;
  }"
6322,"  public void setAddress(String address) {
    this.address = address;
  }"
6323,"  public String getZip() {
    return zip;
  }"
6324,"  public void setZip(String zip) {
    this.zip = zip;
  }"
6325,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
6326,"  City findByState(@Param(""state"") String state);

}"
6327,"  Hotel selectByCityId(int cityId);

}"
6328,"    public void beforeAll(ExtensionContext context) {
      getOutputCapture(context).captureOutput();
    }"
6329,"    public void afterAll(ExtensionContext context) {
      getOutputCapture(context).releaseOutput();
    }"
6330,"    public void afterEach(ExtensionContext context) {
      OutputCapture outputCapture = getOutputCapture(context);
      try {
        if (!outputCapture.matchers.isEmpty()) {"
6331,"    public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      boolean isTestMethodLevel = extensionContext.getTestMethod().isPresent();
      boolean isOutputCapture = parameterContext.getParameter().getType() == OutputCapture.class;
      return isTestMethodLevel && isOutputCapture;
    }"
6332,"    public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
      return getOutputCapture(extensionContext);
    }"
6333,"    private OutputCapture getOutputCapture(ExtensionContext context) {
      return getOrComputeIfAbsent(getStore(context), OutputCapture.class);
    }"
6334,"    private <V> V getOrComputeIfAbsent(Store store, Class<V> type) {
      return store.getOrComputeIfAbsent(type, ReflectionSupport::newInstance, type);
    }"
6335,"    private Store getStore(ExtensionContext context) {
      return context.getStore(Namespace.create(getClass()));
    }"
6336,"    void captureOutput() {
      this.copy = new ByteArrayOutputStream();
      this.captureOut = new CaptureOutputStream(System.out, this.copy);
      this.captureErr = new CaptureOutputStream(System.err, this.copy);
      System.setOut(new PrintStream(this.captureOut));
      System.setErr(new PrintStream(this.captureErr));
    }"
6337,"    void releaseOutput() {
      System.setOut(this.captureOut.getOriginal());
      System.setErr(this.captureErr.getOriginal());
      this.copy = null;
    }"
6338,"    private void flush() {
      try {
        this.captureOut.flush();"
6339,"    public void expect(Matcher<? super String> matcher) {
      this.matchers.add(matcher);
    }"
6340,"    public String toString() {
      flush();
      return this.copy.toString();
    }"
6341,"    void reset() {
      this.matchers.clear();
      this.copy.reset();
    }"
6342,"      PrintStream getOriginal() {
        return this.original;
      }"
6343,"      public void write(int b) throws IOException {
        this.copy.write(b);
        this.original.write(b);
        this.original.flush();
      }"
6344,"      public void write(byte[] b) throws IOException {
        write(b, 0, b.length);
      }"
6345,"      public void write(byte[] b, int off, int len) throws IOException {
        this.copy.write(b, off, len);
        this.original.write(b, off, len);
      }"
6346,"      public void flush() throws IOException {
        this.copy.flush();
        this.original.flush();
      }"
6347,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6348,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
6349,"  void selectCityByIdTest() {
    City city = cityDao.selectCityById(1);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6350,"  void selectByCityIdTest() {
    Hotel hotel = hotelMapper.selectByCityId(1);
    assertThat(hotel.getCity()).isEqualTo(1);
    assertThat(hotel.getName()).isEqualTo(""Conrad Treasury Place"");
    assertThat(hotel.getAddress()).isEqualTo(""William & George Streets"");
    assertThat(hotel.getZip()).isEqualTo(""4001"");
  }"
6351,"  protected String[] getProperties(Class<?> testClass) {
    MybatisTest annotation = AnnotatedElementUtils.getMergedAnnotation(testClass, MybatisTest.class);
    return (annotation != null) ? annotation.properties() : null;
  }"
6352,"  protected boolean hasAnnotation() {
    return this.annotation != null;
  }"
6353,"  protected ComponentScan.Filter[] getFilters(FilterType type) {
    switch (type) {
      case INCLUDE:"
6354,"  protected boolean isUseDefaultFilters() {
    return this.annotation.useDefaultFilters();
  }"
6355,"  protected Set<Class<?>> getDefaultIncludes() {
    return Collections.emptySet();
  }"
6356,"  protected Set<Class<?>> getComponentIncludes() {
    return Collections.emptySet();
  }"
6357,"  public String getMessage() {
    return ""Hello!"";
  }"
6358,"  public String getMessage() {
    return ""Goodbye!"";
  }"
6359,"  void testIncludeFilter() {
    assertThat(component.getMessage()).isEqualTo(""Hello!"");
  }"
6360,"  void testExcludeFilter() {
    assertThat(service).isNull();
  }"
6361,"  void testSqlSession() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample findSample = sqlSession.selectOne(""findSample"", 1L);
    assertThat(findSample.getId()).isNotNull().isEqualTo(1L);
    assertThat(findSample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
6362,"  void testMapper() {
    Map<String, Object> parameters = new HashMap<>();
    parameters.put(""id"", 1);
    parameters.put(""name"", ""wonwoo"");
    sqlSession.insert(""saveSample"", parameters);
    Sample sample = sampleMapper.findByName(""wonwoo"");
    assertThat(sample.getId()).isNotNull().isEqualTo(1L);
    assertThat(sample.getName()).isNotNull().isEqualTo(""wonwoo"");
  }"
6363,"  void testAutoConfigureComponents() {
    // @AutoConfigureMybatis
    this.applicationContext.getBean(JdbcTemplate.class);
    this.applicationContext.getBean(NamedParameterJdbcTemplate.class);
    this.applicationContext.getBean(DataSourceTransactionManager.class);
    this.applicationContext.getBean(TransactionInterceptor.class);
    // @AutoConfigureCache
    this.applicationContext.getBean(CacheManager.class);
    this.applicationContext.getBean(CacheInterceptor.class);
  }"
6364,"  void didNotInjectExampleComponent() {
    Assertions.assertThrows(NoSuchBeanDefinitionException.class,
        () -> this.applicationContext.getBean(ExampleComponent.class));"
6365,"  public Long getId() {
    return id;
  }"
6366,"  public void setId(Long id) {
    this.id = id;
  }"
6367,"  public String getName() {
    return name;
  }"
6368,"  public void setName(String name) {
    this.name = name;
  }"
6369,"  Sample findByName(String name);

}"
6370,"  LocalDateTime now();

}"
6371,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6372,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6373,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6374,"  public Long getId() {
    return this.id;
  }"
6375,"  public void setId(Long id) {
    this.id = id;
  }"
6376,"  public String getName() {
    return this.name;
  }"
6377,"  public void setName(String name) {
    this.name = name;
  }"
6378,"  public Long getFirst() {
    return first;
  }"
6379,"  public void setFirst(Long first) {
    this.first = first;
  }"
6380,"  public String getLast() {
    return last;
  }"
6381,"  public void setLast(String last) {
    this.last = last;
  }"
6382,"  public void setParameter(PreparedStatement ps, int i, Number parameter, JdbcType jdbcType) throws SQLException {
  }

  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

  @Override
  public String toString() {
    return ""type="" + type;
  }

}"
6383,"  public Number getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
6384,"  public Number getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
6385,"  public Number getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
6386,"  public String toString() {
    return ""type="" + type;
  }"
6387,"  public void setParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException {
  }

  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }

  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }

  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }

}"
6388,"  public Object getResult(ResultSet rs, String columnName) throws SQLException {
    return null;
  }"
6389,"  public Object getResult(CallableStatement cs, int columnIndex) throws SQLException {
    return null;
  }"
6390,"  public Object getResult(ResultSet rs, int columnIndex) throws SQLException {
    return null;
  }"
6391,"  City findById(@Param(""cityId"") Long cityId);

}"
6392,"  public City findById(long id) {
    return this.sqlSessionTemplate.selectOne(""selectCityById"", id);
  }"
6393,"  public static void main(String[] args) {
    SpringApplication.run(SampleAnnotationApplication.class, args);
  }"
6394,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
6395,"  public Long getId() {
    return this.id;
  }"
6396,"  public void setId(Long id) {
    this.id = id;
  }"
6397,"  public String getName() {
    return this.name;
  }"
6398,"  public void setName(String name) {
    this.name = name;
  }"
6399,"  public String getState() {
    return this.state;
  }"
6400,"  public void setState(String state) {
    this.state = state;
  }"
6401,"  public String getCountry() {
    return this.country;
  }"
6402,"  public void setCountry(String country) {
    this.country = country;
  }"
6403,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6404,"  City findByState(@Param(""state"") String state);

}"
6405,"  void test(OutputCapture outputCapture) {
    SampleAnnotationApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6406,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6407,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
6408,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
  }"
6409,"  public Long getId() {
    return this.id;
  }"
6410,"  public void setId(Long id) {
    this.id = id;
  }"
6411,"  public String getName() {
    return this.name;
  }"
6412,"  public void setName(String name) {
    this.name = name;
  }"
6413,"  public String getState() {
    return this.state;
  }"
6414,"  public void setState(String state) {
    this.state = state;
  }"
6415,"  public String getCountry() {
    return this.country;
  }"
6416,"  public void setCountry(String country) {
    this.country = country;
  }"
6417,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6418,"  City findById(@Param(""id"") Long id);

  @Select(""/mappers/CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6419,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6420,"  City findByName(@Param(""name"") String name);

}"
6421,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6422,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6423,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6424,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6425,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6426,"  public static void main(String[] args) {
    SpringApplication.run(SampleFreeMarkerApplication.class, args);
  }"
6427,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
6428,"  public Long getId() {
    return this.id;
  }"
6429,"  public void setId(Long id) {
    this.id = id;
  }"
6430,"  public String getName() {
    return this.name;
  }"
6431,"  public void setName(String name) {
    this.name = name;
  }"
6432,"  public String getState() {
    return this.state;
  }"
6433,"  public void setState(String state) {
    this.state = state;
  }"
6434,"  public String getCountry() {
    return this.country;
  }"
6435,"  public void setCountry(String country) {
    this.country = country;
  }"
6436,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6437,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.ftl"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6438,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6439,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6440,"  City findByCountry(@Param(""country"") String country);

}"
6441,"  void test(OutputCapture outputCapture) {
    SampleFreeMarkerApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6442,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6443,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6444,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6445,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6446,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
6447,"  public static void main(String[] args) {
    SpringApplication.run(SampleThymeleafApplication.class, args);
  }"
6448,"  public void run(String... args) {
    System.out.println(this.cityMapper.findByState(""CA""));
    System.out.println(this.cityMapper.findByCountry(""JP""));
  }"
6449,"  public Long getId() {
    return this.id;
  }"
6450,"  public void setId(Long id) {
    this.id = id;
  }"
6451,"  public String getName() {
    return this.name;
  }"
6452,"  public void setName(String name) {
    this.name = name;
  }"
6453,"  public String getState() {
    return this.state;
  }"
6454,"  public void setState(String state) {
    this.state = state;
  }"
6455,"  public String getCountry() {
    return this.country;
  }"
6456,"  public void setCountry(String country) {
    this.country = country;
  }"
6457,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6458,"  City findById(@Param(""id"") Long id);

  @Select(""CityMapper-findByState.sql"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6459,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6460,"  City findByName(@Param(""name"") String name);

  @SelectProvider(TemplateFilePathProvider.class)
  City findByCountry(@Param(""country"") String country);

}"
6461,"  City findByCountry(@Param(""country"") String country);

}"
6462,"  void test(OutputCapture outputCapture) {
    SampleThymeleafApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6463,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""2,Tokyo,13,JP"");
  }"
6464,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6465,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6466,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6467,"  void findByCountry() {
    City city = cityMapper.findByCountry(""JP"");
    assertThat(city.getId()).isEqualTo(2);
    assertThat(city.getName()).isEqualTo(""Tokyo"");
    assertThat(city.getState()).isEqualTo(""13"");
    assertThat(city.getCountry()).isEqualTo(""JP"");
  }"
6468,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
6469,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
6470,"  public Long getId() {
    return this.id;
  }"
6471,"  public void setId(Long id) {
    this.id = id;
  }"
6472,"  public String getName() {
    return this.name;
  }"
6473,"  public void setName(String name) {
    this.name = name;
  }"
6474,"  public String getState() {
    return this.state;
  }"
6475,"  public void setState(String state) {
    this.state = state;
  }"
6476,"  public String getCountry() {
    return this.country;
  }"
6477,"  public void setCountry(String country) {
    this.country = country;
  }"
6478,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6479,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6480,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6481,"  City findByName(@Param(""name"") String name);

}"
6482,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6483,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6484,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6485,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6486,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6487,"  public static void main(String[] args) {
    SpringApplication.run(SampleVelocityApplication.class, args);
  }"
6488,"  public void run(String... args) {
    System.out.println(this.cityMapper.findById(1L));
  }"
6489,"  public Long getId() {
    return this.id;
  }"
6490,"  public void setId(Long id) {
    this.id = id;
  }"
6491,"  public String getName() {
    return this.name;
  }"
6492,"  public void setName(String name) {
    this.name = name;
  }"
6493,"  public String getState() {
    return this.state;
  }"
6494,"  public void setState(String state) {
    this.state = state;
  }"
6495,"  public String getCountry() {
    return this.country;
  }"
6496,"  public void setCountry(String country) {
    this.country = country;
  }"
6497,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6498,"  City findById(@Param(""id"") Long id);

  // TODO Does not support template file yet
  // @Select(""/mappers/CityMapper-findByState.vm"")
  // @Select(""#parse('/mappers/CityMapper-findByState.vm')"")
  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6499,"  City findByState(@Param(""state"") String state);

  City findByName(@Param(""name"") String name);

}"
6500,"  City findByName(@Param(""name"") String name);

}"
6501,"  void test(OutputCapture outputCapture) {
    SampleVelocityApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6502,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6503,"  void findByState() {
    City city = cityMapper.findByState(""CA"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6504,"  void findById() {
    City city = cityMapper.findById(1L);
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6505,"  void findByName() {
    City city = cityMapper.findByName(""San Francisco"");
    assertThat(city.getId()).isEqualTo(1);
    assertThat(city.getName()).isEqualTo(""San Francisco"");
    assertThat(city.getState()).isEqualTo(""CA"");
    assertThat(city.getCountry()).isEqualTo(""US"");
  }"
6506,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
6507,"  protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
    return application.sources(SampleWebApplication.class);
  }"
6508,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
6509,"  public Long getId() {
    return this.id;
  }"
6510,"  public void setId(Long id) {
    this.id = id;
  }"
6511,"  public String getName() {
    return this.name;
  }"
6512,"  public void setName(String name) {
    this.name = name;
  }"
6513,"  public String getState() {
    return this.state;
  }"
6514,"  public void setState(String state) {
    this.state = state;
  }"
6515,"  public String getCountry() {
    return this.country;
  }"
6516,"  public void setCountry(String country) {
    this.country = country;
  }"
6517,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6518,"  City findByState(@Param(""state"") String state);

}"
6519,"  void test() {
    RestTemplate restTemplate = new RestTemplate();
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = restTemplate
        .getForObject(""http://localhost:18080/mybatis-spring-boot-sample-war/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6520,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6521,"  public static void main(String[] args) {
    SpringApplication.run(SampleWebApplication.class, args);
  }"
6522,"  City getCity(@PathVariable String state) {
    return cityMapper.findByState(state);
  }"
6523,"  public Long getId() {
    return this.id;
  }"
6524,"  public void setId(Long id) {
    this.id = id;
  }"
6525,"  public String getName() {
    return this.name;
  }"
6526,"  public void setName(String name) {
    this.name = name;
  }"
6527,"  public String getState() {
    return this.state;
  }"
6528,"  public void setState(String state) {
    this.state = state;
  }"
6529,"  public String getCountry() {
    return this.country;
  }"
6530,"  public void setCountry(String country) {
    this.country = country;
  }"
6531,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6532,"  City findByState(@Param(""state"") String state);

}"
6533,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""CA"");
    assertThat(body).hasSize(4).containsEntry(""id"", 1).containsEntry(""name"", ""San Francisco"")
        .containsEntry(""state"", ""CA"").containsEntry(""country"", ""US"");"
6534,"  public static void main(String[] args) {
    SpringApplication.run(SampleXmlApplication.class, args);
  }"
6535,"  public void run(String... args) {
    System.out.println(this.cityDao.selectCityById(1));
    System.out.println(this.hotelMapper.selectByCityId(1));
  }"
6536,"  public City selectCityById(long id) {
    return this.sqlSession.selectOne(""selectCityById"", id);
  }"
6537,"  public Long getId() {
    return this.id;
  }"
6538,"  public void setId(Long id) {
    this.id = id;
  }"
6539,"  public String getName() {
    return this.name;
  }"
6540,"  public void setName(String name) {
    this.name = name;
  }"
6541,"  public String getState() {
    return this.state;
  }"
6542,"  public void setState(String state) {
    this.state = state;
  }"
6543,"  public String getCountry() {
    return this.country;
  }"
6544,"  public void setCountry(String country) {
    this.country = country;
  }"
6545,"  public String toString() {
    return getId() + "","" + getName() + "","" + getState() + "","" + getCountry();
  }"
6546,"  public Long getCity() {
    return city;
  }"
6547,"  public void setCity(Long city) {
    this.city = city;
  }"
6548,"  public String getName() {
    return name;
  }"
6549,"  public void setName(String name) {
    this.name = name;
  }"
6550,"  public String getAddress() {
    return address;
  }"
6551,"  public void setAddress(String address) {
    this.address = address;
  }"
6552,"  public String getZip() {
    return zip;
  }"
6553,"  public void setZip(String zip) {
    this.zip = zip;
  }"
6554,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
6555,"  City findByState(@Param(""state"") String state);

}"
6556,"  Hotel selectByCityId(int cityId);

}"
6557,"  void test(OutputCapture outputCapture) {
    SampleXmlApplication.main(new String[] {});
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
  }"
6558,"  void test(OutputCapture outputCapture) {
    String output = outputCapture.toString();
    assertThat(output).contains(""1,San Francisco,CA,US"");
    assertThat(output).contains(""1,Conrad Treasury Place,William & George Streets,4001"");
  }"
6559,"  public boolean isValid() {
    return true;
  }"
6560,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = URLDecoder.decode(url.toString(), urlDecodingCharset.name());
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
6561,"  public static void setUrlDecodingCharset(Charset charset) {
    urlDecodingCharset = charset;
  }"
6562,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"") + Normalizer"
6563,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
6564,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6565,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6566,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
6567,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6568,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6569,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6570,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6571,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6572,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6573,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6574,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
6575,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
6576,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
6577,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6578,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6579,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6580,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6581,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6582,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6583,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6584,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
6585,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
6586,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6587,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6588,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6589,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6590,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
6591,"  void testWithMyBatisConfigurationCustomizeByJavaConfig() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisPropertiesConfigurationCustomizer.class)"
6592,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
6593,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
6594,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
6595,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6596,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6597,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6598,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6599,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6600,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6601,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
6602,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6603,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
6604,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
6605,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6606,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6607,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6608,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6609,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6610,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6611,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6612,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6613,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
6614,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6615,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6616,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
6617,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6618,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6619,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6620,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6621,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6622,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
6623,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
6624,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
6625,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
6626,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6627,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6628,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6629,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6630,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
6631,"    void customize(MybatisProperties properties) {
      properties.getConfiguration().getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
6632,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
6633,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
6634,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
6635,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
6636,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
6637,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
6638,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6639,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6640,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
6641,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6642,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6643,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
6644,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
6645,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
6646,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
6647,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
6648,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
6649,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6650,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
6651,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
6652,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
6653,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
6654,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
6655,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
6656,"  City getCity(@PathVariable(""state"") String state) {
    return cityMapper.findByState(state);
  }"
6657,"  City getCity(@PathVariable(""state"") String state) {
    return cityMapper.findByState(state);
  }"
6658,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
6659,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
6660,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    if (properties.getConfiguration() == null || properties.getConfiguration().getVfsImpl() == null) {
      factory.setVfs(SpringBootVFS.class);
    }
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    Resource[] mapperLocations = this.properties.resolveMapperLocations();
    if (!ObjectUtils.isEmpty(mapperLocations)) {
      factory.setMapperLocations(mapperLocations);
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }
    applySqlSessionFactoryBeanCustomizers(factory);
    return factory.getObject();
  }"
6661,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    MybatisProperties.CoreConfiguration coreConfiguration = this.properties.getConfiguration();
    Configuration configuration = null;
    if (coreConfiguration != null || !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && coreConfiguration != null) {
      coreConfiguration.applyTo(configuration);
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
6662,"  private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
      for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {"
6663,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
6664,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
6665,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
6666,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
6667,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
6668,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
6669,"  void testProperties() throws IOException {

    DocumentContext documentContext = JsonPath
        .parse(new FileSystemResource(""src/main/resources/META-INF/additional-spring-configuration-metadata.json"")
            .getInputStream());

    List<Map<String, Object>> properties = documentContext.read(""$.properties"");

    assertAll(() -> assertThat(properties.size()).isEqualTo(4), () -> {
      // assert for mybatis.lazy-initialization"
6670,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
6671,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6672,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6673,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
6674,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6675,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6676,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6677,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6678,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6679,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6680,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6681,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
6682,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
6683,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
6684,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6685,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6686,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6687,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6688,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6689,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6690,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6691,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
6692,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
6693,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6694,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6695,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6696,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6697,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
6698,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
6699,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
6700,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
6701,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6702,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6703,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6704,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6705,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6706,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6707,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
6708,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6709,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
6710,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
6711,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6712,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6713,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6714,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6715,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6716,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6717,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6718,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6719,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
6720,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6721,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6722,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
6723,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6724,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6725,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6726,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6727,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6728,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
6729,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
6730,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
6731,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
6732,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6733,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6734,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6735,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6736,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
6737,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
6738,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
6739,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
6740,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
6741,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
6742,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
6743,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6744,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6745,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
6746,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6747,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6748,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
6749,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
6750,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
6751,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
6752,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
6753,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
6754,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6755,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
6756,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
6757,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
6758,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
6759,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
6760,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
6761,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6762,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6763,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6764,"  void testWithDefaultCoreConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run(context -> {
      assertThat(context.getBean(SqlSessionFactory.class).getConfiguration().isSafeRowBoundsEnabled()).isFalse();"
6765,"  void testWithCustomizeCoreConfiguration() {
    assertAll(
        () -> this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)"
6766,"  void checkProperties() {
    Set<String> mybatisCoreConfigurationProperties = Arrays
        .stream(PropertyAccessorFactory.forBeanPropertyAccess(new Configuration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    Set<String> mybatisSpringBootConfigurationProperties = Arrays.stream(PropertyAccessorFactory
        .forBeanPropertyAccess(new MybatisProperties.CoreConfiguration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    mybatisCoreConfigurationProperties.removeAll(mybatisSpringBootConfigurationProperties);
    mybatisCoreConfigurationProperties.removeAll(Arrays.asList(""reflectorFactory"", ""defaultScriptingLanguage"",
        ""sqlFragments"", ""typeHandlerRegistry"", ""mapperRegistry"", ""interceptors"", ""cacheNames"", ""incompleteResultMaps"",
        ""typeAliasRegistry"", ""incompleteMethods"", ""proxyFactory"", ""resultMaps"", ""defaultScriptingLanguageInstance"",
        ""parameterMaps"", ""keyGenerators"", ""parameterMapNames"", ""caches"", ""mappedStatementNames"", ""objectWrapperFactory"",
        ""objectFactory"", ""databaseId"", ""incompleteStatements"", ""resultMapNames"", ""defaultScriptingLanuageInstance"",
        ""keyGeneratorNames"", ""environment"", ""mappedStatements"", ""languageRegistry"", ""incompleteCacheRefs""));
    assertThat(mybatisCoreConfigurationProperties).isEmpty();
  }"
6767,"  public void afterPropertiesSet() {
    checkConfigFileExists();
  }"
6768,"  private void checkConfigFileExists() {
    if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {
      Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());"
6769,"  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    if (properties.getConfiguration() == null || properties.getConfiguration().getVfsImpl() == null) {
      factory.setVfs(SpringBootVFS.class);
    }
    if (StringUtils.hasText(this.properties.getConfigLocation())) {
      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));
    }
    applyConfiguration(factory);
    if (this.properties.getConfigurationProperties() != null) {
      factory.setConfigurationProperties(this.properties.getConfigurationProperties());
    }
    if (!ObjectUtils.isEmpty(this.interceptors)) {
      factory.setPlugins(this.interceptors);
    }
    if (this.databaseIdProvider != null) {
      factory.setDatabaseIdProvider(this.databaseIdProvider);
    }
    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) {
      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());
    }
    if (this.properties.getTypeAliasesSuperType() != null) {
      factory.setTypeAliasesSuperType(this.properties.getTypeAliasesSuperType());
    }
    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) {
      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());
    }
    if (!ObjectUtils.isEmpty(this.typeHandlers)) {
      factory.setTypeHandlers(this.typeHandlers);
    }
    Resource[] mapperLocations = this.properties.resolveMapperLocations();
    if (!ObjectUtils.isEmpty(mapperLocations)) {
      factory.setMapperLocations(mapperLocations);
    }
    Set<String> factoryPropertyNames = Stream
        .of(new BeanWrapperImpl(SqlSessionFactoryBean.class).getPropertyDescriptors()).map(PropertyDescriptor::getName)
        .collect(Collectors.toSet());
    Class<? extends LanguageDriver> defaultLanguageDriver = this.properties.getDefaultScriptingLanguageDriver();
    if (factoryPropertyNames.contains(""scriptingLanguageDrivers"") && !ObjectUtils.isEmpty(this.languageDrivers)) {
      // Need to mybatis-spring 2.0.2+
      factory.setScriptingLanguageDrivers(this.languageDrivers);
      if (defaultLanguageDriver == null && this.languageDrivers.length == 1) {
        defaultLanguageDriver = this.languageDrivers[0].getClass();
      }
    }
    if (factoryPropertyNames.contains(""defaultScriptingLanguageDriver"")) {
      // Need to mybatis-spring 2.0.2+
      factory.setDefaultScriptingLanguageDriver(defaultLanguageDriver);
    }
    applySqlSessionFactoryBeanCustomizers(factory);
    return factory.getObject();
  }"
6770,"  private void applyConfiguration(SqlSessionFactoryBean factory) {
    MybatisProperties.CoreConfiguration coreConfiguration = this.properties.getConfiguration();
    Configuration configuration = null;
    if (coreConfiguration != null || !StringUtils.hasText(this.properties.getConfigLocation())) {
      configuration = new Configuration();
    }
    if (configuration != null && coreConfiguration != null) {
      coreConfiguration.applyTo(configuration);
    }
    if (configuration != null && !CollectionUtils.isEmpty(this.configurationCustomizers)) {
      for (ConfigurationCustomizer customizer : this.configurationCustomizers) {
        customizer.customize(configuration);
      }
    }
    factory.setConfiguration(configuration);
  }"
6771,"  private void applySqlSessionFactoryBeanCustomizers(SqlSessionFactoryBean factory) {
    if (!CollectionUtils.isEmpty(this.sqlSessionFactoryBeanCustomizers)) {
      for (SqlSessionFactoryBeanCustomizer customizer : this.sqlSessionFactoryBeanCustomizers) {"
6772,"  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);"
6773,"    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

      if (!AutoConfigurationPackages.has(this.beanFactory)) {
        logger.debug(""Could not determine auto-configuration package, automatic mapper scanning disabled."");
        return;
      }

      logger.debug(""Searching for mappers annotated with @Mapper"");

      List<String> packages = AutoConfigurationPackages.get(this.beanFactory);
      if (logger.isDebugEnabled()) {
        packages.forEach(pkg -> logger.debug(""Using auto-configuration base package '{}'"", pkg));
      }

      BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(MapperScannerConfigurer.class);
      builder.addPropertyValue(""processPropertyPlaceHolders"", true);
      builder.addPropertyValue(""annotationClass"", Mapper.class);
      builder.addPropertyValue(""basePackage"", StringUtils.collectionToCommaDelimitedString(packages));
      BeanWrapper beanWrapper = new BeanWrapperImpl(MapperScannerConfigurer.class);
      Set<String> propertyNames = Stream.of(beanWrapper.getPropertyDescriptors()).map(PropertyDescriptor::getName)
          .collect(Collectors.toSet());
      if (propertyNames.contains(""lazyInitialization"")) {
        // Need to mybatis-spring 2.0.2+
        builder.addPropertyValue(""lazyInitialization"", ""${mybatis.lazy-initialization:false}"");
      }
      if (propertyNames.contains(""defaultScope"")) {
        // Need to mybatis-spring 2.0.6+
        builder.addPropertyValue(""defaultScope"", ""${mybatis.mapper-default-scope:}"");
      }

      // for spring-native
      boolean injectSqlSession = environment.getProperty(""mybatis.inject-sql-session-on-mapper-scan"", Boolean.class,
          Boolean.TRUE);
      if (injectSqlSession && this.beanFactory instanceof ListableBeanFactory) {
        ListableBeanFactory listableBeanFactory = (ListableBeanFactory) this.beanFactory;
        Optional<String> sqlSessionTemplateBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionTemplate.class, listableBeanFactory));
        Optional<String> sqlSessionFactoryBeanName = Optional
            .ofNullable(getBeanNameForType(SqlSessionFactory.class, listableBeanFactory));
        if (sqlSessionTemplateBeanName.isPresent() || !sqlSessionFactoryBeanName.isPresent()) {
          builder.addPropertyValue(""sqlSessionTemplateBeanName"",
              sqlSessionTemplateBeanName.orElse(""sqlSessionTemplate""));
        } else {
          builder.addPropertyValue(""sqlSessionFactoryBeanName"", sqlSessionFactoryBeanName.get());
        }
      }
      builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

      registry.registerBeanDefinition(MapperScannerConfigurer.class.getName(), builder.getBeanDefinition());
    }"
6774,"    public void setBeanFactory(BeanFactory beanFactory) {
      this.beanFactory = beanFactory;
    }"
6775,"    public void setEnvironment(Environment environment) {
      this.environment = environment;
    }"
6776,"    private String getBeanNameForType(Class<?> type, ListableBeanFactory factory) {
      String[] beanNames = factory.getBeanNamesForType(type);
      return beanNames.length > 0 ? beanNames[0] : null;
    }"
6777,"    public void afterPropertiesSet() {
      logger.debug(
          ""Not found configuration for registering mapper bean using @MapperScan, MapperFactoryBean and MapperScannerConfigurer."");"
6778,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver() {
      return new FreeMarkerLanguageDriver();
    }"
6779,"    FreeMarkerLanguageDriver freeMarkerLanguageDriver(FreeMarkerLanguageDriverConfig config) {
      return new FreeMarkerLanguageDriver(config);
    }"
6780,"    public FreeMarkerLanguageDriverConfig freeMarkerLanguageDriverConfig() {
      return FreeMarkerLanguageDriverConfig.newInstance();
    }"
6781,"    org.mybatis.scripting.velocity.Driver velocityLanguageDriver() {
      return new org.mybatis.scripting.velocity.Driver();
    }"
6782,"    VelocityLanguageDriver velocityLanguageDriver(VelocityLanguageDriverConfig config) {
      return new VelocityLanguageDriver(config);
    }"
6783,"    public VelocityLanguageDriverConfig velocityLanguageDriverConfig() {
      return VelocityLanguageDriverConfig.newInstance();
    }"
6784,"    ThymeleafLanguageDriver thymeleafLanguageDriver(ThymeleafLanguageDriverConfig config) {
      return new ThymeleafLanguageDriver(config);
    }"
6785,"    public ThymeleafLanguageDriverConfig thymeleafLanguageDriverConfig() {
      return ThymeleafLanguageDriverConfig.newInstance();
    }"
6786,"      public DialectConfig getDialect() {
        return super.getDialect();
      }"
6787,"      public TemplateFileConfig getTemplateFile() {
        return super.getTemplateFile();
      }"
6788,"  public boolean isValid() {
    return true;
  }"
6789,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = URLDecoder.decode(url.toString(), urlDecodingCharset.name());
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
6790,"  public static void setUrlDecodingCharset(Charset charset) {
    urlDecodingCharset = charset;
  }"
6791,"  public static void setClassLoaderSupplier(Supplier<ClassLoader> supplier) {
    classLoaderSupplier = supplier;
  }"
6792,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"") + Normalizer"
6793,"  City findByState(@Param(""state"") String state);

}"
6794,"  City findByState(@Param(""state"") String state);

}"
6795,"  public boolean isValid() {
    return true;
  }"
6796,"  protected List<String> list(URL url, String path) throws IOException {
    String urlString = URLDecoder.decode(url.toString(), urlDecodingCharset);
    String baseUrlString = urlString.endsWith(""/"") ? urlString : urlString.concat(""/"");
    Resource[] resources = resourceResolver.getResources(baseUrlString + ""**/*.class"");
    return Stream.of(resources).map(resource -> preserveSubpackageName(baseUrlString, resource, path))
        .collect(Collectors.toList());"
6797,"  public static void setUrlDecodingCharset(Charset charset) {
    urlDecodingCharset = charset;
  }"
6798,"  public static void setClassLoaderSupplier(Supplier<ClassLoader> supplier) {
    classLoaderSupplier = supplier;
  }"
6799,"  private static String preserveSubpackageName(final String baseUrlString, final Resource resource,
      final String rootPath) {
    try {
      return rootPath + (rootPath.endsWith(""/"") ? """" : ""/"")"
6800,"    public static void main( String[] args )
    {
        log( ""Apache Maven Wrapper Downloader "" + WRAPPER_VERSION );

        if ( args.length != 2 )
        {
            System.err.println( "" - ERROR wrapperUrl or wrapperJarPath parameter missing"" );
            System.exit( 1 );
        }

        try
        {"
6801,"    private static void downloadFileFromURL( URL wrapperUrl, Path wrapperJarPath )
        throws IOException
    {
        log( "" - Downloading to: "" + wrapperJarPath );
        if ( System.getenv( ""MVNW_USERNAME"" ) != null && System.getenv( ""MVNW_PASSWORD"" ) != null )
        {
            final String username = System.getenv( ""MVNW_USERNAME"" );
            final char[] password = System.getenv( ""MVNW_PASSWORD"" ).toCharArray();
            Authenticator.setDefault( new Authenticator()
            {
                @Override
                protected PasswordAuthentication getPasswordAuthentication()
                {
                    return new PasswordAuthentication( username, password );
                }
            } );
        }
        try ( InputStream inStream = wrapperUrl.openStream() )
        {
            Files.copy( inStream, wrapperJarPath, StandardCopyOption.REPLACE_EXISTING );
        }
        log( "" - Downloader complete"" );
    }"
6802,"                protected PasswordAuthentication getPasswordAuthentication()
                {
                    return new PasswordAuthentication( username, password );
                }"
6803,"    private static void log( String msg )
    {
        if ( VERBOSE )
        {"
6804,"  public Long getCity() {
    return city;
  }"
6805,"  public void setCity(Long city) {
    this.city = city;
  }"
6806,"  public String getName() {
    return name;
  }"
6807,"  public void setName(String name) {
    this.name = name;
  }"
6808,"  public String getAddress() {
    return address;
  }"
6809,"  public void setAddress(String address) {
    this.address = address;
  }"
6810,"  public String getZip() {
    return zip;
  }"
6811,"  public void setZip(String zip) {
    this.zip = zip;
  }"
6812,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
6813,"  public Long getCity() {
    return city;
  }"
6814,"  public void setCity(Long city) {
    this.city = city;
  }"
6815,"  public String getName() {
    return name;
  }"
6816,"  public void setName(String name) {
    this.name = name;
  }"
6817,"  public String getAddress() {
    return address;
  }"
6818,"  public void setAddress(String address) {
    this.address = address;
  }"
6819,"  public String getZip() {
    return zip;
  }"
6820,"  public void setZip(String zip) {
    this.zip = zip;
  }"
6821,"  public String toString() {
    return getCity() + "","" + getName() + "","" + getAddress() + "","" + getZip();
  }"
6822,"  void setup() {
    City city = new City();
    city.setId(10L);
    city.setCountry(""US"");
    city.setState(""NV"");
    city.setName(""Las Vegas"");
    Mockito.when(cityMapper.findByState(""NV"")).thenReturn(city);
  }"
6823,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""NV"");
    assertThat(body).hasSize(4).containsEntry(""id"", 10).containsEntry(""name"", ""Las Vegas"").containsEntry(""state"", ""NV"")
        .containsEntry(""country"", ""US"");"
6824,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6825,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6826,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6827,"  void testWithDefaultCoreConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run(context -> {
      assertThat(context.getBean(SqlSessionFactory.class).getConfiguration().isSafeRowBoundsEnabled()).isFalse();"
6828,"  void testWithCustomizeCoreConfiguration() {
    assertAll(
        () -> this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)"
6829,"  void checkProperties() {
    Set<String> mybatisCoreConfigurationProperties = Arrays
        .stream(PropertyAccessorFactory.forBeanPropertyAccess(new Configuration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    Set<String> mybatisSpringBootConfigurationProperties = Arrays.stream(PropertyAccessorFactory
        .forBeanPropertyAccess(new MybatisProperties.CoreConfiguration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    mybatisCoreConfigurationProperties.removeAll(mybatisSpringBootConfigurationProperties);
    mybatisCoreConfigurationProperties.removeAll(Arrays.asList(""reflectorFactory"", ""defaultScriptingLanguage"",
        ""sqlFragments"", ""typeHandlerRegistry"", ""mapperRegistry"", ""interceptors"", ""cacheNames"", ""incompleteResultMaps"",
        ""typeAliasRegistry"", ""incompleteMethods"", ""proxyFactory"", ""resultMaps"", ""defaultScriptingLanguageInstance"",
        ""parameterMaps"", ""keyGenerators"", ""parameterMapNames"", ""caches"", ""mappedStatementNames"", ""objectWrapperFactory"",
        ""objectFactory"", ""incompleteStatements"", ""resultMapNames"", ""defaultScriptingLanuageInstance"",
        ""keyGeneratorNames"", ""environment"", ""mappedStatements"", ""languageRegistry"", ""incompleteCacheRefs""));
    assertThat(mybatisCoreConfigurationProperties).isEmpty();
  }"
6830,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6831,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6832,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6833,"  void testWithDefaultCoreConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run(context -> {
      assertThat(context.getBean(SqlSessionFactory.class).getConfiguration().isSafeRowBoundsEnabled()).isFalse();"
6834,"  void testWithCustomizeCoreConfiguration() {
    assertAll(
        () -> this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)"
6835,"  void checkProperties() {
    Set<String> mybatisCoreConfigurationProperties = Arrays
        .stream(PropertyAccessorFactory.forBeanPropertyAccess(new Configuration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    Set<String> mybatisSpringBootConfigurationProperties = Arrays.stream(PropertyAccessorFactory
        .forBeanPropertyAccess(new MybatisProperties.CoreConfiguration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    mybatisCoreConfigurationProperties.removeAll(mybatisSpringBootConfigurationProperties);
    mybatisCoreConfigurationProperties.removeAll(Arrays.asList(""reflectorFactory"", ""defaultScriptingLanguage"",
        ""sqlFragments"", ""typeHandlerRegistry"", ""mapperRegistry"", ""interceptors"", ""cacheNames"", ""incompleteResultMaps"",
        ""typeAliasRegistry"", ""incompleteMethods"", ""proxyFactory"", ""resultMaps"", ""defaultScriptingLanguageInstance"",
        ""parameterMaps"", ""keyGenerators"", ""parameterMapNames"", ""caches"", ""mappedStatementNames"", ""objectWrapperFactory"",
        ""objectFactory"", ""incompleteStatements"", ""resultMapNames"", ""defaultScriptingLanuageInstance"",
        ""keyGeneratorNames"", ""environment"", ""mappedStatements"", ""languageRegistry"", ""incompleteCacheRefs""));
    assertThat(mybatisCoreConfigurationProperties).isEmpty();
  }"
6836,"  void setup() {
    City city = new City();
    city.setId(10L);
    city.setCountry(""US"");
    city.setState(""NV"");
    city.setName(""Las Vegas"");
    Mockito.when(cityMapper.findByState(""NV"")).thenReturn(city);
  }"
6837,"  void test() {
    @SuppressWarnings(""unchecked"")
    Map<String, Object> body = this.restTemplate.getForObject(""/cities/{state}"", Map.class, ""NV"");
    assertThat(body).hasSize(4).containsEntry(""id"", 10).containsEntry(""name"", ""Las Vegas"").containsEntry(""state"", ""NV"")
        .containsEntry(""country"", ""US"");"
6838,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
6839,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
6840,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
6841,"  void testWithDefaultCoreConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run(context -> {
      assertThat(context.getBean(SqlSessionFactory.class).getConfiguration().isSafeRowBoundsEnabled()).isFalse();"
6842,"  void testWithCustomizeCoreConfiguration() {
    assertAll(
        () -> this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)"
6843,"  void checkProperties() {
    Set<String> mybatisCoreConfigurationProperties = Arrays
        .stream(PropertyAccessorFactory.forBeanPropertyAccess(new Configuration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    Set<String> mybatisSpringBootConfigurationProperties = Arrays.stream(PropertyAccessorFactory
        .forBeanPropertyAccess(new MybatisProperties.CoreConfiguration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    mybatisCoreConfigurationProperties.removeAll(mybatisSpringBootConfigurationProperties);
    mybatisCoreConfigurationProperties.removeAll(Arrays.asList(""reflectorFactory"", ""defaultScriptingLanguage"",
        ""sqlFragments"", ""typeHandlerRegistry"", ""mapperRegistry"", ""interceptors"", ""cacheNames"", ""incompleteResultMaps"",
        ""typeAliasRegistry"", ""incompleteMethods"", ""proxyFactory"", ""resultMaps"", ""defaultScriptingLanguageInstance"",
        ""parameterMaps"", ""keyGenerators"", ""parameterMapNames"", ""caches"", ""mappedStatementNames"", ""objectWrapperFactory"",
        ""objectFactory"", ""incompleteStatements"", ""resultMapNames"", ""defaultScriptingLanuageInstance"",
        ""keyGeneratorNames"", ""environment"", ""mappedStatements"", ""languageRegistry"", ""incompleteCacheRefs""));
    assertThat(mybatisCoreConfigurationProperties).isEmpty();
  }"
6844,"    public static void main(String[] args) {
        log(""Apache Maven Wrapper Downloader "" + WRAPPER_VERSION);

        if (args.length != 2) {
            System.err.println("" - ERROR wrapperUrl or wrapperJarPath parameter missing"");
            System.exit(1);
        }

        try {
            log("" - Downloader started"");"
6845,"    private static void downloadFileFromURL(URL wrapperUrl, Path wrapperJarPath)
            throws IOException {
        log("" - Downloading to: "" + wrapperJarPath);
        if (System.getenv(""MVNW_USERNAME"") != null && System.getenv(""MVNW_PASSWORD"") != null) {
            final String username = System.getenv(""MVNW_USERNAME"");
            final char[] password = System.getenv(""MVNW_PASSWORD"").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        Path temp = wrapperJarPath
                .getParent()
                .resolve(wrapperJarPath.getFileName() + "".""
                        + Long.toUnsignedString(ThreadLocalRandom.current().nextLong()) + "".tmp"");
        try (InputStream inStream = wrapperUrl.openStream()) {
            Files.copy(inStream, temp, StandardCopyOption.REPLACE_EXISTING);
            Files.move(temp, wrapperJarPath, StandardCopyOption.REPLACE_EXISTING);
        } finally {
            Files.deleteIfExists(temp);
        }
        log("" - Downloader complete"");
    }"
6846,"                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }"
6847,"    private static void log(String msg) {
        if (VERBOSE) {
            System.out.println(msg);"
6848,"    public static void main(String[] args) {
        log(""Apache Maven Wrapper Downloader "" + WRAPPER_VERSION);

        if (args.length != 2) {
            System.err.println("" - ERROR wrapperUrl or wrapperJarPath parameter missing"");
            System.exit(1);
        }

        try {
            log("" - Downloader started"");"
6849,"    private static void downloadFileFromURL(URL wrapperUrl, Path wrapperJarPath)
            throws IOException {
        log("" - Downloading to: "" + wrapperJarPath);
        if (System.getenv(""MVNW_USERNAME"") != null && System.getenv(""MVNW_PASSWORD"") != null) {
            final String username = System.getenv(""MVNW_USERNAME"");
            final char[] password = System.getenv(""MVNW_PASSWORD"").toCharArray();
            Authenticator.setDefault(new Authenticator() {
                @Override
                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }
            });
        }
        Path temp = wrapperJarPath
                .getParent()
                .resolve(wrapperJarPath.getFileName() + "".""
                        + Long.toUnsignedString(ThreadLocalRandom.current().nextLong()) + "".tmp"");
        try (InputStream inStream = wrapperUrl.openStream()) {
            Files.copy(inStream, temp, StandardCopyOption.REPLACE_EXISTING);
            Files.move(temp, wrapperJarPath, StandardCopyOption.REPLACE_EXISTING);
        } finally {
            Files.deleteIfExists(temp);
        }
        log("" - Downloader complete"");
    }"
6850,"                protected PasswordAuthentication getPasswordAuthentication() {
                    return new PasswordAuthentication(username, password);
                }"
6851,"    private static void log(String msg) {
        if (VERBOSE) {
            System.out.println(msg);"
6852,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
6853,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6854,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6855,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
6856,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6857,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6858,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6859,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6860,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6861,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6862,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6863,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
6864,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
6865,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
6866,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6867,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6868,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6869,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6870,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6871,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6872,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6873,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
6874,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
6875,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6876,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6877,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6878,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6879,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
6880,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
6881,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
6882,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
6883,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6884,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6885,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6886,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6887,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6888,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6889,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
6890,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6891,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
6892,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
6893,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6894,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6895,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6896,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6897,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6898,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6899,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6900,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6901,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
6902,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6903,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6904,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
6905,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6906,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6907,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6908,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6909,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6910,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
6911,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
6912,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
6913,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
6914,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6915,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6916,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
6917,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
6918,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
6919,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
6920,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
6921,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
6922,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
6923,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
6924,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
6925,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6926,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6927,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
6928,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
6929,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6930,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
6931,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
6932,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
6933,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
6934,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
6935,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
6936,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
6937,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
6938,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
6939,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
6940,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
6941,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
6942,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
6943,"  void testNoDataSource() {
    this.contextRunner.withUserConfiguration(PropertyPlaceholderAutoConfiguration.class).run(context -> {
      assertThat(context.getBeanNamesForType(SqlSessionFactory.class)).isEmpty();"
6944,"  void testMultipleDataSource() {
    this.contextRunner
        .withUserConfiguration(MultipleDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6945,"  void testSingleCandidateDataSource() {
    this.contextRunner
        .withUserConfiguration(SingleCandidateDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6946,"  void testDefaultConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisLanguageDriverAutoConfiguration.class,"
6947,"  void testScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6948,"  void testAutoScanWithDefault() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6949,"  void testAutoScanWithInjectSqlSessionOnMapperScanIsFalse() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6950,"  void testAutoScanWithLazy() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6951,"  void testAutoScanWithDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6952,"  void testAutoScanWithoutDefaultScope() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6953,"  void testWithConfigLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6954,"  void testWithCheckConfigLocationFileExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisAutoConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"", ""mybatis.check-config-location=true"")"
6955,"  void testWithCheckConfigLocationFileNotSpecify() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.check-config-location=true"")"
6956,"  void testWithCheckConfigLocationFileDoesNotExists() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:foo.xml"", ""mybatis.check-config-location=true"")"
6957,"  void testWithTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6958,"  void testWithMapperLocation() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6959,"  void testWithExecutorType() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisMapperConfiguration.class,"
6960,"  void testDefaultBootConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6961,"  void testWithInterceptorsOrder1() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6962,"  void testWithInterceptorsOrder2() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisInterceptorConfiguration2.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6963,"  void testWithTypeHandlers() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisTypeHandlerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6964,"  void testWithDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, DatabaseProvidersConfiguration.class,"
6965,"  void testMixedWithConfigurationFileAndInterceptor() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisInterceptorConfiguration.class,"
6966,"  void testMixedWithConfigurationFileAndDatabaseIdProvider() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6967,"  void testMixedWithConfigurationFileAndTypeHandlersPackage() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6968,"  void testMixedWithConfigurationFileAndTypeAliasesPackageAndMapperLocations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6969,"  void testMixedWithFullConfigurations() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6970,"  void testWithMyBatisConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.configuration.map-underscore-to-camel-case:true"").run(context -> assertThat("
6971,"  void testWithMyBatisConfigurationCustomizer() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MyBatisConfigurationCustomizerConfiguration.class)"
6972,"  void testWithSqlSessionFactoryBeanCustomizer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        SqlSessionFactoryBeanCustomizerConfiguration.class).run(context -> {"
6973,"  void testConfigFileAndConfigurationWithTogether() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
        .withPropertyValues(""mybatis.config-location:mybatis-config.xml"","
6974,"  void testWithoutConfigurationVariablesAndProperties() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6975,"  void testWithConfigurationVariablesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6976,"  void testWithConfigurationPropertiesOnly() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6977,"  void testWithConfigurationVariablesAndPropertiesOtherKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6978,"  void testWithConfigurationVariablesAndPropertiesSameKey() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, PropertyPlaceholderAutoConfiguration.class)"
6979,"  void testCustomSqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6980,"  void testMySqlSessionFactory() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionFactoryConfiguration.class)"
6981,"  void testCustomSqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class,"
6982,"  void testMySqlSessionTemplate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MySqlSessionTemplateConfiguration.class)"
6983,"  void testCustomSqlSessionTemplateAndSqlSessionFactory() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MybatisBootMapperScanAutoConfiguration.class, CustomSqlSessionFactoryConfiguration.class,"
6984,"  void testTypeAliasesSuperTypeIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6985,"  void testMapperFactoryBean() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperFactoryBeanConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6986,"  void testMapperScannerConfigurer() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
        MapperScannerConfigurerConfiguration.class, PropertyPlaceholderAutoConfiguration.class).run(context -> {"
6987,"  void testDefaultScriptingLanguageIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6988,"  void testExcludeMybatisLanguageDriverAutoConfiguration() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6989,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidate() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6990,"  void testMybatisLanguageDriverAutoConfigurationWithSingleCandidateWhenDefaultLanguageDriverIsSpecify() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisScanMapperConfiguration.class,"
6991,"  void whenFlywayIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnFlywayBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6992,"  void whenCustomMigrationInitializerIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
        .run((context) -> {"
6993,"  void whenCustomFlywayIsDefinedThenMybatisSqlSessionTemplateDependsOnIt() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlyway.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6994,"  void whenLiquibaseIsAutoConfiguredThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
      BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition(""sqlSessionTemplate"");"
6995,"  void whenCustomSpringLiquibaseIsDefinedThenMybatisSqlSessionTemplateDependsOnSpringLiquibaseBeans() {
    ApplicationContextRunner contextRunner = new ApplicationContextRunner()
        .withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class, MybatisAutoConfiguration.class));
    contextRunner.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
        .run((context) -> {"
6996,"  void testTypeAliasesWithMultiByteCharacterInPackageName() {
    this.contextRunner
        .withUserConfiguration(EmbeddedDataSourceConfiguration.class, MybatisBootMapperScanAutoConfiguration.class)"
6997,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
6998,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
6999,"    DataSource dataSourcePrimary() {
      return Mockito.mock(DataSource.class);
    }"
7000,"    DataSource dataSourceReplica() {
      return Mockito.mock(DataSource.class);
    }"
7001,"    MapperFactoryBean<DateTimeMapper> dateTimeMapper(SqlSessionFactory sqlSessionFactory) {
      MapperFactoryBean<DateTimeMapper> factoryBean = new MapperFactoryBean<>(DateTimeMapper.class);
      factoryBean.setSqlSessionFactory(sqlSessionFactory);
      return factoryBean;
    }"
7002,"    static MapperScannerConfigurer mapperScannerConfigurer() {
      MapperScannerConfigurer configurer = new MapperScannerConfigurer();
      configurer.setBasePackage(""com.example.mapper"");
      return configurer;
    }"
7003,"    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
      beanFactory.registerScope(""thread"", new SimpleThreadScope());
    }"
7004,"    public CityMapperImpl cityMapper() {
      return new CityMapperImpl();
    }"
7005,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
7006,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
7007,"    public MyInterceptor myInterceptor() {
      return new MyInterceptor();
    }"
7008,"    public MyInterceptor2 myInterceptor2() {
      return new MyInterceptor2();
    }"
7009,"    public MyTypeHandler myTypeHandler() {
      return new MyTypeHandler();
    }"
7010,"    ConfigurationCustomizer typeHandlerConfigurationCustomizer() {
      return configuration -> configuration.getTypeHandlerRegistry().register(new DummyTypeHandler());
    }"
7011,"    ConfigurationCustomizer cacheConfigurationCustomizer() {
      return configuration -> configuration.addCache(new PerpetualCache(""test""));
    }"
7012,"    SqlSessionFactoryBeanCustomizer typeHandlerSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setTypeHandlers(new DummyTypeHandler());
    }"
7013,"    SqlSessionFactoryBeanCustomizer cacheSqlSessionFactoryBeanCustomizer() {
      return factoryBean -> factoryBean.setCache(new PerpetualCache(""test""));
    }"
7014,"    ThymeleafLanguageDriver myThymeleafLanguageDriver() {
      return new ThymeleafLanguageDriver();
    }"
7015,"    public Object intercept(Invocation invocation) {
      return ""Test"";
    }"
7016,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
7017,"    public void setProperties(Properties properties) {

    }
  }

  @Intercepts(@Signature(type = Map.class, method = ""get"", args = { Object.class }))
  static class MyInterceptor2 implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }

    @Override
    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }

    @Override
    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
7018,"    public Object intercept(Invocation invocation) {
      return ""Test2"";
    }"
7019,"    public Object plugin(Object target) {
      return Plugin.wrap(target, this);
    }"
7020,"    public void setProperties(Properties properties) {

    }
  }

  @Configuration
  static class DatabaseProvidersConfiguration {

    @Bean
    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }

    @Bean
    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }

  }

  @Configuration
  static class CustomSqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }
  }

  @Configuration
  static class MySqlSessionFactoryConfiguration {
    @Bean
    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }
  }

  @Configuration
  static class CustomSqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }
  }

  @Configuration
  static class MySqlSessionTemplateConfiguration {
    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }
  }

  static class MySqlSessionFactory extends DefaultSqlSessionFactory {
    MySqlSessionFactory(org.apache.ibatis.session.Configuration configuration) {
      super(configuration);
    }
  }

  static class MySqlSessionTemplate extends SqlSessionTemplate {
    MySqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      super(sqlSessionFactory);
    }
  }

  static class MyTypeHandler extends BaseTypeHandler<UUID> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
7021,"    public PropertiesFactoryBean vendorProperties() {
      Properties properties = new Properties();
      properties.put(""SQL Server"", ""sqlserver"");
      properties.put(""DB2"", ""db2"");
      properties.put(""H2"", ""h2"");

      PropertiesFactoryBean propertiesFactoryBean = new PropertiesFactoryBean();
      propertiesFactoryBean.setProperties(properties);
      return propertiesFactoryBean;
    }"
7022,"    public VendorDatabaseIdProvider vendorDatabaseIdProvider(
        @Qualifier(""vendorProperties"") Properties vendorProperties) {
      VendorDatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
      databaseIdProvider.setProperties(vendorProperties);
      return databaseIdProvider;
    }"
7023,"    public SqlSessionFactory customSqlSessionFactory(DataSource dataSource) throws Exception {
      SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
      sqlSessionFactoryBean.setDataSource(dataSource);
      Properties props = new Properties();
      props.setProperty(""key"", ""value"");
      sqlSessionFactoryBean.setConfigurationProperties(props);
      return sqlSessionFactoryBean.getObject();
    }"
7024,"    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) {
      MySqlSessionFactory sqlSessionFactory = new MySqlSessionFactory(new org.apache.ibatis.session.Configuration());
      sqlSessionFactory.getConfiguration()
          .setEnvironment(new Environment("""", new SpringManagedTransactionFactory(), dataSource));
      return sqlSessionFactory;
    }"
7025,"    public SqlSessionTemplate customSqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new SqlSessionTemplate(sqlSessionFactory, ExecutorType.BATCH);
    }"
7026,"    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
      return new MySqlSessionTemplate(sqlSessionFactory);
    }"
7027,"    public void setNonNullParameter(PreparedStatement ps, int i, UUID parameter, JdbcType jdbcType) {

    }

    @Override
    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }

    @Override
    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }

    @Override
    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }

  }

  @Configuration
  @TestAutoConfigurationPackage(CityMapper.class)
  static class CityMapperRepositoryConfiguration {

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlywayMigrationInitializer {

    @Bean
    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class CustomFlyway {

    @Bean
    Flyway customFlyway() {
      return Flyway.configure().load();
    }

  }

  @Configuration(proxyBeanMethods = false)
  static class LiquibaseUserConfiguration {

    @Bean
    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }

  }

}"
7028,"    public UUID getNullableResult(ResultSet rs, String columnName) {
      return null;
    }"
7029,"    public UUID getNullableResult(ResultSet rs, int columnIndex) {
      return null;
    }"
7030,"    public UUID getNullableResult(CallableStatement cs, int columnIndex) {
      return null;
    }"
7031,"    FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
      FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
      initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
      return initializer;
    }"
7032,"    Flyway customFlyway() {
      return Flyway.configure().load();
    }"
7033,"    SpringLiquibase springLiquibase(DataSource dataSource) {
      SpringLiquibase liquibase = new SpringLiquibase();
      liquibase.setChangeLog(""classpath:/db/changelog/db.changelog-master.yaml"");
      liquibase.setShouldRun(true);
      liquibase.setDataSource(dataSource);
      return liquibase;
    }"
7034,"  void emptyMapperLocations() {
    MybatisProperties properties = new MybatisProperties();
    assertThat(properties.resolveMapperLocations()).isEmpty();
  }"
7035,"  void twoLocations() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repository/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(2);
  }"
7036,"  void twoLocationsWithOneIncorrectLocation() {
    MybatisProperties properties = new MybatisProperties();
    properties
        .setMapperLocations(new String[] { ""classpath:org/mybatis/spring/boot/autoconfigure/repository/CityMapper.xml"",
            ""classpath:org/mybatis/spring/boot/autoconfigure/repositoy/*Mapper.xml"" });
    assertThat(properties.resolveMapperLocations()).hasSize(1);
  }"
7037,"  void testWithDefaultCoreConfiguration() {
    this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run(context -> {
      assertThat(context.getBean(SqlSessionFactory.class).getConfiguration().isSafeRowBoundsEnabled()).isFalse();"
7038,"  void testWithCustomizeCoreConfiguration() {
    assertAll(
        () -> this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)"
7039,"  void checkProperties() {
    Set<String> mybatisCoreConfigurationProperties = Arrays
        .stream(PropertyAccessorFactory.forBeanPropertyAccess(new Configuration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    Set<String> mybatisSpringBootConfigurationProperties = Arrays.stream(PropertyAccessorFactory
        .forBeanPropertyAccess(new MybatisProperties.CoreConfiguration()).getPropertyDescriptors())
        .map(PropertyDescriptor::getName).collect(Collectors.toSet());
    mybatisCoreConfigurationProperties.removeAll(mybatisSpringBootConfigurationProperties);
    mybatisCoreConfigurationProperties.removeAll(Arrays.asList(""reflectorFactory"", ""defaultScriptingLanguage"",
        ""sqlFragments"", ""typeHandlerRegistry"", ""mapperRegistry"", ""interceptors"", ""cacheNames"", ""incompleteResultMaps"",
        ""typeAliasRegistry"", ""incompleteMethods"", ""proxyFactory"", ""resultMaps"", ""defaultScriptingLanguageInstance"",
        ""parameterMaps"", ""keyGenerators"", ""parameterMapNames"", ""caches"", ""mappedStatementNames"", ""objectWrapperFactory"",
        ""objectFactory"", ""incompleteStatements"", ""resultMapNames"", ""defaultScriptingLanuageInstance"",
        ""keyGeneratorNames"", ""environment"", ""mappedStatements"", ""languageRegistry"", ""incompleteCacheRefs""));
    assertThat(mybatisCoreConfigurationProperties).isEmpty();
  }"
7040,"  public static void initializeFlipper(Context context, ReactInstanceManager reactInstanceManager) {
    if (FlipperUtils.shouldEnableFlipper(context)) {
      final FlipperClient client = AndroidFlipperClient.getInstance(context);"
7041,"            public void apply(OkHttpClient.Builder builder) {
              builder.addNetworkInterceptor(new FlipperOkhttpInterceptor(networkFlipperPlugin));
            }"
7042,"              public void onReactContextInitialized(ReactContext reactContext) {
                reactInstanceManager.removeReactInstanceEventListener(this);
                reactContext.runOnNativeModulesQueueThread(
                    new Runnable() {"
7043,"                      public void run() {
                        client.addPlugin(new FrescoFlipperPlugin());
                      }"
7044,"  protected String getMainComponentName() {
    return ""Reanimated2Playground"";
  }"
7045,"        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }"
7046,"        protected List<ReactPackage> getPackages() {
          @SuppressWarnings(""UnnecessaryLocalVariable"")
          List<ReactPackage> packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // packages.add(new MyReactNativePackage());
          return packages;
        }"
7047,"        protected String getJSMainModuleName() {
          return ""index"";
        }"
7048,"  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }"
7049,"  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }"
7050,"  private static void initializeFlipper(
      Context context, ReactInstanceManager reactInstanceManager) {
    if (BuildConfig.DEBUG) {
      try {"
7051,"  protected String getMainComponentName() {
    return ""Reanimated2Playground"";
  }"
7052,"  protected ReactActivityDelegate createReactActivityDelegate() {
    return new ReactActivityDelegate(this, getMainComponentName()) {
      @Override"
7053,"      protected ReactRootView createRootView() {
       return new RNGestureHandlerEnabledRootView(MainActivity.this);
      }"
7054,"        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }"
7055,"        protected List<ReactPackage> getPackages() {
          @SuppressWarnings(""UnnecessaryLocalVariable"")
          List<ReactPackage> packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // packages.add(new MyReactNativePackage());
          return packages;
        }"
7056,"        protected String getJSMainModuleName() {
          return ""index"";
        }"
7057,"        protected JSIModulePackage getJSIModulePackage() {
          return new ReanimatedJSIModulePackage();
        }"
7058,"  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }"
7059,"  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }"
7060,"  private static void initializeFlipper(
      Context context, ReactInstanceManager reactInstanceManager) {
    if (BuildConfig.DEBUG) {
      try {"
7061,"  protected String getMainComponentName() {
    return ""Reanimated2Playground"";
  }"
7062,"  protected ReactActivityDelegate createReactActivityDelegate() {
    return new ReactActivityDelegate(this, getMainComponentName()) {
      @Override"
7063,"      protected ReactRootView createRootView() {
       return new RNGestureHandlerEnabledRootView(MainActivity.this);
      }"
7064,"        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }"
7065,"        protected List<ReactPackage> getPackages() {
          @SuppressWarnings(""UnnecessaryLocalVariable"")
          List<ReactPackage> packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // packages.add(new MyReactNativePackage());
          return packages;
        }"
7066,"        protected String getJSMainModuleName() {
          return ""index"";
        }"
7067,"  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }"
7068,"  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }"
7069,"  private static void initializeFlipper(
      Context context, ReactInstanceManager reactInstanceManager) {
    if (BuildConfig.DEBUG) {
      try {"
7070,"        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }"
7071,"        protected List<ReactPackage> getPackages() {
          @SuppressWarnings(""UnnecessaryLocalVariable"")
          List<ReactPackage> packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // packages.add(new MyReactNativePackage());
          return packages;
        }"
7072,"        protected String getJSMainModuleName() {
          return ""index"";
        }"
7073,"        protected JSIModulePackage getJSIModulePackage() {
          return new ReanimatedJSIModulePackage(); // <- add
        }"
7074,"  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }"
7075,"  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }"
7076,"  private static void initializeFlipper(
      Context context, ReactInstanceManager reactInstanceManager) {
    if (BuildConfig.DEBUG) {
      try {"
7077,"  public static void initializeFlipper(Context context, ReactInstanceManager reactInstanceManager) {
    if (FlipperUtils.shouldEnableFlipper(context)) {
      final FlipperClient client = AndroidFlipperClient.getInstance(context);"
7078,"            public void apply(OkHttpClient.Builder builder) {
              builder.addNetworkInterceptor(new FlipperOkhttpInterceptor(networkFlipperPlugin));
            }"
7079,"              public void onReactContextInitialized(ReactContext reactContext) {
                reactInstanceManager.removeReactInstanceEventListener(this);
                reactContext.runOnNativeModulesQueueThread(
                    new Runnable() {"
7080,"                      public void run() {
                        client.addPlugin(new FrescoFlipperPlugin());
                      }"
7081,"  protected String getMainComponentName() {
    return ""Reanimated3Playground"";
  }"
7082,"  protected ReactActivityDelegate createReactActivityDelegate() {
    return new DefaultReactActivityDelegate(
        this,"
7083,"        public boolean getUseDeveloperSupport() {
          return BuildConfig.DEBUG;
        }"
7084,"        protected List<ReactPackage> getPackages() {
          @SuppressWarnings(""UnnecessaryLocalVariable"")
          List<ReactPackage> packages = new PackageList(this).getPackages();
          // Packages that cannot be autolinked yet can be added manually here, for example:
          // packages.add(new MyReactNativePackage());
          return packages;
        }"
7085,"        protected String getJSMainModuleName() {
          return ""index"";
        }"
7086,"        protected boolean isNewArchEnabled() {
          return BuildConfig.IS_NEW_ARCHITECTURE_ENABLED;
        }"
7087,"        protected Boolean isHermesEnabled() {
          return BuildConfig.IS_HERMES_ENABLED;
        }"
7088,"  public ReactNativeHost getReactNativeHost() {
    return mReactNativeHost;
  }"
7089,"  public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    if (BuildConfig.IS_NEW_ARCHITECTURE_ENABLED) {
      // If you opted-in for the New Architecture, we load the native entry point for this app.
      DefaultNewArchitectureEntryPoint.load();
    }
    ReactNativeFlipper.initializeFlipper(this, getReactNativeHost().getReactInstanceManager());
  }"
7090,"  public static void initializeFlipper(Context context, ReactInstanceManager reactInstanceManager) {
    // Do nothing as we don't want to initialize Flipper on Release.
  }
}"
7091,"    public boolean basicLoad(final Ruby runtime) throws IOException {
        new com.concurrent_ruby.ext.AtomicReferenceLibrary().load(runtime, false);
        new com.concurrent_ruby.ext.JavaAtomicBooleanLibrary().load(runtime, false);
        new com.concurrent_ruby.ext.JavaAtomicFixnumLibrary().load(runtime, false);
        new com.concurrent_ruby.ext.JavaSemaphoreLibrary().load(runtime, false);
        new com.concurrent_ruby.ext.SynchronizationLibrary().load(runtime, false);
        new com.concurrent_ruby.ext.JRubyMapBackendLibrary().load(runtime, false);
        return true;
    }"
7092,"    public void load(Ruby runtime, boolean wrap) throws IOException {
        RubyModule concurrentMod = runtime.defineModule(""Concurrent"");
        RubyClass atomicCls = concurrentMod.defineClassUnder(""JavaAtomicReference"", runtime.getObject(), JRUBYREFERENCE_ALLOCATOR);
        try {
            sun.misc.Unsafe.class.getMethod(""getAndSetObject"", Object.class);
            atomicCls.setAllocator(JRUBYREFERENCE8_ALLOCATOR);
        } catch (Exception e) {
            // leave it as Java 6/7 version
        }
        atomicCls.defineAnnotatedMethods(JRubyReference.class);
    }"
7093,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JRubyReference(runtime, klazz);
        }"
7094,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JRubyReference8(runtime, klazz);
        }"
7095,"        public IRubyObject initialize(ThreadContext context) {
            UNSAFE.putObject(this, referenceOffset, context.nil);
            return context.nil;
        }"
7096,"        public IRubyObject initialize(ThreadContext context, IRubyObject value) {
            UNSAFE.putObject(this, referenceOffset, value);
            return context.nil;
        }"
7097,"        public IRubyObject get() {
            return reference;
        }"
7098,"        public IRubyObject set(IRubyObject newValue) {
            UNSAFE.putObjectVolatile(this, referenceOffset, newValue);
            return newValue;
        }"
7099,"        public IRubyObject compare_and_set(ThreadContext context, IRubyObject expectedValue, IRubyObject newValue) {
            Ruby runtime = context.runtime;
            
            if (expectedValue instanceof RubyNumeric) {
                // numerics are not always idempotent in Ruby, so we need to do slower logic
                return compareAndSetNumeric(context, expectedValue, newValue);
            }
            
            return runtime.newBoolean(UNSAFE.compareAndSwapObject(this, referenceOffset, expectedValue, newValue));
        }"
7100,"        public IRubyObject get_and_set(ThreadContext context, IRubyObject newValue) {
            // less-efficient version for Java 6 and 7
            while (true) {
                IRubyObject oldValue = get();"
7101,"        private IRubyObject compareAndSetNumeric(ThreadContext context, IRubyObject expectedValue, IRubyObject newValue) {
            Ruby runtime = context.runtime;
            
            // loop until:
            // * reference CAS would succeed for same-valued objects
            // * current and expected have different values as determined by #equals
            while (true) {
                IRubyObject current = reference;"
7102,"	private static sun.misc.Unsafe loadUnsafe() {
	    try {
		Class unsafeClass = Class.forName(""sun.misc.Unsafe"");"
7103,"        public IRubyObject get_and_set(ThreadContext context, IRubyObject newValue) {
            // efficient version for Java 8
            return (IRubyObject)UNSAFE.getAndSetObject(this, referenceOffset, newValue);
        }"
7104,"  public void load(Ruby runtime, boolean wrap) throws IOException {

    RubyModule concurrentMod = runtime.defineModule(""Concurrent"");
    RubyModule thread_safeMod = concurrentMod.defineModuleUnder(""Collection"");
    RubyClass jrubyRefClass = thread_safeMod.defineClassUnder(""JRubyMapBackend"", runtime.getObject(), BACKEND_ALLOCATOR);
    jrubyRefClass.setAllocator(BACKEND_ALLOCATOR);
    jrubyRefClass.defineAnnotatedMethods(JRubyMapBackend.class);
  }"
7105,"    public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
      return new JRubyMapBackend(runtime, klazz);
    }"
7106,"      private static ConcurrentHashMap<IRubyObject, IRubyObject> newCHM(int initialCapacity, float loadFactor) {
        if (CAN_USE_UNSAFE_CHM) {
          return new ConcurrentHashMapV8<IRubyObject, IRubyObject>(initialCapacity, loadFactor);"
7107,"      private static ConcurrentHashMap<IRubyObject, IRubyObject> newCHM() {
        return newCHM(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);
      }"
7108,"      private static boolean canUseUnsafeCHM() {
        try {
          new com.concurrent_ruby.ext.jsr166e.ConcurrentHashMapV8(); // force class load and initialization"
7109,"      private static boolean isCausedBySecurityException(Throwable t) {
        while (t != null) {
          if ((t.getMessage() != null && t.getMessage().contains(""Could not initialize intrinsics"")) || t instanceof SecurityException) {
            return true;
          }
          t = t.getCause();
        }
        return false;
      }"
7110,"      public IRubyObject initialize(ThreadContext context) {
        map = newCHM();
        return context.getRuntime().getNil();
      }"
7111,"      public IRubyObject initialize(ThreadContext context, IRubyObject options) {
        map = toCHM(context, options);
        return context.getRuntime().getNil();
      }"
7112,"      private ConcurrentHashMap<IRubyObject, IRubyObject> toCHM(ThreadContext context, IRubyObject options) {
        Ruby runtime = context.getRuntime();
        if (!options.isNil() && options.respondsTo(""[]"")) {
          IRubyObject rInitialCapacity = options.callMethod(context, ""[]"", runtime.newSymbol(""initial_capacity""));"
7113,"        public IRubyObject op_aref(ThreadContext context, IRubyObject key) {
          IRubyObject value;
          return ((value = map.get(key)) == null) ? context.getRuntime().getNil() : value;
        }"
7114,"        public IRubyObject op_aset(IRubyObject key, IRubyObject value) {
          map.put(key, value);
          return value;
        }"
7115,"      public IRubyObject put_if_absent(IRubyObject key, IRubyObject value) {
        IRubyObject result = map.putIfAbsent(key, value);
        return result == null ? getRuntime().getNil() : result;
      }"
7116,"      public IRubyObject compute_if_absent(final ThreadContext context, final IRubyObject key, final Block block) {
        return map.computeIfAbsent(key, new ConcurrentHashMap.Fun<IRubyObject, IRubyObject>() {
          @Override"
7117,"          public IRubyObject apply(IRubyObject key) {
            return block.yieldSpecific(context);
          }"
7118,"      public IRubyObject compute_if_present(final ThreadContext context, final IRubyObject key, final Block block) {
        IRubyObject result = map.computeIfPresent(key, new ConcurrentHashMap.BiFun<IRubyObject, IRubyObject, IRubyObject>() {
          @Override
          public IRubyObject apply(IRubyObject key, IRubyObject oldValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }
        });
        return result == null ? context.getRuntime().getNil() : result;
      }"
7119,"          public IRubyObject apply(IRubyObject key, IRubyObject oldValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }"
7120,"      public IRubyObject compute(final ThreadContext context, final IRubyObject key, final Block block) {
        IRubyObject result = map.compute(key, new ConcurrentHashMap.BiFun<IRubyObject, IRubyObject, IRubyObject>() {
          @Override
          public IRubyObject apply(IRubyObject key, IRubyObject oldValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }
        });
        return result == null ? context.getRuntime().getNil() : result;
      }"
7121,"          public IRubyObject apply(IRubyObject key, IRubyObject oldValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }"
7122,"      public IRubyObject merge_pair(final ThreadContext context, final IRubyObject key, final IRubyObject value, final Block block) {
        IRubyObject result = map.merge(key, value, new ConcurrentHashMap.BiFun<IRubyObject, IRubyObject, IRubyObject>() {
          @Override
          public IRubyObject apply(IRubyObject oldValue, IRubyObject newValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }
        });
        return result == null ? context.getRuntime().getNil() : result;
      }"
7123,"          public IRubyObject apply(IRubyObject oldValue, IRubyObject newValue) {
            IRubyObject result = block.yieldSpecific(context, oldValue == null ? context.getRuntime().getNil() : oldValue);
            return result.isNil() ? null : result;
          }"
7124,"      public RubyBoolean replace_pair(IRubyObject key, IRubyObject oldValue, IRubyObject newValue) {
        return getRuntime().newBoolean(map.replace(key, oldValue, newValue));
      }"
7125,"        public RubyBoolean has_key_p(IRubyObject key) {
          return map.containsKey(key) ? getRuntime().getTrue() : getRuntime().getFalse();
        }"
7126,"      public IRubyObject key(IRubyObject value) {
        final IRubyObject key = map.findKey(value);
        return key == null ? getRuntime().getNil() : key;
      }"
7127,"      public IRubyObject replace_if_exists(IRubyObject key, IRubyObject value) {
        IRubyObject result = map.replace(key, value);
        return result == null ? getRuntime().getNil() : result;
      }"
7128,"      public IRubyObject get_and_set(IRubyObject key, IRubyObject value) {
        IRubyObject result = map.put(key, value);
        return result == null ? getRuntime().getNil() : result;
      }"
7129,"      public IRubyObject delete(IRubyObject key) {
        IRubyObject result = map.remove(key);
        return result == null ? getRuntime().getNil() : result;
      }"
7130,"      public RubyBoolean delete_pair(IRubyObject key, IRubyObject value) {
        return getRuntime().newBoolean(map.remove(key, value));
      }"
7131,"      public IRubyObject clear() {
        map.clear();
        return this;
      }"
7132,"      public IRubyObject each_pair(ThreadContext context, Block block) {
        for (Map.Entry<IRubyObject,IRubyObject> entry : map.entrySet()) {
          block.yieldSpecific(context, entry.getKey(), entry.getValue());
        }
        return this;
      }"
7133,"      public RubyFixnum size(ThreadContext context) {
        return context.getRuntime().newFixnum(map.size());
      }"
7134,"      public IRubyObject get_or_default(IRubyObject key, IRubyObject defaultValue) {
        return map.getValueOrDefault(key, defaultValue);
      }"
7135,"        public JRubyMapBackend initialize_copy(ThreadContext context, IRubyObject other) {
          map = newCHM();
          return this;
        }"
7136,"    public void load(Ruby runtime, boolean wrap) throws IOException {
        RubyModule concurrentMod = runtime.defineModule(""Concurrent"");
        RubyClass atomicCls = concurrentMod.defineClassUnder(""JavaAtomicBoolean"", runtime.getObject(), JRUBYREFERENCE_ALLOCATOR);
        atomicCls.defineAnnotatedMethods(JavaAtomicBoolean.class);
    }"
7137,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JavaAtomicBoolean(runtime, klazz);
        }"
7138,"        public IRubyObject initialize(ThreadContext context, IRubyObject value) {
            atomicBoolean = new AtomicBoolean(convertRubyBooleanToJavaBoolean(value));
            return context.nil;
        }"
7139,"        public IRubyObject initialize(ThreadContext context) {
            atomicBoolean = new AtomicBoolean();
            return context.nil;
        }"
7140,"        public IRubyObject value() {
            return getRuntime().newBoolean(atomicBoolean.get());
        }"
7141,"        public IRubyObject isAtomicTrue() {
            return getRuntime().newBoolean(atomicBoolean.get());
        }"
7142,"        public IRubyObject isAtomicFalse() {
            return getRuntime().newBoolean((atomicBoolean.get() == false));
        }"
7143,"        public IRubyObject setAtomic(ThreadContext context, IRubyObject newValue) {
            atomicBoolean.set(convertRubyBooleanToJavaBoolean(newValue));
            return context.nil;
        }"
7144,"        public IRubyObject makeTrue() {
            return getRuntime().newBoolean(atomicBoolean.compareAndSet(false, true));
        }"
7145,"        public IRubyObject makeFalse() {
            return getRuntime().newBoolean(atomicBoolean.compareAndSet(true, false));
        }"
7146,"        private boolean convertRubyBooleanToJavaBoolean(IRubyObject newValue) {
            if (newValue instanceof RubyBoolean.False || newValue instanceof RubyNil) {
                return false;"
7147,"    public void load(Ruby runtime, boolean wrap) throws IOException {
        RubyModule concurrentMod = runtime.defineModule(""Concurrent"");
        RubyClass atomicCls = concurrentMod.defineClassUnder(""JavaAtomicFixnum"", runtime.getObject(), JRUBYREFERENCE_ALLOCATOR);

        atomicCls.defineAnnotatedMethods(JavaAtomicFixnum.class);
    }"
7148,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JavaAtomicFixnum(runtime, klazz);
        }"
7149,"        public IRubyObject initialize(ThreadContext context) {
            this.atomicLong = new AtomicLong(0);
            return context.nil;
        }"
7150,"        public IRubyObject initialize(ThreadContext context, IRubyObject value) {
            this.atomicLong = new AtomicLong(rubyFixnumToLong(value));
            return context.nil;
        }"
7151,"        public IRubyObject getValue() {
            return getRuntime().newFixnum(atomicLong.get());
        }"
7152,"        public IRubyObject setValue(ThreadContext context, IRubyObject newValue) {
            atomicLong.set(rubyFixnumToLong(newValue));
            return context.nil;
        }"
7153,"        public IRubyObject increment() {
            return getRuntime().newFixnum(atomicLong.incrementAndGet());
        }"
7154,"        public IRubyObject increment(IRubyObject value) {
            long delta = rubyFixnumToLong(value);
            return getRuntime().newFixnum(atomicLong.addAndGet(delta));
        }"
7155,"        public IRubyObject decrement() {
            return getRuntime().newFixnum(atomicLong.decrementAndGet());
        }"
7156,"        public IRubyObject decrement(IRubyObject value) {
            long delta = rubyFixnumToLong(value);
            return getRuntime().newFixnum(atomicLong.addAndGet(-delta));
        }"
7157,"        public IRubyObject compareAndSet(ThreadContext context, IRubyObject expect, IRubyObject update) {
            return getRuntime().newBoolean(atomicLong.compareAndSet(rubyFixnumToLong(expect), rubyFixnumToLong(update)));
        }"
7158,"        public IRubyObject update(ThreadContext context, Block block) {
            for (;;) {
                long _oldValue       = atomicLong.get();"
7159,"        private long rubyFixnumToLong(IRubyObject value) {
            if (value instanceof RubyFixnum) {
                RubyFixnum fixNum = (RubyFixnum) value;"
7160,"    public void load(Ruby runtime, boolean wrap) throws IOException {
        RubyModule concurrentMod = runtime.defineModule(""Concurrent"");
        RubyClass atomicCls = concurrentMod.defineClassUnder(""JavaSemaphore"", runtime.getObject(), JRUBYREFERENCE_ALLOCATOR);

        atomicCls.defineAnnotatedMethods(JavaSemaphore.class);
    }"
7161,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JavaSemaphore(runtime, klazz);
        }"
7162,"        public IRubyObject initialize(ThreadContext context, IRubyObject value) {
            this.semaphore = new JRubySemaphore(rubyFixnumInt(value, ""count""));
            return context.nil;
        }"
7163,"        public IRubyObject acquire(ThreadContext context, final Block block) throws InterruptedException {
            return this.acquire(context, 1, block);
        }"
7164,"        public IRubyObject acquire(ThreadContext context, IRubyObject permits, final Block block) throws InterruptedException {
            return this.acquire(context, rubyFixnumToPositiveInt(permits, ""permits""), block);
        }"
7165,"        public IRubyObject availablePermits(ThreadContext context) {
            return getRuntime().newFixnum(this.semaphore.availablePermits());
        }"
7166,"        public IRubyObject drainPermits(ThreadContext context) {
            return getRuntime().newFixnum(this.semaphore.drainPermits());
        }"
7167,"        public IRubyObject tryAcquire(ThreadContext context, final Block block) throws InterruptedException {
            int permitsInt = 1;
            boolean acquired = semaphore.tryAcquire(permitsInt);

            return triedAcquire(context, permitsInt, acquired, block);
        }"
7168,"        public IRubyObject tryAcquire(ThreadContext context, IRubyObject permits, final Block block) throws InterruptedException {
            int permitsInt = rubyFixnumToPositiveInt(permits, ""permits"");
            boolean acquired = semaphore.tryAcquire(permitsInt);

            return triedAcquire(context, permitsInt, acquired, block);
        }"
7169,"        public IRubyObject tryAcquire(ThreadContext context, IRubyObject permits, IRubyObject timeout, final Block block) throws InterruptedException {
            int permitsInt = rubyFixnumToPositiveInt(permits, ""permits"");
            boolean acquired = semaphore.tryAcquire(
                    permitsInt,
                    rubyNumericToLong(timeout, ""timeout""),
                    java.util.concurrent.TimeUnit.SECONDS
                    );

            return triedAcquire(context, permitsInt, acquired, block);
        }"
7170,"        public IRubyObject release(ThreadContext context) {
            this.semaphore.release(1);
            return getRuntime().newBoolean(true);
        }"
7171,"        public IRubyObject release(ThreadContext context, IRubyObject permits) {
            this.semaphore.release(rubyFixnumToPositiveInt(permits, ""permits""));
            return getRuntime().newBoolean(true);
        }"
7172,"        public IRubyObject reducePermits(ThreadContext context, IRubyObject reduction) throws InterruptedException {
            this.semaphore.publicReducePermits(rubyFixnumToNonNegativeInt(reduction, ""reduction""));
            return context.nil;
        }"
7173,"        private IRubyObject acquire(ThreadContext context, int permits, final Block block) throws InterruptedException {
            this.semaphore.acquire(permits);

            if (!block.isGiven()) return context.nil;

            try {
                return block.yieldSpecific(context);"
7174,"        private IRubyObject triedAcquire(ThreadContext context, int permits, boolean acquired, final Block block) {
            if (!block.isGiven()) return getRuntime().newBoolean(acquired);
            if (!acquired) return context.nil;

            try {
                return block.yieldSpecific(context);"
7175,"        private int rubyFixnumInt(IRubyObject value, String paramName) {
            if (value instanceof RubyFixnum) {
                RubyFixnum fixNum = (RubyFixnum) value;"
7176,"        private int rubyFixnumToNonNegativeInt(IRubyObject value, String paramName) {
            if (value instanceof RubyFixnum && ((RubyFixnum) value).getLongValue() >= 0) {
                RubyFixnum fixNum = (RubyFixnum) value;"
7177,"        private int rubyFixnumToPositiveInt(IRubyObject value, String paramName) {
            if (value instanceof RubyFixnum && ((RubyFixnum) value).getLongValue() > 0) {
                RubyFixnum fixNum = (RubyFixnum) value;"
7178,"        private long rubyNumericToLong(IRubyObject value, String paramName) {
            if (value instanceof RubyNumeric && ((RubyNumeric) value).getDoubleValue() > 0) {
                RubyNumeric fixNum = (RubyNumeric) value;"
7179,"            public void publicReducePermits(int i) {
                reducePermits(i);
            }"
7180,"    private static Unsafe loadUnsafe() {
        try {
            Class ncdfe = Class.forName(""sun.misc.Unsafe"");"
7181,"    private static boolean supportsFences() {
        if (UNSAFE == null) {
            return false;"
7182,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new Object(runtime, klazz);
        }"
7183,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new AbstractLockableObject(runtime, klazz);
        }"
7184,"        public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
            return new JRubyLockableObject(runtime, klazz);
        }"
7185,"    public void load(Ruby runtime, boolean wrap) throws IOException {
        RubyModule synchronizationModule = runtime.
                defineModule(""Concurrent"").
                defineModuleUnder(""Synchronization"");

        RubyModule jrubyAttrVolatileModule = synchronizationModule.defineModuleUnder(""JRubyAttrVolatile"");
        jrubyAttrVolatileModule.defineAnnotatedMethods(JRubyAttrVolatile.class);

        defineClass(runtime, synchronizationModule, ""AbstractObject"", ""Object"",
                Object.class, OBJECT_ALLOCATOR);

        defineClass(runtime, synchronizationModule, ""Object"", ""AbstractLockableObject"",
                AbstractLockableObject.class, ABSTRACT_LOCKABLE_OBJECT_ALLOCATOR);

        defineClass(runtime, synchronizationModule, ""AbstractLockableObject"", ""JRubyLockableObject"",
                JRubyLockableObject.class, JRUBY_LOCKABLE_OBJECT_ALLOCATOR);

        defineClass(runtime, synchronizationModule, ""Object"", ""JRuby"",
                JRuby.class, new ObjectAllocator() {"
7186,"                    public IRubyObject allocate(Ruby runtime, RubyClass klazz) {
                        return new JRuby(runtime, klazz);
                    }"
7187,"    private RubyClass defineClass(
            Ruby runtime,
            RubyModule namespace,
            String parentName,
            String name,
            Class javaImplementation,
            ObjectAllocator allocator) {
        final RubyClass parentClass = namespace.getClass(parentName);

        if (parentClass == null) {
            System.out.println(""not found "" + parentName);
            throw runtime.newRuntimeError(namespace.toString() + ""::"" + parentName + "" is missing"");
        }

        final RubyClass newClass = namespace.defineClassUnder(name, parentClass, allocator);
        newClass.defineAnnotatedMethods(javaImplementation);
        return newClass;
    }"
7188,"        public static IRubyObject fullMemoryBarrier(ThreadContext context, IRubyObject module) {
            // Prevent reordering of ivar writes with publication of this instance
            if (!FULL_FENCE) {
                // Assuming that following volatile read and write is not eliminated it simulates fullFence.
                // If it's eliminated it'll cause problems only on non-x86 platforms.
                // http://shipilev.net/blog/2014/jmm-pragmatics/#_happens_before_test_your_understanding
                final int volatileRead = volatileField;
                volatileField = context.getLine();
            } else {
                UNSAFE.fullFence();
            }
            return context.nil;
        }"
7189,"        public static IRubyObject instanceVariableGetVolatile(
                ThreadContext context,
                IRubyObject module,
                IRubyObject self,
                IRubyObject name) {
            // Ensure we ses latest value with loadFence
            if (!FULL_FENCE) {
                // piggybacking on volatile read, simulating loadFence"
7190,"        public static IRubyObject InstanceVariableSetVolatile(
                ThreadContext context,
                IRubyObject module,
                IRubyObject self,
                IRubyObject name,
                IRubyObject value) {
            // Ensure we make last update visible
            if (!FULL_FENCE) {
                // piggybacking on volatile write, simulating storeFence"
7191,"        public IRubyObject rubySynchronize(ThreadContext context, Block block) {
            synchronized (this) {
                return block.yield(context, null);"
7192,"        public IRubyObject nsWait(ThreadContext context, IRubyObject[] args) {
            Ruby runtime = context.runtime;
            if (args.length > 1) {
                throw runtime.newArgumentError(args.length, 1);
            }
            Double timeout = null;
            if (args.length > 0 && !args[0].isNil()) {
                timeout = args[0].convertToFloat().getDoubleValue();
                if (timeout < 0) {
                    throw runtime.newArgumentError(""time interval must be positive"");
                }
            }
            if (Thread.interrupted()) {
                throw runtime.newConcurrencyError(""thread interrupted"");
            }
            boolean success = false;
            try {
                success = context.getThread().wait_timeout(this, timeout);
            } catch (InterruptedException ie) {
                throw runtime.newConcurrencyError(ie.getLocalizedMessage());
            } finally {
                // An interrupt or timeout may have caused us to miss
                // a notify that we consumed, so do another notify in
                // case someone else is available to pick it up.
                if (!success) {
                    this.notify();
                }
            }
            return this;
        }"
7193,"        public IRubyObject nsSignal(ThreadContext context) {
            notify();
            return this;
        }"
7194,"        public IRubyObject nsBroadcast(ThreadContext context) {
            notifyAll();
            return this;
        }"
7195,"        public static IRubyObject sleepInterruptibly(final ThreadContext context, IRubyObject receiver, final Block block) {
            try {
                context.getThread().executeBlockingTask(new RubyThread.BlockingTask() {
                    @Override
                    public void run() throws InterruptedException {
                        block.call(context);
                    }

                    @Override
                    public void wakeup() {
                        context.getThread().getNativeThread().interrupt();
                    }
                });
            } catch (InterruptedException e) {
                throw context.runtime.newThreadError(""interrupted in Concurrent::Synchronization::JRuby.sleep_interruptibly"");
            }
            return context.nil;
        }"
7196,"                    public void run() throws InterruptedException {
                        block.call(context);
                    }"
7197,"                    public void wakeup() {
                        context.getThread().getNativeThread().interrupt();
                    }"
7198,"    public interface Fun<A,T> { T apply(A a); }
    /** Interface describing a function of two arguments */
    public interface BiFun<A,B,T> { T apply(A a, B b); }

    public V get(K key);
    public V put(K key, V value);
    public V putIfAbsent(K key, V value);
    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7199,"    public interface BiFun<A,B,T> { T apply(A a, B b); }

    public V get(K key);
    public V put(K key, V value);
    public V putIfAbsent(K key, V value);
    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7200,"    public V get(K key);
    public V put(K key, V value);
    public V putIfAbsent(K key, V value);
    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7201,"    public V put(K key, V value);
    public V putIfAbsent(K key, V value);
    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7202,"    public V putIfAbsent(K key, V value);
    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7203,"    public V computeIfAbsent(K key, Fun<? super K, ? extends V> mf);
    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7204,"    public V computeIfPresent(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7205,"    public V compute(K key, BiFun<? super K, ? super V, ? extends V> mf);
    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7206,"    public V merge(K key, V value, BiFun<? super V, ? super V, ? extends V> mf);
    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7207,"    public boolean replace(K key, V oldVal, V newVal);
    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7208,"    public V replace(K key, V value);
    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7209,"    public boolean containsKey(K key);
    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7210,"    public boolean remove(Object key, Object value);
    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7211,"    public V remove(K key);
    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7212,"    public void clear();
    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7213,"    public Set<Map.Entry<K,V>> entrySet();
    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7214,"    public int size();
    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7215,"    public V getValueOrDefault(Object key, V defaultValue);

    public boolean containsValue(V value);
    public K findKey(V value);
}"
7216,"    public boolean containsValue(V value);
    public K findKey(V value);
}"
7217,"    public K findKey(V value);
}"
7218,"        Spliterator<T> split();
    }


    /*
     * Overview:
     *
     * The primary design goal of this hash table is to maintain
     * concurrent readability (typically method get(), but also
     * iterators and related methods) while minimizing update
     * contention. Secondary goals are to keep space consumption about
     * the same or better than java.util.HashMap, and to support high
     * initial insertion rates on an empty table by many threads.
     *
     * Each key-value mapping is held in a Node.  Because Node fields
     * can contain special values, they are defined using plain Object
     * types. Similarly in turn, all internal methods that use them
     * work off Object types. And similarly, so do the internal
     * methods of auxiliary iterator and view classes.  All public
     * generic typed methods relay in/out of these internal methods,
     * supplying null-checks and casts as needed. This also allows
     * many of the public methods to be factored into a smaller number
     * of internal methods (although sadly not so for the five
     * variants of put-related operations). The validation-based
     * approach explained below leads to a lot of code sprawl because
     * retry-control precludes factoring into smaller methods.
     *
     * The table is lazily initialized to a power-of-two size upon the
     * first insertion.  Each bin in the table normally contains a
     * list of Nodes (most often, the list has only zero or one Node).
     * Table accesses require volatile/atomic reads, writes, and
     * CASes.  Because there is no other way to arrange this without
     * adding further indirections, we use intrinsics
     * (sun.misc.Unsafe) operations.  The lists of nodes within bins
     * are always accurately traversable under volatile reads, so long
     * as lookups check hash code and non-nullness of value before
     * checking key equality.
     *
     * We use the top two bits of Node hash fields for control
     * purposes -- they are available anyway because of addressing
     * constraints.  As explained further below, these top bits are
     * used as follows:
     *  00 - Normal
     *  01 - Locked
     *  11 - Locked and may have a thread waiting for lock
     *  10 - Node is a forwarding node
     *
     * The lower 30 bits of each Node's hash field contain a
     * transformation of the key's hash code, except for forwarding
     * nodes, for which the lower bits are zero (and so always have
     * hash field == MOVED).
     *
     * Insertion (via put or its variants) of the first node in an
     * empty bin is performed by just CASing it to the bin.  This is
     * by far the most common case for put operations under most
     * key/hash distributions.  Other update operations (insert,
     * delete, and replace) require locks.  We do not want to waste
     * the space required to associate a distinct lock object with
     * each bin, so instead use the first node of a bin list itself as
     * a lock. Blocking support for these locks relies on the builtin
     * ""synchronized"" monitors.  However, we also need a tryLock
     * construction, so we overlay these by using bits of the Node
     * hash field for lock control (see above), and so normally use
     * builtin monitors only for blocking and signalling using
     * wait/notifyAll constructions. See Node.tryAwaitLock.
     *
     * Using the first node of a list as a lock does not by itself
     * suffice though: When a node is locked, any update must first
     * validate that it is still the first node after locking it, and
     * retry if not. Because new nodes are always appended to lists,
     * once a node is first in a bin, it remains first until deleted
     * or the bin becomes invalidated (upon resizing).  However,
     * operations that only conditionally update may inspect nodes
     * until the point of update. This is a converse of sorts to the
     * lazy locking technique described by Herlihy & Shavit.
     *
     * The main disadvantage of per-bin locks is that other update
     * operations on other nodes in a bin list protected by the same
     * lock can stall, for example when user equals() or mapping
     * functions take a long time.  However, statistically, under
     * random hash codes, this is not a common problem.  Ideally, the
     * frequency of nodes in bins follows a Poisson distribution
     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
     * parameter of about 0.5 on average, given the resizing threshold
     * of 0.75, although with a large variance because of resizing
     * granularity. Ignoring variance, the expected occurrences of
     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The
     * first values are:
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: less than 1 in ten million
     *
     * Lock contention probability for two threads accessing distinct
     * elements is roughly 1 / (8 * #elements) under random hashes.
     *
     * Actual hash code distributions encountered in practice
     * sometimes deviate significantly from uniform randomness.  This
     * includes the case when N > (1<<30), so some keys MUST collide.
     * Similarly for dumb or hostile usages in which multiple keys are
     * designed to have identical hash codes. Also, although we guard
     * against the worst effects of this (see method spread), sets of
     * hashes may differ only in bits that do not impact their bin
     * index for a given power-of-two mask.  So we use a secondary
     * strategy that applies when the number of nodes in a bin exceeds
     * a threshold, and at least one of the keys implements
     * Comparable.  These TreeBins use a balanced tree to hold nodes
     * (a specialized form of red-black trees), bounding search time
     * to O(log N).  Each search step in a TreeBin is around twice as
     * slow as in a regular list, but given that N cannot exceed
     * (1<<64) (before running out of addresses) this bounds search
     * steps, lock hold times, etc, to reasonable constants (roughly
     * 100 nodes inspected per operation worst case) so long as keys
     * are Comparable (which is very common -- String, Long, etc).
     * TreeBin nodes (TreeNodes) also maintain the same ""next""
     * traversal pointers as regular nodes, so can be traversed in
     * iterators in the same way.
     *
     * The table is resized when occupancy exceeds a percentage
     * threshold (nominally, 0.75, but see below).  Only a single
     * thread performs the resize (using field ""sizeCtl"", to arrange
     * exclusion), but the table otherwise remains usable for reads
     * and updates. Resizing proceeds by transferring bins, one by
     * one, from the table to the next table.  Because we are using
     * power-of-two expansion, the elements from each bin must either
     * stay at same index, or move with a power of two offset. We
     * eliminate unnecessary node creation by catching cases where old
     * nodes can be reused because their next fields won't change.  On
     * average, only about one-sixth of them need cloning when a table
     * doubles. The nodes they replace will be garbage collectable as
     * soon as they are no longer referenced by any reader thread that
     * may be in the midst of concurrently traversing table.  Upon
     * transfer, the old table bin contains only a special forwarding
     * node (with hash field ""MOVED"") that contains the next table as
     * its key. On encountering a forwarding node, access and update
     * operations restart, using the new table.
     *
     * Each bin transfer requires its bin lock. However, unlike other
     * cases, a transfer can skip a bin if it fails to acquire its
     * lock, and revisit it later (unless it is a TreeBin). Method
     * rebuild maintains a buffer of TRANSFER_BUFFER_SIZE bins that
     * have been skipped because of failure to acquire a lock, and
     * blocks only if none are available (i.e., only very rarely).
     * The transfer operation must also ensure that all accessible
     * bins in both the old and new table are usable by any traversal.
     * When there are no lock acquisition failures, this is arranged
     * simply by proceeding from the last bin (table.length - 1) up
     * towards the first.  Upon seeing a forwarding node, traversals
     * (see class Iter) arrange to move to the new table
     * without revisiting nodes.  However, when any node is skipped
     * during a transfer, all earlier table bins may have become
     * visible, so are initialized with a reverse-forwarding node back
     * to the old table until the new ones are established. (This
     * sometimes requires transiently locking a forwarding node, which
     * is possible under the above encoding.) These more expensive
     * mechanics trigger only when necessary.
     *
     * The traversal scheme also applies to partial traversals of
     * ranges of bins (via an alternate Traverser constructor)
     * to support partitioned aggregate operations.  Also, read-only
     * operations give up if ever forwarded to a null table, which
     * provides support for shutdown-style clearing, which is also not
     * currently implemented.
     *
     * Lazy table initialization minimizes footprint until first use,
     * and also avoids resizings when the first operation is from a
     * putAll, constructor with map argument, or deserialization.
     * These cases attempt to override the initial capacity settings,
     * but harmlessly fail to take effect in cases of races.
     *
     * The element count is maintained using a LongAdder, which avoids
     * contention on updates but can encounter cache thrashing if read
     * too frequently during concurrent access. To avoid reading so
     * often, resizing is attempted either when a bin lock is
     * contended, or upon adding to a bin already holding two or more
     * nodes (checked before adding in the xIfAbsent methods, after
     * adding in others). Under uniform hash distributions, the
     * probability of this occurring at threshold is around 13%,
     * meaning that only about 1 in 8 puts check threshold (and after
     * resizing, many fewer do so). But this approximation has high
     * variance for small table sizes, so we check on any collision
     * for sizes <= 64. The bulk putAll operation further reduces
     * contention by only committing count updates upon these size
     * checks.
     *
     * Maintaining API and serialization compatibility with previous
     * versions of this class introduces several oddities. Mainly: We
     * leave untouched but unused constructor arguments refering to
     * concurrencyLevel. We accept a loadFactor constructor argument,
     * but apply it only to initial table capacity (which is the only
     * time that we can guarantee to honor it.) We also declare an
     * unused ""Segment"" class that is instantiated in minimal form
     * only when serializing.
     */

    /* ---------------- Constants -------------- */

    /**
     * The largest possible table capacity.  This value must be
     * exactly 1<<30 to stay within Java array allocation and indexing
     * bounds for power of two table sizes, and is further required
     * because the top two bits of 32bit hash fields are used for
     * control purposes.
     */
    private static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * The default initial table capacity.  Must be a power of 2
     * (i.e., at least 1) and at most MAXIMUM_CAPACITY.
     */
    private static final int DEFAULT_CAPACITY = 16;

    /**
     * The largest possible (non-power of two) array size.
     * Needed by toArray and related methods.
     */
    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * The default concurrency level for this table. Unused but
     * defined for compatibility with previous versions of this class.
     */
    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;

    /**
     * The load factor for this table. Overrides of this value in
     * constructors affect only the initial table capacity.  The
     * actual floating point value isn't normally used -- it is
     * simpler to use expressions such as {@code n - (n >>> 2)} for
     * the associated resizing threshold.
     */
    private static final float LOAD_FACTOR = 0.75f;

    /**
     * The buffer size for skipped bins during transfers. The
     * value is arbitrary but should be large enough to avoid
     * most locking stalls during resizes.
     */
    private static final int TRANSFER_BUFFER_SIZE = 32;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  The value reflects the approximate break-even point for
     * using tree-based operations.
     * Note that Doug's version defaults to 8, but when dealing with
     * Ruby objects it is actually beneficial to avoid TreeNodes
     * as long as possible as it usually means going into Ruby land.
     */
    private static final int TREE_THRESHOLD = 16;

    /*
     * Encodings for special uses of Node hash fields. See above for
     * explanation.
     */
    static final int MOVED     = 0x80000000; // hash field for forwarding nodes
    static final int LOCKED    = 0x40000000; // set/tested only as a bit
    static final int WAITING   = 0xc0000000; // both bits set/tested together
    static final int HASH_BITS = 0x3fffffff; // usable bits of normal node hash

    /* ---------------- Fields -------------- */

    /**
     * The array of bins. Lazily initialized upon first insertion.
     * Size is always a power of two. Accessed directly by iterators.
     */
    transient volatile Node[] table;

    /**
     * The counter maintaining number of elements.
     */
    private transient final LongAdder counter;

    /**
     * Table initialization and resizing control.  When negative, the
     * table is being initialized or resized. Otherwise, when table is
     * null, holds the initial table size to use upon creation, or 0
     * for default. After initialization, holds the next element count
     * value upon which to resize the table.
     */
    private transient volatile int sizeCtl;

    // views
    private transient KeySetView<K,V> keySet;
    private transient ValuesView<K,V> values;
    private transient EntrySetView<K,V> entrySet;

    /** For serialization compatibility. Null unless serialized; see below */
    private Segment<K,V>[] segments;

    /* ---------------- Table element access -------------- */

    /*
     * Volatile access methods are used for table elements as well as
     * elements of in-progress next table while resizing.  Uses are
     * null checked by callers, and implicitly bounds-checked, relying
     * on the invariants that tab arrays have non-zero size, and all
     * indices are masked with (tab.length - 1) which is never
     * negative and always less than length. Note that, to be correct
     * wrt arbitrary concurrency errors by users, bounds checks must
     * operate on local variables, which accounts for some odd-looking
     * inline assignments below.
     */

    static final Node tabAt(Node[] tab, int i) { // used by Iter
        return (Node)UNSAFE.getObjectVolatile(tab, ((long)i<<ASHIFT)+ABASE);
    }

    private static final boolean casTabAt(Node[] tab, int i, Node c, Node v) {
        return UNSAFE.compareAndSwapObject(tab, ((long)i<<ASHIFT)+ABASE, c, v);
    }

    private static final void setTabAt(Node[] tab, int i, Node v) {
        UNSAFE.putObjectVolatile(tab, ((long)i<<ASHIFT)+ABASE, v);
    }

    /* ---------------- Nodes -------------- */

    /**
     * Key-value entry. Note that this is never exported out as a
     * user-visible Map.Entry (see MapEntry below). Nodes with a hash
     * field of MOVED are special, and do not contain user keys or
     * values.  Otherwise, keys are never null, and null val fields
     * indicate that a node is in the process of being deleted or
     * created. For purposes of read-only access, a key may be read
     * before a val, but can only be used after checking val to be
     * non-null.
     */
    static class Node {
        volatile int hash;
        final Object key;
        volatile Object val;
        volatile Node next;

        Node(int hash, Object key, Object val, Node next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }

        /** CompareAndSet the hash field */
        final boolean casHash(int cmp, int val) {
            return UNSAFE.compareAndSwapInt(this, hashOffset, cmp, val);
        }

        /** The number of spins before blocking for a lock */
        static final int MAX_SPINS =
                Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

        /**
         * Spins a while if LOCKED bit set and this node is the first
         * of its bin, and then sets WAITING bits on hash field and
         * blocks (once) if they are still set.  It is OK for this
         * method to return even if lock is not available upon exit,
         * which enables these simple single-wait mechanics.
         *
         * The corresponding signalling operation is performed within
         * callers: Upon detecting that WAITING has been set when
         * unlocking lock (via a failed CAS from non-waiting LOCKED
         * state), unlockers acquire the sync lock and perform a
         * notifyAll.
         *
         * The initial sanity check on tab and bounds is not currently
         * necessary in the only usages of this method, but enables
         * use in other future contexts.
         */
        final void tryAwaitLock(Node[] tab, int i) {
            if (tab != null && i >= 0 && i < tab.length) { // sanity check
                int r = ThreadLocalRandom.current().nextInt(); // randomize spins
                int spins = MAX_SPINS, h;
                while (tabAt(tab, i) == this && ((h = hash) & LOCKED) != 0) {
                    if (spins >= 0) {
                        r ^= r << 1; r ^= r >>> 3; r ^= r << 10; // xorshift
                        if (r >= 0 && --spins == 0)
                            Thread.yield();  // yield before block
                    }
                    else if (casHash(h, h | WAITING)) {
                        synchronized (this) {
                            if (tabAt(tab, i) == this &&
                                    (hash & WAITING) == WAITING) {
                                try {
                                    wait();
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                }
                            }
                            else
                                notifyAll(); // possibly won race vs signaller
                        }
                        break;
                    }
                }
            }
        }

        // Unsafe mechanics for casHash
        private static final sun.misc.Unsafe UNSAFE;
        private static final long hashOffset;

        static {
            try {
                UNSAFE = getUnsafe();
                Class<?> k = Node.class;
                hashOffset = UNSAFE.objectFieldOffset
                        (k.getDeclaredField(""hash""));
            } catch (Exception e) {
                throw new Error(e);
            }
        }
    }

    /* ---------------- TreeBins -------------- */

    /**
     * Nodes for use in TreeBins
     */
    static final class TreeNode extends Node {
        TreeNode parent;  // red-black tree links
        TreeNode left;
        TreeNode right;
        TreeNode prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, Object key, Object val, Node next, TreeNode parent) {
            super(hash, key, val, next);
            this.parent = parent;
        }
    }

    /**
     * A specialized form of red-black tree for use in bins
     * whose size exceeds a threshold.
     *
     * TreeBins use a special form of comparison for search and
     * related operations (which is the main reason we cannot use
     * existing collections such as TreeMaps). TreeBins contain
     * Comparable elements, but may contain others, as well as
     * elements that are Comparable but not necessarily Comparable<T>
     * for the same T, so we cannot invoke compareTo among them. To
     * handle this, the tree is ordered primarily by hash value, then
     * by getClass().getName() order, and then by Comparator order
     * among elements of the same class.  On lookup at a node, if
     * elements are not comparable or compare as 0, both left and
     * right children may need to be searched in the case of tied hash
     * values. (This corresponds to the full list search that would be
     * necessary if all elements were non-Comparable and had tied
     * hashes.)  The red-black balancing code is updated from
     * pre-jdk-collections
     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)
     * based in turn on Cormen, Leiserson, and Rivest ""Introduction to
     * Algorithms"" (CLR).
     *
     * TreeBins also maintain a separate locking discipline than
     * regular bins. Because they are forwarded via special MOVED
     * nodes at bin heads (which can never change once established),
     * we cannot use those nodes as locks. Instead, TreeBin
     * extends AbstractQueuedSynchronizer to support a simple form of
     * read-write lock. For update operations and table validation,
     * the exclusive form of lock behaves in the same way as bin-head
     * locks. However, lookups use shared read-lock mechanics to allow
     * multiple readers in the absence of writers.  Additionally,
     * these lookups do not ever block: While the lock is not
     * available, they proceed along the slow traversal path (via
     * next-pointers) until the lock becomes available or the list is
     * exhausted, whichever comes first. (These cases are not fast,
     * but maximize aggregate expected throughput.)  The AQS mechanics
     * for doing this are straightforward.  The lock state is held as
     * AQS getState().  Read counts are negative; the write count (1)
     * is positive.  There are no signalling preferences among readers
     * and writers. Since we don't need to export full Lock API, we
     * just override the minimal AQS methods and use them directly.
     */
    static final class TreeBin extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 2249069246763182397L;
        transient TreeNode root;  // root of tree
        transient TreeNode first; // head of next-pointer list

        /* AQS overrides */
        public final boolean isHeldExclusively() { return getState() > 0; }
        public final boolean tryAcquire(int ignore) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        public final boolean tryRelease(int ignore) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        public final int tryAcquireShared(int ignore) {
            for (int c;;) {
                if ((c = getState()) > 0)
                    return -1;
                if (compareAndSetState(c, c -1))
                    return 1;
            }
        }
        public final boolean tryReleaseShared(int ignore) {
            int c;
            do {} while (!compareAndSetState(c = getState(), c + 1));
            return c == -1;
        }

        /** From CLR */
        private void rotateLeft(TreeNode p) {
            if (p != null) {
                TreeNode r = p.right, pp, rl;
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                if ((pp = r.parent = p.parent) == null)
                    root = r;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
        }

        /** From CLR */
        private void rotateRight(TreeNode p) {
            if (p != null) {
                TreeNode l = p.left, pp, lr;
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent) == null)
                    root = l;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
        }

        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, Object k, TreeNode p) {
            return getTreeNode(h, (RubyObject)k, p);
        }

        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, RubyObject k, TreeNode p) {
            RubyClass c = k.getMetaClass(); boolean kNotComparable = !k.respondsTo(""<=>"");
            while (p != null) {
                int dir, ph;  RubyObject pk; RubyClass pc;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = (RubyClass)pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pl, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            // try to continue iterating on the left side
                            else if ((pl = p.left) != null && h <= pl.hash)
                                dir = -1;
                            else // no matching node found
                                return null;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                p = (dir > 0) ? p.right : p.left;
            }
            return null;
        }

        int rubyCompare(RubyObject l, RubyObject r) {
            ThreadContext context = l.getMetaClass().getRuntime().getCurrentContext();
            IRubyObject result;
            try {
                result = l.callMethod(context, ""<=>"", r);
            } catch (RaiseException e) {
                // handle objects ""lying"" about responding to <=>, ie: an Array containing non-comparable keys
                if (context.runtime.getNoMethodError().isInstance(e.getException())) {
                    return 0;
                }
                throw e;
            }

            return result.isNil() ? 0 : RubyNumeric.num2int(result.convertToInteger());
        }

        /**
         * Wrapper for getTreeNode used by CHM.get. Tries to obtain
         * read-lock to call getTreeNode, but during failure to get
         * lock, searches along next links.
         */
        final Object getValue(int h, Object k) {
            Node r = null;
            int c = getState(); // Must read lock state first
            for (Node e = first; e != null; e = e.next) {
                if (c <= 0 && compareAndSetState(c, c - 1)) {
                    try {
                        r = getTreeNode(h, k, root);
                    } finally {
                        releaseShared(0);
                    }
                    break;
                }
                else if ((e.hash & HASH_BITS) == h && k.equals(e.key)) {
                    r = e;
                    break;
                }
                else
                    c = getState();
            }
            return r == null ? null : r.val;
        }

        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
                (int h, Object k, Object v) {
            return putTreeNode(h, (RubyObject)k, v);
        }

        /**
         * Finds or adds a node.
         * @return null if added
         */
        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
        (int h, RubyObject k, Object v) {
            RubyClass c = k.getMetaClass();
            boolean kNotComparable = !k.respondsTo(""<=>"");
            TreeNode pp = root, p = null;
            int dir = 0;
            while (pp != null) { // find existing node or leaf to insert at
                int ph;  RubyObject pk; RubyClass pc;
                p = pp;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            else // continue descending down the left subtree
                                dir = -1;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                pp = (dir > 0) ? p.right : p.left;
            }

            TreeNode f = first;
            TreeNode x = first = new TreeNode(h, (Object)k, v, f, p);
            if (p == null)
                root = x;
            else { // attach and rebalance; adapted from CLR
                TreeNode xp, xpp;
                if (f != null)
                    f.prev = x;
                if (dir <= 0)
                    p.left = x;
                else
                    p.right = x;
                x.red = true;
                while (x != null && (xp = x.parent) != null && xp.red &&
                        (xpp = xp.parent) != null) {
                    TreeNode xppl = xpp.left;
                    if (xp == xppl) {
                        TreeNode y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }
                    else {
                        TreeNode y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }
                }
                TreeNode r = root;
                if (r != null && r.red)
                    r.red = false;
            }
            return null;
        }

        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by ""next"" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         */
        final void deleteTreeNode(TreeNode p) {
            TreeNode next = (TreeNode)p.next; // unlink traversal pointers
            TreeNode pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode replacement;
            TreeNode pl = p.left;
            TreeNode pr = p.right;
            if (pl != null && pr != null) {
                TreeNode s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode sr = s.right;
                TreeNode pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode x = replacement;
                while (x != null) {
                    TreeNode xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                    (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ? null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                    (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ? null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers
                    pp.left = null;
                else if (p == pp.right)
                    pp.right = null;
                p.parent = null;
            }
        }
    }

    /* ---------------- Collision reduction methods -------------- */

    /**
     * Spreads higher bits to lower, and also forces top 2 bits to 0.
     * Because the table uses power-of-two masking, sets of hashes
     * that vary only in bits above the current mask will always
     * collide. (Among known examples are sets of Float keys holding
     * consecutive whole numbers in small tables.)  To counter this,
     * we apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed across bits (so don't benefit
     * from spreading), and because we use trees to handle large sets
     * of collisions in bins, we don't need excessively high quality.
     */
    private static final int spread(int h) {
        h ^= (h >>> 18) ^ (h >>> 12);
        return (h ^ (h >>> 10)) & HASH_BITS;
    }

    /**
     * Replaces a list bin with a tree bin. Call only when locked.
     * Fails to replace if the given key is non-comparable or table
     * is, or needs, resizing.
     */
    private final void replaceWithTreeBin(Node[] tab, int index, Object key) {
        if ((key instanceof Comparable) &&
                (tab.length >= MAXIMUM_CAPACITY || counter.sum() < (long)sizeCtl)) {
            TreeBin t = new TreeBin();
            for (Node e = tabAt(tab, index); e != null; e = e.next)
                t.putTreeNode(e.hash & HASH_BITS, e.key, e.val);
            setTabAt(tab, index, new Node(MOVED, t, null, null));
        }
    }

    /* ---------------- Internal access and update methods -------------- */

    /** Implementation for get and containsKey */
    private final Object internalGet(Object k) {
        int h = spread(k.hashCode());
        retry: for (Node[] tab = table; tab != null;) {
            Node e, p; Object ek, ev; int eh;      // locals to read fields once
            for (e = tabAt(tab, (tab.length - 1) & h); e != null; e = e.next) {
                if ((eh = e.hash) == MOVED) {
                    if ((ek = e.key) instanceof TreeBin)  // search TreeBin
                        return ((TreeBin)ek).getValue(h, k);
                    else {                        // restart with new table
                        tab = (Node[])ek;
                        continue retry;
                    }
                }
                else if ((eh & HASH_BITS) == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                    return ev;
            }
            break;
        }
        return null;
    }

    /**
     * Implementation for the four public remove/replace methods:
     * Replaces node value with v, conditional upon match of cv if
     * non-null.  If resulting value is null, delete.
     */
    private final Object internalReplace(Object k, Object v, Object cv) {
        int h = spread(k.hashCode());
        Object oldVal = null;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null ||
                    (f = tabAt(tab, i = (tab.length - 1) & h)) == null)
                break;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    boolean deleted = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null) {
                                Object pv = p.val;
                                if (cv == null || cv == pv || cv.equals(pv)) {
                                    oldVal = pv;
                                    if ((p.val = v) == null) {
                                        deleted = true;
                                        t.deleteTreeNode(p);
                                    }
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (validated) {
                        if (deleted)
                            counter.add(-1L);
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) != h && f.next == null) // precheck
                break;                          // rules out possible existence
            else if ((fh & LOCKED) != 0) {
                checkForResize();               // try resizing if can't get lock
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                boolean validated = false;
                boolean deleted = false;
                try {
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        for (Node e = f, pred = null;;) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    ((ev = e.val) != null) &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                if (cv == null || cv == ev || cv.equals(ev)) {
                                    oldVal = ev;
                                    if ((e.val = v) == null) {
                                        deleted = true;
                                        Node en = e.next;
                                        if (pred != null)
                                            pred.next = en;
                                        else
                                            setTabAt(tab, i, en);
                                    }
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (validated) {
                    if (deleted)
                        counter.add(-1L);
                    break;
                }
            }
        }
        return oldVal;
    }

    /*
     * Internal versions of the six insertion methods, each a
     * little more complicated than the last. All have
     * the same basic structure as the first (internalPut):
     *  1. If table uninitialized, create
     *  2. If bin empty, try to CAS new node
     *  3. If bin stale, use new table
     *  4. if bin converted to TreeBin, validate and relay to TreeBin methods
     *  5. Lock and validate; if valid, scan and add or update
     *
     * The others interweave other checks and/or alternative actions:
     *  * Plain put checks for and performs resize after insertion.
     *  * putIfAbsent prescans for mapping without lock (and fails to add
     *    if present), which also makes pre-emptive resize checks worthwhile.
     *  * computeIfAbsent extends form used in putIfAbsent with additional
     *    mechanics to deal with, calls, potential exceptions and null
     *    returns from function call.
     *  * compute uses the same function-call mechanics, but without
     *    the prescans
     *  * merge acts as putIfAbsent in the absent case, but invokes the
     *    update function if present
     *  * putAll attempts to pre-allocate enough table space
     *    and more lazily performs count updates and checks.
     *
     * Someday when details settle down a bit more, it might be worth
     * some factoring to reduce sprawl.
     */

    /** Implementation for put */
    private final Object internalPut(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null) {
                                oldVal = p.val;
                                p.val = v;
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                Object oldVal = null;
                try {                        // needed in case equals() throws
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                oldVal = ev;
                                e.val = v;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                last.next = new Node(h, k, v, null);
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {                  // unlock and signal if needed
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (oldVal != null)
                        return oldVal;
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }

    /** Implementation for putIfAbsent */
    private final Object internalPutIfAbsent(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null)
                                oldVal = p.val;
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) { // at least 2 nodes -- search and maybe resize
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    Object oldVal = null;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    oldVal = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    last.next = new Node(h, k, v, null);
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }

    /** Implementation for computeIfAbsent */
    private final Object internalComputeIfAbsent(K k,
                                                 Fun<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.apply(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.apply(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val != null) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for compute */
    @SuppressWarnings(""unchecked"") private final Object internalCompute
    (K k, boolean onlyIfPresent, BiFun<? super K, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.apply(k, null)) != null) {
                            node.val = val;
                            delta = 1;
                        }
                    } finally {
                        if (delta == 0)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv;
                            if (p == null) {
                                if (onlyIfPresent)
                                    break;
                                pv = null;
                            } else
                                pv = p.val;
                            if ((val = mf.apply(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent && (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node(h, k, val, null);
                                    delta = 1;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for merge */
    @SuppressWarnings(""unchecked"") private final Object internalMerge
    (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply((V)p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply((V)ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node(h, k, val, null);
                                delta = 1;
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for putAll */
    private final void internalPutAll(Map<?, ?> m) {
        tryPresize(m.size());
        long delta = 0L;     // number of uncommitted additions
        boolean npe = false; // to throw exception on exit for nulls
        try {                // to clean up counts on other exceptions
            for (Map.Entry<?, ?> entry : m.entrySet()) {
                Object k, v;
                if (entry == null || (k = entry.getKey()) == null ||
                        (v = entry.getValue()) == null) {
                    npe = true;
                    break;
                }
                int h = spread(k.hashCode());
                for (Node[] tab = table;;) {
                    int i; Node f; int fh; Object fk;
                    if (tab == null)
                        tab = initTable();
                    else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null){
                        if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                            ++delta;
                            break;
                        }
                    }
                    else if ((fh = f.hash) == MOVED) {
                        if ((fk = f.key) instanceof TreeBin) {
                            TreeBin t = (TreeBin)fk;
                            boolean validated = false;
                            t.acquire(0);
                            try {
                                if (tabAt(tab, i) == f) {
                                    validated = true;
                                    TreeNode p = t.getTreeNode(h, k, t.root);
                                    if (p != null)
                                        p.val = v;
                                    else {
                                        t.putTreeNode(h, k, v);
                                        ++delta;
                                    }
                                }
                            } finally {
                                t.release(0);
                            }
                            if (validated)
                                break;
                        }
                        else
                            tab = (Node[])fk;
                    }
                    else if ((fh & LOCKED) != 0) {
                        counter.add(delta);
                        delta = 0L;
                        checkForResize();
                        f.tryAwaitLock(tab, i);
                    }
                    else if (f.casHash(fh, fh | LOCKED)) {
                        int count = 0;
                        try {
                            if (tabAt(tab, i) == f) {
                                count = 1;
                                for (Node e = f;; ++count) {
                                    Object ek, ev;
                                    if ((e.hash & HASH_BITS) == h &&
                                            (ev = e.val) != null &&
                                            ((ek = e.key) == k || k.equals(ek))) {
                                        e.val = v;
                                        break;
                                    }
                                    Node last = e;
                                    if ((e = e.next) == null) {
                                        ++delta;
                                        last.next = new Node(h, k, v, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                        break;
                                    }
                                }
                            }
                        } finally {
                            if (!f.casHash(fh | LOCKED, fh)) {
                                f.hash = fh;
                                synchronized (f) { f.notifyAll(); };
                            }
                        }
                        if (count != 0) {
                            if (count > 1) {
                                counter.add(delta);
                                delta = 0L;
                                checkForResize();
                            }
                            break;
                        }
                    }
                }
            }
        } finally {
            if (delta != 0)
                counter.add(delta);
        }
        if (npe)
            throw new NullPointerException();
    }

    /* ---------------- Table Initialization and Resizing -------------- */

    /**
     * Returns a power of two table size for the given desired capacity.
     * See Hackers Delight, sec 3.2
     */
    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

    /**
     * Initializes table, using the size recorded in sizeCtl.
     */
    private final Node[] initTable() {
        Node[] tab; int sc;
        while ((tab = table) == null) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                try {
                    if ((tab = table) == null) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        tab = table = new Node[n];
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }

    /**
     * If table is too small and not already resizing, creates next
     * table and transfers bins.  Rechecks occupancy after a transfer
     * to see if another resize is already needed because resizings
     * are lagging additions.
     */
    private final void checkForResize() {
        Node[] tab; int n, sc;
        while ((tab = table) != null &&
                (n = tab.length) < MAXIMUM_CAPACITY &&
                (sc = sizeCtl) >= 0 && counter.sum() >= (long)sc &&
                UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
            try {
                if (tab == table) {
                    table = rebuild(tab);
                    sc = (n << 1) - (n >>> 1);
                }
            } finally {
                sizeCtl = sc;
            }
        }
    }

    /**
     * Tries to presize table to accommodate the given number of elements.
     *
     * @param size number of elements (doesn't need to be perfectly accurate)
     */
    private final void tryPresize(int size) {
        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
                tableSizeFor(size + (size >>> 1) + 1);
        int sc;
        while ((sc = sizeCtl) >= 0) {
            Node[] tab = table; int n;
            if (tab == null || (n = tab.length) == 0) {
                n = (sc > c) ? sc : c;
                if (UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                    try {
                        if (table == tab) {
                            table = new Node[n];
                            sc = n - (n >>> 2);
                        }
                    } finally {
                        sizeCtl = sc;
                    }
                }
            }
            else if (c <= sc || n >= MAXIMUM_CAPACITY)
                break;
            else if (UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                try {
                    if (table == tab) {
                        table = rebuild(tab);
                        sc = (n << 1) - (n >>> 1);
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
    }

    /*
     * Moves and/or copies the nodes in each bin to new table. See
     * above for explanation.
     *
     * @return the new table
     */
    private static final Node[] rebuild(Node[] tab) {
        int n = tab.length;
        Node[] nextTab = new Node[n << 1];
        Node fwd = new Node(MOVED, nextTab, null, null);
        int[] buffer = null;       // holds bins to revisit; null until needed
        Node rev = null;           // reverse forwarder; null until needed
        int nbuffered = 0;         // the number of bins in buffer list
        int bufferIndex = 0;       // buffer index of current buffered bin
        int bin = n - 1;           // current non-buffered bin or -1 if none

        for (int i = bin;;) {      // start upwards sweep
            int fh; Node f;
            if ((f = tabAt(tab, i)) == null) {
                if (bin >= 0) {    // Unbuffered; no lock needed (or available)
                    if (!casTabAt(tab, i, f, fwd))
                        continue;
                }
                else {             // transiently use a locked forwarding node
                    Node g = new Node(MOVED|LOCKED, nextTab, null, null);
                    if (!casTabAt(tab, i, f, g))
                        continue;
                    setTabAt(nextTab, i, null);
                    setTabAt(nextTab, i + n, null);
                    setTabAt(tab, i, fwd);
                    if (!g.casHash(MOVED|LOCKED, MOVED)) {
                        g.hash = MOVED;
                        synchronized (g) { g.notifyAll(); }
                    }
                }
            }
            else if ((fh = f.hash) == MOVED) {
                Object fk = f.key;
                if (fk instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            splitTreeBin(nextTab, i, t);
                            setTabAt(tab, i, fwd);
                        }
                    } finally {
                        t.release(0);
                    }
                    if (!validated)
                        continue;
                }
            }
            else if ((fh & LOCKED) == 0 && f.casHash(fh, fh|LOCKED)) {
                boolean validated = false;
                try {              // split to lo and hi lists; copying as needed
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        splitBin(nextTab, i, f);
                        setTabAt(tab, i, fwd);
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (!validated)
                    continue;
            }
            else {
                if (buffer == null) // initialize buffer for revisits
                    buffer = new int[TRANSFER_BUFFER_SIZE];
                if (bin < 0 && bufferIndex > 0) {
                    int j = buffer[--bufferIndex];
                    buffer[bufferIndex] = i;
                    i = j;         // swap with another bin
                    continue;
                }
                if (bin < 0 || nbuffered >= TRANSFER_BUFFER_SIZE) {
                    f.tryAwaitLock(tab, i);
                    continue;      // no other options -- block
                }
                if (rev == null)   // initialize reverse-forwarder
                    rev = new Node(MOVED, tab, null, null);
                if (tabAt(tab, i) != f || (f.hash & LOCKED) == 0)
                    continue;      // recheck before adding to list
                buffer[nbuffered++] = i;
                setTabAt(nextTab, i, rev);     // install place-holders
                setTabAt(nextTab, i + n, rev);
            }

            if (bin > 0)
                i = --bin;
            else if (buffer != null && nbuffered > 0) {
                bin = -1;
                i = buffer[bufferIndex = --nbuffered];
            }
            else
                return nextTab;
        }
    }

    /**
     * Splits a normal bin with list headed by e into lo and hi parts;
     * installs in given table.
     */
    private static void splitBin(Node[] nextTab, int i, Node e) {
        int bit = nextTab.length >>> 1; // bit to split on
        int runBit = e.hash & bit;
        Node lastRun = e, lo = null, hi = null;
        for (Node p = e.next; p != null; p = p.next) {
            int b = p.hash & bit;
            if (b != runBit) {
                runBit = b;
                lastRun = p;
            }
        }
        if (runBit == 0)
            lo = lastRun;
        else
            hi = lastRun;
        for (Node p = e; p != lastRun; p = p.next) {
            int ph = p.hash & HASH_BITS;
            Object pk = p.key, pv = p.val;
            if ((ph & bit) == 0)
                lo = new Node(ph, pk, pv, lo);
            else
                hi = new Node(ph, pk, pv, hi);
        }
        setTabAt(nextTab, i, lo);
        setTabAt(nextTab, i + bit, hi);
    }

    /**
     * Splits a tree bin into lo and hi parts; installs in given table.
     */
    private static void splitTreeBin(Node[] nextTab, int i, TreeBin t) {
        int bit = nextTab.length >>> 1;
        TreeBin lt = new TreeBin();
        TreeBin ht = new TreeBin();
        int lc = 0, hc = 0;
        for (Node e = t.first; e != null; e = e.next) {
            int h = e.hash & HASH_BITS;
            Object k = e.key, v = e.val;
            if ((h & bit) == 0) {
                ++lc;
                lt.putTreeNode(h, k, v);
            }
            else {
                ++hc;
                ht.putTreeNode(h, k, v);
            }
        }
        Node ln, hn; // throw away trees if too small
        if (lc <= (TREE_THRESHOLD >>> 1)) {
            ln = null;
            for (Node p = lt.first; p != null; p = p.next)
                ln = new Node(p.hash, p.key, p.val, ln);
        }
        else
            ln = new Node(MOVED, lt, null, null);
        setTabAt(nextTab, i, ln);
        if (hc <= (TREE_THRESHOLD >>> 1)) {
            hn = null;
            for (Node p = ht.first; p != null; p = p.next)
                hn = new Node(p.hash, p.key, p.val, hn);
        }
        else
            hn = new Node(MOVED, ht, null, null);
        setTabAt(nextTab, i + bit, hn);
    }

    /**
     * Implementation for clear. Steps through each bin, removing all
     * nodes.
     */
    private final void internalClear() {
        long delta = 0L; // negative number of deletions
        int i = 0;
        Node[] tab = table;
        while (tab != null && i < tab.length) {
            int fh; Object fk;
            Node f = tabAt(tab, i);
            if (f == null)
                ++i;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            for (Node p = t.first; p != null; p = p.next) {
                                if (p.val != null) { // (currently always true)
                                    p.val = null;
                                    --delta;
                                }
                            }
                            t.first = null;
                            t.root = null;
                            ++i;
                        }
                    } finally {
                        t.release(0);
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                counter.add(delta); // opportunistically update count
                delta = 0L;
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        for (Node e = f; e != null; e = e.next) {
                            if (e.val != null) {  // (currently always true)
                                e.val = null;
                                --delta;
                            }
                        }
                        setTabAt(tab, i, null);
                        ++i;
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
            }
        }
        if (delta != 0)
            counter.add(delta);
    }

    /* ----------------Table Traversal -------------- */

    /**
     * Encapsulates traversal for methods such as containsValue; also
     * serves as a base class for other iterators and bulk tasks.
     *
     * At each step, the iterator snapshots the key (""nextKey"") and
     * value (""nextVal"") of a valid node (i.e., one that, at point of
     * snapshot, has a non-null user value). Because val fields can
     * change (including to null, indicating deletion), field nextVal
     * might not be accurate at point of use, but still maintains the
     * weak consistency property of holding a value that was once
     * valid. To support iterator.remove, the nextKey field is not
     * updated (nulled out) when the iterator cannot advance.
     *
     * Internal traversals directly access these fields, as in:
     * {@code while (it.advance() != null) { process(it.nextKey); }}
     *
     * Exported iterators must track whether the iterator has advanced
     * (in hasNext vs next) (by setting/checking/nulling field
     * nextVal), and then extract key, value, or key-value pairs as
     * return values of next().
     *
     * The iterator visits once each still-valid node that was
     * reachable upon iterator construction. It might miss some that
     * were added to a bin after the bin was visited, which is OK wrt
     * consistency guarantees. Maintaining this property in the face
     * of possible ongoing resizes requires a fair amount of
     * bookkeeping state that is difficult to optimize away amidst
     * volatile accesses.  Even so, traversal maintains reasonable
     * throughput.
     *
     * Normally, iteration proceeds bin-by-bin traversing lists.
     * However, if the table has been resized, then all future steps
     * must traverse both the bin at the current index as well as at
     * (index + baseSize); and so on for further resizings. To
     * paranoically cope with potential sharing by users of iterators
     * across threads, iteration terminates if a bounds checks fails
     * for a table read.
     *
     * This class extends ForkJoinTask to streamline parallel
     * iteration in bulk operations (see BulkTask). This adds only an
     * int of space overhead, which is close enough to negligible in
     * cases where it is not needed to not worry about it.  Because
     * ForkJoinTask is Serializable, but iterators need not be, we
     * need to add warning suppressions.
     */
    @SuppressWarnings(""serial"") static class Traverser<K,V,R> {
        final ConcurrentHashMapV8<K, V> map;
        Node next;           // the next entry to use
        K nextKey;           // cached key field of next
        V nextVal;           // cached val field of next
        Node[] tab;          // current table; updated if resized
        int index;           // index of bin to use next
        int baseIndex;       // current index of initial table
        int baseLimit;       // index bound for initial table
        int baseSize;        // initial table size

        /** Creates iterator for all entries in the table. */
        Traverser(ConcurrentHashMapV8<K, V> map) {
            this.map = map;
        }

        /** Creates iterator for split() methods */
        Traverser(Traverser<K,V,?> it) {
            ConcurrentHashMapV8<K, V> m; Node[] t;
            if ((m = this.map = it.map) == null)
                t = null;
            else if ((t = it.tab) == null && // force parent tab initialization
                    (t = it.tab = m.table) != null)
                it.baseLimit = it.baseSize = t.length;
            this.tab = t;
            this.baseSize = it.baseSize;
            it.baseLimit = this.index = this.baseIndex =
                    ((this.baseLimit = it.baseLimit) + it.baseIndex + 1) >>> 1;
        }

        /**
         * Advances next; returns nextVal or null if terminated.
         * See above for explanation.
         */
        final V advance() {
            Node e = next;
            V ev = null;
            outer: do {
                if (e != null)                  // advance past used/skipped node
                    e = e.next;
                while (e == null) {             // get to next non-null bin
                    ConcurrentHashMapV8<K, V> m;
                    Node[] t; int b, i, n; Object ek; // checks must use locals
                    if ((t = tab) != null)
                        n = t.length;
                    else if ((m = map) != null && (t = tab = m.table) != null)
                        n = baseLimit = baseSize = t.length;
                    else
                        break outer;
                    if ((b = baseIndex) >= baseLimit ||
                            (i = index) < 0 || i >= n)
                        break outer;
                    if ((e = tabAt(t, i)) != null && e.hash == MOVED) {
                        if ((ek = e.key) instanceof TreeBin)
                            e = ((TreeBin)ek).first;
                        else {
                            tab = (Node[])ek;
                            continue;           // restarts due to null val
                        }
                    }                           // visit upper slots if present
                    index = (i += baseSize) < n ? i : (baseIndex = b + 1);
                }
                nextKey = (K) e.key;
            } while ((ev = (V) e.val) == null);    // skip deleted or special nodes
            next = e;
            return nextVal = ev;
        }

        public final void remove() {
            Object k = nextKey;
            if (k == null && (advance() == null || (k = nextKey) == null))
                throw new IllegalStateException();
            map.internalReplace(k, null, null);
        }

        public final boolean hasNext() {
            return nextVal != null || advance() != null;
        }

        public final boolean hasMoreElements() { return hasNext(); }
        public final void setRawResult(Object x) { }
        public R getRawResult() { return null; }
        public boolean exec() { return true; }
    }

    /* ---------------- Public operations -------------- */

    /**
     * Creates a new, empty map with the default initial table size (16).
     */
    public ConcurrentHashMapV8() {
        this.counter = new LongAdder();
    }

    /**
     * Creates a new, empty map with an initial table size
     * accommodating the specified number of elements without the need
     * to dynamically resize.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     */
    public ConcurrentHashMapV8(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                MAXIMUM_CAPACITY :
                tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new map with the same mappings as the given map.
     *
     * @param m the map
     */
    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {
        this.counter = new LongAdder();
        this.sizeCtl = DEFAULT_CAPACITY;
        internalPutAll(m);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}) and
     * initial table density ({@code loadFactor}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative or the load factor is nonpositive
     *
     * @since 1.6
     */
    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}), table
     * density ({@code loadFactor}), and number of concurrently
     * updating threads ({@code concurrencyLevel}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation may use this value as
     * a sizing hint.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive
     */
    public ConcurrentHashMapV8(int initialCapacity,
                               float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
                MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);
    }

    /**
     * {@inheritDoc}
     */
    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }

    /**
     * {@inheritDoc}
     */
    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                        (int)n);
    }

    /**
     * Returns the number of mappings. This method should be used
     * instead of {@link #size} because a ConcurrentHashMapV8 may
     * contain more mappings than can be represented as an int. The
     * value returned is a snapshot; the actual count may differ if
     * there are ongoing concurrent insertions or removals.
     *
     * @return the number of mappings
     */
    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * <p>More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or the given defaultValue if this map contains no mapping for the key.
     *
     * @param key the key
     * @param defaultValue the value to return if this map contains
     * no mapping for the given key
     * @return the mapping for the key, if present; else the defaultValue
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }

    /**
     * Tests if the specified object is a key in this table.
     *
     * @param  key   possible key
     * @return {@code true} if and only if the specified object
     *         is a key in this table, as determined by the
     *         {@code equals} method; {@code false} otherwise
     * @throws NullPointerException if the specified key is null
     */
    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value. Note: This method may require a full traversal
     * of the map, and is much slower than method {@code containsKey}.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if this map maps one or more keys to the
     *         specified value
     * @throws NullPointerException if the specified value is null
     */
    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }

    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }

    /**
     * Legacy method testing if some key maps into the specified value
     * in this table.  This method is identical in functionality to
     * {@link #containsValue}, and exists solely to ensure
     * full compatibility with class {@link java.util.Hashtable},
     * which supported this method prior to introduction of the
     * Java Collections framework.
     *
     * @param  value a value to search for
     * @return {@code true} if and only if some key maps to the
     *         {@code value} argument in this table as
     *         determined by the {@code equals} method;
     *         {@code false} otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean contains(Object value) {
        return containsValue(value);
    }

    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * <p>The value can be retrieved by calling the {@code get} method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }

    /**
     * Copies all of the mappings from the specified map to this one.
     * These mappings replace any mappings that this map had for any of the
     * keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     */
    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }

    /**
     * If the specified key is not already associated with a value,
     * computes its value using the given mappingFunction and enters
     * it into the map unless null.  This is equivalent to
     * <pre> {@code
     * if (map.containsKey(key))
     *   return map.get(key);
     * value = mappingFunction.apply(key);
     * if (value != null)
     *   map.put(key, value);
     * return value;}</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null} no mapping is recorded. If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and no mapping is recorded.  Some
     * attempted update operations on this map by other threads may be
     * blocked while computation is in progress, so the computation
     * should be short and simple, and must not attempt to update any
     * other mappings of this Map. The most appropriate usage is to
     * construct a new object serving as an initial mapped value, or
     * memoized result, as in:
     *
     *  <pre> {@code
     * map.computeIfAbsent(key, new Fun<K, V>() {
     *   public V map(K k) { return new Value(f(k)); }});}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param mappingFunction the function to compute a value
     * @return the current (existing or computed) value associated with
     *         the specified key, or null if the computed value is null
     * @throws NullPointerException if the specified key or mappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the mappingFunction does so,
     *         in which case the mapping is left unestablished
     */
    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }

    /**
     * If the given key is present, computes a new mapping value given a key and
     * its current mapped value. This is equivalent to
     *  <pre> {@code
     *   if (map.containsKey(key)) {
     *     value = remappingFunction.apply(key, map.get(key));
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }

    /**
     * Computes a new mapping value given a key and
     * its current mapped value (or {@code null} if there is no current
     * mapping). This is equivalent to
     *  <pre> {@code
     *   value = remappingFunction.apply(key, map.get(key));
     *   if (value != null)
     *     map.put(key, value);
     *   else
     *     map.remove(key);
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * <pre> {@code
     * Map<Key, String> map = ...;
     * final String msg = ...;
     * map.compute(key, new BiFun<Key, String, String>() {
     *   public String apply(Key k, String v) {
     *    return (v == null) ? msg : v + msg;});}}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }

    /**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * Otherwise, replace the value with the results of
     * the given remapping function. This is equivalent to:
     *  <pre> {@code
     *   if (!map.containsKey(key))
     *     map.put(value);
     *   else {
     *     newValue = remappingFunction.apply(map.get(key), value);
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map.
     */
    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }

    /**
     * Removes the key (and its corresponding value) from this map.
     * This method does nothing if the key is not in the map.
     *
     * @param  key the key that needs to be removed
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if the specified key is null
     */
    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if any of the arguments are null
     */
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }

    /**
     * Removes all of the mappings from this map.
     */
    public void clear() {
        internalClear();
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.
     *
     * @return the set view
     */
    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }

    /**
     * Returns a {@link Set} view of the keys in this map, using the
     * given common mapped value for any additions (i.e., {@link
     * Collection#add} and {@link Collection#addAll}). This is of
     * course only appropriate if it is acceptable to use the same
     * value for all additions from this view.
     *
     * @param mappedValue the mapped value to use for any
     * additions.
     * @return the set view
     * @throws NullPointerException if the mappedValue is null
     */
    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.
     */
    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or
     * {@code addAll} operations.
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }

    /**
     * Returns an enumeration of the keys in this table.
     *
     * @return an enumeration of the keys in this table
     * @see #keySet()
     */
    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns an enumeration of the values in this table.
     *
     * @return an enumeration of the values in this table
     * @see #values()
     */
    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the keys in this map.
     *
     * @return a partitionable iterator of the keys in this map
     */
    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the values in this map.
     *
     * @return a partitionable iterator of the values in this map
     */
    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the entries in this map.
     *
     * @return a partitionable iterator of the entries in this map
     */
    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }

    /**
     * Returns the hash code value for this {@link Map}, i.e.,
     * the sum of, for each key-value pair in the map,
     * {@code key.hashCode() ^ value.hashCode()}.
     *
     * @return the hash code value for this map
     */
    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }

    /**
     * Returns a string representation of this map.  The string
     * representation consists of a list of key-value mappings (in no
     * particular order) enclosed in braces (""{@code {}}"").  Adjacent
     * mappings are separated by the characters {@code "", ""} (comma
     * and space).  Each key-value mapping is rendered as the key
     * followed by an equals sign (""{@code =}"") followed by the
     * associated value.
     *
     * @return a string representation of this map
     */
    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }

    /**
     * Compares the specified object with this map for equality.
     * Returns {@code true} if the given object is a map with the same
     * mappings as this map.  This operation may return misleading
     * results if either map is concurrently modified during execution
     * of this method.
     *
     * @param o object to be compared for equality with this map
     * @return {@code true} if the specified object is equal to this map
     */
    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }

    /* ----------------Iterators -------------- */

    @SuppressWarnings(""serial"") static final class KeyIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<K>, Enumeration<K> {
        KeyIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        KeyIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }
        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }

        public final K nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class ValueIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<V>, Enumeration<V> {
        ValueIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        ValueIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }

        public final V nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class EntryIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<Map.Entry<K,V>> {
        EntryIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        EntryIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }
    }

    /**
     * Exported Entry for iterators
     */
    static final class MapEntry<K,V> implements Map.Entry<K, V> {
        final K key; // non-null
        V val;       // non-null
        final ConcurrentHashMapV8<K, V> map;
        MapEntry(K key, V val, ConcurrentHashMapV8<K, V> map) {
            this.key = key;
            this.val = val;
            this.map = map;
        }
        public final K getKey()       { return key; }
        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }

        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == val || v.equals(val)));
        }

        /**
         * Sets our entry's value and writes through to the map. The
         * value to return is somewhat arbitrary here. Since we do not
         * necessarily track asynchronous changes, the most recent
         * ""previous"" value could be different from what we return (or
         * could even have been removed in which case the put will
         * re-establish). We do not and cannot guarantee more.
         */
        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }
    }

    /* ---------------- Serialization Support -------------- */

    /**
     * Stripped-down version of helper class used in previous version,
     * declared for the sake of serialization compatibility
     */
    static class Segment<K,V> implements Serializable {
        private static final long serialVersionUID = 2249069246763182397L;
        final float loadFactor;
        Segment(float lf) { this.loadFactor = lf; }
    }

    /**
     * Saves the state of the {@code ConcurrentHashMapV8} instance to a
     * stream (i.e., serializes it).
     * @param s the stream
     * @serialData
     * the key (Object) and value (Object)
     * for each key-value mapping, followed by a null pair.
     * The key-value mappings are emitted in no particular order.
     */
    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     * @param s the stream
     */
    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        UNSAFE.putObjectVolatile(this, counterOffset, new LongAdder());

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;
            int n;
            if (size >= (long)(MAXIMUM_CAPACITY >>> 1))
                n = MAXIMUM_CAPACITY;
            else {
                int sz = (int)size;
                n = tableSizeFor(sz + (sz >>> 1) + 1);
            }
            int sc = sizeCtl;
            boolean collide = false;
            if (n > sc &&
                    UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                try {
                    if (table == null) {
                        init = true;
                        Node[] tab = new Node[n];
                        int mask = n - 1;
                        while (p != null) {
                            int j = p.hash & mask;
                            Node next = p.next;
                            Node q = p.next = tabAt(tab, j);
                            setTabAt(tab, j, p);
                            if (!collide && q != null && q.hash == p.hash)
                                collide = true;
                            p = next;
                        }
                        table = tab;
                        counter.add(size);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                if (collide) { // rescan and convert to TreeBins
                    Node[] tab = table;
                    for (int i = 0; i < tab.length; ++i) {
                        int c = 0;
                        for (Node e = tabAt(tab, i); e != null; e = e.next) {
                            if (++c > TREE_THRESHOLD &&
                                    (e.key instanceof Comparable)) {
                                replaceWithTreeBin(tab, i, e.key);
                                break;
                            }
                        }
                    }
                }
            }
            if (!init) { // Can only happen if unsafely published.
                while (p != null) {
                    internalPut(p.key, p.val);
                    p = p.next;
                }
            }
        }
    }


    // -------------------------------------------------------

    // Sams
    /** Interface describing a void action of one argument */
    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7219,"    static final Node tabAt(Node[] tab, int i) { // used by Iter
        return (Node)UNSAFE.getObjectVolatile(tab, ((long)i<<ASHIFT)+ABASE);
    }"
7220,"    private static final boolean casTabAt(Node[] tab, int i, Node c, Node v) {
        return UNSAFE.compareAndSwapObject(tab, ((long)i<<ASHIFT)+ABASE, c, v);
    }"
7221,"    private static final void setTabAt(Node[] tab, int i, Node v) {
        UNSAFE.putObjectVolatile(tab, ((long)i<<ASHIFT)+ABASE, v);
    }"
7222,"        final boolean casHash(int cmp, int val) {
            return UNSAFE.compareAndSwapInt(this, hashOffset, cmp, val);
        }"
7223,"        final void tryAwaitLock(Node[] tab, int i) {
            if (tab != null && i >= 0 && i < tab.length) { // sanity check
                int r = ThreadLocalRandom.current().nextInt(); // randomize spins"
7224,"        public final boolean isHeldExclusively() { return getState() > 0; }
        public final boolean tryAcquire(int ignore) {"
7225,"        public final boolean tryAcquire(int ignore) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }"
7226,"        public final boolean tryRelease(int ignore) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }"
7227,"        public final int tryAcquireShared(int ignore) {
            for (int c;;) {
                if ((c = getState()) > 0)"
7228,"        public final boolean tryReleaseShared(int ignore) {
            int c;
            do {} while (!compareAndSetState(c = getState(), c + 1));
            return c == -1;
        }"
7229,"        private void rotateLeft(TreeNode p) {
            if (p != null) {
                TreeNode r = p.right, pp, rl;"
7230,"        private void rotateRight(TreeNode p) {
            if (p != null) {
                TreeNode l = p.left, pp, lr;"
7231,"        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, Object k, TreeNode p) {
            return getTreeNode(h, (RubyObject)k, p);
        }"
7232,"        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, RubyObject k, TreeNode p) {
            RubyClass c = k.getMetaClass(); boolean kNotComparable = !k.respondsTo(""<=>"");
            while (p != null) {
                int dir, ph;  RubyObject pk; RubyClass pc;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = (RubyClass)pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pl, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            // try to continue iterating on the left side
                            else if ((pl = p.left) != null && h <= pl.hash)
                                dir = -1;
                            else // no matching node found
                                return null;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                p = (dir > 0) ? p.right : p.left;
            }
            return null;
        }"
7233,"        int rubyCompare(RubyObject l, RubyObject r) {
            ThreadContext context = l.getMetaClass().getRuntime().getCurrentContext();
            IRubyObject result;
            try {
                result = l.callMethod(context, ""<=>"", r);
            } catch (RaiseException e) {
                // handle objects ""lying"" about responding to <=>, ie: an Array containing non-comparable keys
                if (context.runtime.getNoMethodError().isInstance(e.getException())) {
                    return 0;
                }
                throw e;
            }

            return result.isNil() ? 0 : RubyNumeric.num2int(result.convertToInteger());
        }"
7234,"        final Object getValue(int h, Object k) {
            Node r = null;
            int c = getState(); // Must read lock state first
            for (Node e = first; e != null; e = e.next) {
                if (c <= 0 && compareAndSetState(c, c - 1)) {
                    try {
                        r = getTreeNode(h, k, root);
                    } finally {
                        releaseShared(0);
                    }
                    break;
                }
                else if ((e.hash & HASH_BITS) == h && k.equals(e.key)) {
                    r = e;
                    break;
                }
                else
                    c = getState();
            }
            return r == null ? null : r.val;
        }"
7235,"        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
                (int h, Object k, Object v) {
            return putTreeNode(h, (RubyObject)k, v);
        }"
7236,"        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
        (int h, RubyObject k, Object v) {
            RubyClass c = k.getMetaClass();
            boolean kNotComparable = !k.respondsTo(""<=>"");
            TreeNode pp = root, p = null;
            int dir = 0;
            while (pp != null) { // find existing node or leaf to insert at
                int ph;  RubyObject pk; RubyClass pc;
                p = pp;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            else // continue descending down the left subtree
                                dir = -1;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                pp = (dir > 0) ? p.right : p.left;
            }

            TreeNode f = first;
            TreeNode x = first = new TreeNode(h, (Object)k, v, f, p);
            if (p == null)
                root = x;
            else { // attach and rebalance; adapted from CLR
                TreeNode xp, xpp;
                if (f != null)
                    f.prev = x;
                if (dir <= 0)
                    p.left = x;
                else
                    p.right = x;
                x.red = true;
                while (x != null && (xp = x.parent) != null && xp.red &&
                        (xpp = xp.parent) != null) {
                    TreeNode xppl = xpp.left;
                    if (xp == xppl) {
                        TreeNode y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }
                    else {
                        TreeNode y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }
                }
                TreeNode r = root;
                if (r != null && r.red)
                    r.red = false;
            }
            return null;
        }"
7237,"        final void deleteTreeNode(TreeNode p) {
            TreeNode next = (TreeNode)p.next; // unlink traversal pointers
            TreeNode pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode replacement;
            TreeNode pl = p.left;
            TreeNode pr = p.right;
            if (pl != null && pr != null) {
                TreeNode s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode sr = s.right;
                TreeNode pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode x = replacement;
                while (x != null) {
                    TreeNode xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                    (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ? null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                    (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ? null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers"
7238,"    private static final int spread(int h) {
        h ^= (h >>> 18) ^ (h >>> 12);
        return (h ^ (h >>> 10)) & HASH_BITS;
    }"
7239,"    private final void replaceWithTreeBin(Node[] tab, int index, Object key) {
        if ((key instanceof Comparable) &&
                (tab.length >= MAXIMUM_CAPACITY || counter.sum() < (long)sizeCtl)) {"
7240,"    private final Object internalGet(Object k) {
        int h = spread(k.hashCode());
        retry: for (Node[] tab = table; tab != null;) {
            Node e, p; Object ek, ev; int eh;      // locals to read fields once
            for (e = tabAt(tab, (tab.length - 1) & h); e != null; e = e.next) {
                if ((eh = e.hash) == MOVED) {
                    if ((ek = e.key) instanceof TreeBin)  // search TreeBin
                        return ((TreeBin)ek).getValue(h, k);
                    else {                        // restart with new table
                        tab = (Node[])ek;
                        continue retry;
                    }
                }
                else if ((eh & HASH_BITS) == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                    return ev;
            }
            break;
        }
        return null;
    }"
7241,"    private final Object internalReplace(Object k, Object v, Object cv) {
        int h = spread(k.hashCode());
        Object oldVal = null;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null ||
                    (f = tabAt(tab, i = (tab.length - 1) & h)) == null)
                break;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    boolean deleted = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null) {
                                Object pv = p.val;
                                if (cv == null || cv == pv || cv.equals(pv)) {
                                    oldVal = pv;
                                    if ((p.val = v) == null) {
                                        deleted = true;
                                        t.deleteTreeNode(p);
                                    }
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (validated) {
                        if (deleted)
                            counter.add(-1L);
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) != h && f.next == null) // precheck
                break;                          // rules out possible existence
            else if ((fh & LOCKED) != 0) {
                checkForResize();               // try resizing if can't get lock
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                boolean validated = false;
                boolean deleted = false;
                try {
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        for (Node e = f, pred = null;;) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    ((ev = e.val) != null) &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                if (cv == null || cv == ev || cv.equals(ev)) {
                                    oldVal = ev;
                                    if ((e.val = v) == null) {
                                        deleted = true;
                                        Node en = e.next;
                                        if (pred != null)
                                            pred.next = en;
                                        else
                                            setTabAt(tab, i, en);
                                    }
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (validated) {
                    if (deleted)
                        counter.add(-1L);
                    break;
                }
            }
        }
        return oldVal;
    }"
7242,"    private final Object internalPut(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null) {
                                oldVal = p.val;
                                p.val = v;
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                Object oldVal = null;
                try {                        // needed in case equals() throws
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                oldVal = ev;
                                e.val = v;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                last.next = new Node(h, k, v, null);
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {                  // unlock and signal if needed
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (oldVal != null)
                        return oldVal;
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }"
7243,"    private final Object internalPutIfAbsent(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null)
                                oldVal = p.val;
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) { // at least 2 nodes -- search and maybe resize
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    Object oldVal = null;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    oldVal = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    last.next = new Node(h, k, v, null);
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }"
7244,"    private final Object internalComputeIfAbsent(K k,
                                                 Fun<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.apply(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.apply(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val != null) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7245,"    @SuppressWarnings(""unchecked"") private final Object internalCompute
    (K k, boolean onlyIfPresent, BiFun<? super K, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (Node[] tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.apply(k, null)) != null) {
                            node.val = val;
                            delta = 1;
                        }
                    } finally {
                        if (delta == 0)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv;
                            if (p == null) {
                                if (onlyIfPresent)
                                    break;
                                pv = null;
                            } else
                                pv = p.val;
                            if ((val = mf.apply(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent && (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node(h, k, val, null);
                                    delta = 1;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7246,"    @SuppressWarnings(""unchecked"") private final Object internalMerge
    (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (Node[] tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply((V)p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply((V)ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node(h, k, val, null);
                                delta = 1;
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7247,"    private final void internalPutAll(Map<?, ?> m) {
        tryPresize(m.size());
        long delta = 0L;     // number of uncommitted additions
        boolean npe = false; // to throw exception on exit for nulls
        try {                // to clean up counts on other exceptions
            for (Map.Entry<?, ?> entry : m.entrySet()) {
                Object k, v;
                if (entry == null || (k = entry.getKey()) == null ||
                        (v = entry.getValue()) == null) {
                    npe = true;
                    break;
                }
                int h = spread(k.hashCode());
                for (Node[] tab = table;;) {
                    int i; Node f; int fh; Object fk;
                    if (tab == null)
                        tab = initTable();
                    else if ((f = tabAt(tab, i = (tab.length - 1) & h)) == null){
                        if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                            ++delta;
                            break;
                        }
                    }
                    else if ((fh = f.hash) == MOVED) {
                        if ((fk = f.key) instanceof TreeBin) {
                            TreeBin t = (TreeBin)fk;
                            boolean validated = false;
                            t.acquire(0);
                            try {
                                if (tabAt(tab, i) == f) {
                                    validated = true;
                                    TreeNode p = t.getTreeNode(h, k, t.root);
                                    if (p != null)
                                        p.val = v;
                                    else {
                                        t.putTreeNode(h, k, v);
                                        ++delta;
                                    }
                                }
                            } finally {
                                t.release(0);
                            }
                            if (validated)
                                break;
                        }
                        else
                            tab = (Node[])fk;
                    }
                    else if ((fh & LOCKED) != 0) {
                        counter.add(delta);
                        delta = 0L;
                        checkForResize();
                        f.tryAwaitLock(tab, i);
                    }
                    else if (f.casHash(fh, fh | LOCKED)) {
                        int count = 0;
                        try {
                            if (tabAt(tab, i) == f) {
                                count = 1;
                                for (Node e = f;; ++count) {
                                    Object ek, ev;
                                    if ((e.hash & HASH_BITS) == h &&
                                            (ev = e.val) != null &&
                                            ((ek = e.key) == k || k.equals(ek))) {
                                        e.val = v;
                                        break;
                                    }
                                    Node last = e;
                                    if ((e = e.next) == null) {
                                        ++delta;
                                        last.next = new Node(h, k, v, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                        break;
                                    }
                                }
                            }
                        } finally {
                            if (!f.casHash(fh | LOCKED, fh)) {
                                f.hash = fh;
                                synchronized (f) { f.notifyAll(); };
                            }
                        }
                        if (count != 0) {
                            if (count > 1) {
                                counter.add(delta);
                                delta = 0L;
                                checkForResize();
                            }
                            break;
                        }
                    }
                }
            }
        } finally {
            if (delta != 0)
                counter.add(delta);
        }
        if (npe)
            throw new NullPointerException();"
7248,"    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }"
7249,"    private final Node[] initTable() {
        Node[] tab; int sc;
        while ((tab = table) == null) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                try {
                    if ((tab = table) == null) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        tab = table = new Node[n];
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }"
7250,"    private final void checkForResize() {
        Node[] tab; int n, sc;
        while ((tab = table) != null &&
                (n = tab.length) < MAXIMUM_CAPACITY &&"
7251,"    private final void tryPresize(int size) {
        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
                tableSizeFor(size + (size >>> 1) + 1);
        int sc;
        while ((sc = sizeCtl) >= 0) {
            Node[] tab = table; int n;"
7252,"    private static final Node[] rebuild(Node[] tab) {
        int n = tab.length;
        Node[] nextTab = new Node[n << 1];
        Node fwd = new Node(MOVED, nextTab, null, null);
        int[] buffer = null;       // holds bins to revisit; null until needed
        Node rev = null;           // reverse forwarder; null until needed
        int nbuffered = 0;         // the number of bins in buffer list
        int bufferIndex = 0;       // buffer index of current buffered bin
        int bin = n - 1;           // current non-buffered bin or -1 if none

        for (int i = bin;;) {      // start upwards sweep
            int fh; Node f;"
7253,"    private static void splitBin(Node[] nextTab, int i, Node e) {
        int bit = nextTab.length >>> 1; // bit to split on
        int runBit = e.hash & bit;
        Node lastRun = e, lo = null, hi = null;
        for (Node p = e.next; p != null; p = p.next) {
            int b = p.hash & bit;
            if (b != runBit) {
                runBit = b;
                lastRun = p;
            }
        }
        if (runBit == 0)
            lo = lastRun;
        else
            hi = lastRun;
        for (Node p = e; p != lastRun; p = p.next) {
            int ph = p.hash & HASH_BITS;
            Object pk = p.key, pv = p.val;
            if ((ph & bit) == 0)
                lo = new Node(ph, pk, pv, lo);
            else
                hi = new Node(ph, pk, pv, hi);
        }
        setTabAt(nextTab, i, lo);
        setTabAt(nextTab, i + bit, hi);
    }"
7254,"    private static void splitTreeBin(Node[] nextTab, int i, TreeBin t) {
        int bit = nextTab.length >>> 1;
        TreeBin lt = new TreeBin();
        TreeBin ht = new TreeBin();
        int lc = 0, hc = 0;
        for (Node e = t.first; e != null; e = e.next) {
            int h = e.hash & HASH_BITS;
            Object k = e.key, v = e.val;
            if ((h & bit) == 0) {
                ++lc;
                lt.putTreeNode(h, k, v);
            }
            else {
                ++hc;
                ht.putTreeNode(h, k, v);
            }
        }
        Node ln, hn; // throw away trees if too small
        if (lc <= (TREE_THRESHOLD >>> 1)) {
            ln = null;
            for (Node p = lt.first; p != null; p = p.next)
                ln = new Node(p.hash, p.key, p.val, ln);
        }
        else
            ln = new Node(MOVED, lt, null, null);
        setTabAt(nextTab, i, ln);
        if (hc <= (TREE_THRESHOLD >>> 1)) {
            hn = null;
            for (Node p = ht.first; p != null; p = p.next)
                hn = new Node(p.hash, p.key, p.val, hn);
        }
        else
            hn = new Node(MOVED, ht, null, null);
        setTabAt(nextTab, i + bit, hn);
    }"
7255,"    private final void internalClear() {
        long delta = 0L; // negative number of deletions
        int i = 0;
        Node[] tab = table;
        while (tab != null && i < tab.length) {
            int fh; Object fk;
            Node f = tabAt(tab, i);
            if (f == null)
                ++i;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            for (Node p = t.first; p != null; p = p.next) {
                                if (p.val != null) { // (currently always true)
                                    p.val = null;
                                    --delta;
                                }
                            }
                            t.first = null;
                            t.root = null;
                            ++i;
                        }
                    } finally {
                        t.release(0);
                    }
                }
                else
                    tab = (Node[])fk;
            }
            else if ((fh & LOCKED) != 0) {
                counter.add(delta); // opportunistically update count
                delta = 0L;
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        for (Node e = f; e != null; e = e.next) {
                            if (e.val != null) {  // (currently always true)
                                e.val = null;
                                --delta;
                            }
                        }
                        setTabAt(tab, i, null);
                        ++i;
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
            }
        }
        if (delta != 0)
            counter.add(delta);"
7256,"        final V advance() {
            Node e = next;
            V ev = null;
            outer: do {
                if (e != null)                  // advance past used/skipped node
                    e = e.next;
                while (e == null) {             // get to next non-null bin
                    ConcurrentHashMapV8<K, V> m;
                    Node[] t; int b, i, n; Object ek; // checks must use locals
                    if ((t = tab) != null)
                        n = t.length;
                    else if ((m = map) != null && (t = tab = m.table) != null)
                        n = baseLimit = baseSize = t.length;
                    else
                        break outer;
                    if ((b = baseIndex) >= baseLimit ||
                            (i = index) < 0 || i >= n)
                        break outer;
                    if ((e = tabAt(t, i)) != null && e.hash == MOVED) {
                        if ((ek = e.key) instanceof TreeBin)
                            e = ((TreeBin)ek).first;
                        else {
                            tab = (Node[])ek;
                            continue;           // restarts due to null val
                        }
                    }                           // visit upper slots if present
                    index = (i += baseSize) < n ? i : (baseIndex = b + 1);
                }
                nextKey = (K) e.key;
            } while ((ev = (V) e.val) == null);    // skip deleted or special nodes
            next = e;
            return nextVal = ev;
        }"
7257,"        public final void remove() {
            Object k = nextKey;
            if (k == null && (advance() == null || (k = nextKey) == null))
                throw new IllegalStateException();
            map.internalReplace(k, null, null);
        }"
7258,"        public final boolean hasNext() {
            return nextVal != null || advance() != null;
        }"
7259,"        public final boolean hasMoreElements() { return hasNext(); }
        public final void setRawResult(Object x) { }"
7260,"        public final void setRawResult(Object x) { }
        public R getRawResult() { return null; }
        public boolean exec() { return true; }
    }

    /* ---------------- Public operations -------------- */

    /**
     * Creates a new, empty map with the default initial table size (16).
     */
    public ConcurrentHashMapV8() {
        this.counter = new LongAdder();
    }

    /**
     * Creates a new, empty map with an initial table size
     * accommodating the specified number of elements without the need
     * to dynamically resize.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     */
    public ConcurrentHashMapV8(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                MAXIMUM_CAPACITY :
                tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new map with the same mappings as the given map.
     *
     * @param m the map
     */
    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {
        this.counter = new LongAdder();
        this.sizeCtl = DEFAULT_CAPACITY;
        internalPutAll(m);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}) and
     * initial table density ({@code loadFactor}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative or the load factor is nonpositive
     *
     * @since 1.6
     */
    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}), table
     * density ({@code loadFactor}), and number of concurrently
     * updating threads ({@code concurrencyLevel}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation may use this value as
     * a sizing hint.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive
     */
    public ConcurrentHashMapV8(int initialCapacity,
                               float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
                MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);
    }

    /**
     * {@inheritDoc}
     */
    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }

    /**
     * {@inheritDoc}
     */
    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                        (int)n);
    }

    /**
     * Returns the number of mappings. This method should be used
     * instead of {@link #size} because a ConcurrentHashMapV8 may
     * contain more mappings than can be represented as an int. The
     * value returned is a snapshot; the actual count may differ if
     * there are ongoing concurrent insertions or removals.
     *
     * @return the number of mappings
     */
    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * <p>More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or the given defaultValue if this map contains no mapping for the key.
     *
     * @param key the key
     * @param defaultValue the value to return if this map contains
     * no mapping for the given key
     * @return the mapping for the key, if present; else the defaultValue
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }

    /**
     * Tests if the specified object is a key in this table.
     *
     * @param  key   possible key
     * @return {@code true} if and only if the specified object
     *         is a key in this table, as determined by the
     *         {@code equals} method; {@code false} otherwise
     * @throws NullPointerException if the specified key is null
     */
    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value. Note: This method may require a full traversal
     * of the map, and is much slower than method {@code containsKey}.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if this map maps one or more keys to the
     *         specified value
     * @throws NullPointerException if the specified value is null
     */
    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }

    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }

    /**
     * Legacy method testing if some key maps into the specified value
     * in this table.  This method is identical in functionality to
     * {@link #containsValue}, and exists solely to ensure
     * full compatibility with class {@link java.util.Hashtable},
     * which supported this method prior to introduction of the
     * Java Collections framework.
     *
     * @param  value a value to search for
     * @return {@code true} if and only if some key maps to the
     *         {@code value} argument in this table as
     *         determined by the {@code equals} method;
     *         {@code false} otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean contains(Object value) {
        return containsValue(value);
    }

    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * <p>The value can be retrieved by calling the {@code get} method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }

    /**
     * Copies all of the mappings from the specified map to this one.
     * These mappings replace any mappings that this map had for any of the
     * keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     */
    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }

    /**
     * If the specified key is not already associated with a value,
     * computes its value using the given mappingFunction and enters
     * it into the map unless null.  This is equivalent to
     * <pre> {@code
     * if (map.containsKey(key))
     *   return map.get(key);
     * value = mappingFunction.apply(key);
     * if (value != null)
     *   map.put(key, value);
     * return value;}</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null} no mapping is recorded. If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and no mapping is recorded.  Some
     * attempted update operations on this map by other threads may be
     * blocked while computation is in progress, so the computation
     * should be short and simple, and must not attempt to update any
     * other mappings of this Map. The most appropriate usage is to
     * construct a new object serving as an initial mapped value, or
     * memoized result, as in:
     *
     *  <pre> {@code
     * map.computeIfAbsent(key, new Fun<K, V>() {
     *   public V map(K k) { return new Value(f(k)); }});}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param mappingFunction the function to compute a value
     * @return the current (existing or computed) value associated with
     *         the specified key, or null if the computed value is null
     * @throws NullPointerException if the specified key or mappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the mappingFunction does so,
     *         in which case the mapping is left unestablished
     */
    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }

    /**
     * If the given key is present, computes a new mapping value given a key and
     * its current mapped value. This is equivalent to
     *  <pre> {@code
     *   if (map.containsKey(key)) {
     *     value = remappingFunction.apply(key, map.get(key));
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }

    /**
     * Computes a new mapping value given a key and
     * its current mapped value (or {@code null} if there is no current
     * mapping). This is equivalent to
     *  <pre> {@code
     *   value = remappingFunction.apply(key, map.get(key));
     *   if (value != null)
     *     map.put(key, value);
     *   else
     *     map.remove(key);
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * <pre> {@code
     * Map<Key, String> map = ...;
     * final String msg = ...;
     * map.compute(key, new BiFun<Key, String, String>() {
     *   public String apply(Key k, String v) {
     *    return (v == null) ? msg : v + msg;});}}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }

    /**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * Otherwise, replace the value with the results of
     * the given remapping function. This is equivalent to:
     *  <pre> {@code
     *   if (!map.containsKey(key))
     *     map.put(value);
     *   else {
     *     newValue = remappingFunction.apply(map.get(key), value);
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map.
     */
    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }

    /**
     * Removes the key (and its corresponding value) from this map.
     * This method does nothing if the key is not in the map.
     *
     * @param  key the key that needs to be removed
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if the specified key is null
     */
    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if any of the arguments are null
     */
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }

    /**
     * Removes all of the mappings from this map.
     */
    public void clear() {
        internalClear();
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.
     *
     * @return the set view
     */
    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }

    /**
     * Returns a {@link Set} view of the keys in this map, using the
     * given common mapped value for any additions (i.e., {@link
     * Collection#add} and {@link Collection#addAll}). This is of
     * course only appropriate if it is acceptable to use the same
     * value for all additions from this view.
     *
     * @param mappedValue the mapped value to use for any
     * additions.
     * @return the set view
     * @throws NullPointerException if the mappedValue is null
     */
    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.
     */
    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or
     * {@code addAll} operations.
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }

    /**
     * Returns an enumeration of the keys in this table.
     *
     * @return an enumeration of the keys in this table
     * @see #keySet()
     */
    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns an enumeration of the values in this table.
     *
     * @return an enumeration of the values in this table
     * @see #values()
     */
    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the keys in this map.
     *
     * @return a partitionable iterator of the keys in this map
     */
    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the values in this map.
     *
     * @return a partitionable iterator of the values in this map
     */
    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the entries in this map.
     *
     * @return a partitionable iterator of the entries in this map
     */
    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }

    /**
     * Returns the hash code value for this {@link Map}, i.e.,
     * the sum of, for each key-value pair in the map,
     * {@code key.hashCode() ^ value.hashCode()}.
     *
     * @return the hash code value for this map
     */
    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }

    /**
     * Returns a string representation of this map.  The string
     * representation consists of a list of key-value mappings (in no
     * particular order) enclosed in braces (""{@code {}}"").  Adjacent
     * mappings are separated by the characters {@code "", ""} (comma
     * and space).  Each key-value mapping is rendered as the key
     * followed by an equals sign (""{@code =}"") followed by the
     * associated value.
     *
     * @return a string representation of this map
     */
    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }

    /**
     * Compares the specified object with this map for equality.
     * Returns {@code true} if the given object is a map with the same
     * mappings as this map.  This operation may return misleading
     * results if either map is concurrently modified during execution
     * of this method.
     *
     * @param o object to be compared for equality with this map
     * @return {@code true} if the specified object is equal to this map
     */
    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }

    /* ----------------Iterators -------------- */

    @SuppressWarnings(""serial"") static final class KeyIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<K>, Enumeration<K> {
        KeyIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        KeyIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }
        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }

        public final K nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class ValueIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<V>, Enumeration<V> {
        ValueIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        ValueIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }

        public final V nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class EntryIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<Map.Entry<K,V>> {
        EntryIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        EntryIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }
    }

    /**
     * Exported Entry for iterators
     */
    static final class MapEntry<K,V> implements Map.Entry<K, V> {
        final K key; // non-null
        V val;       // non-null
        final ConcurrentHashMapV8<K, V> map;
        MapEntry(K key, V val, ConcurrentHashMapV8<K, V> map) {
            this.key = key;
            this.val = val;
            this.map = map;
        }
        public final K getKey()       { return key; }
        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }

        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == val || v.equals(val)));
        }

        /**
         * Sets our entry's value and writes through to the map. The
         * value to return is somewhat arbitrary here. Since we do not
         * necessarily track asynchronous changes, the most recent
         * ""previous"" value could be different from what we return (or
         * could even have been removed in which case the put will
         * re-establish). We do not and cannot guarantee more.
         */
        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }
    }

    /* ---------------- Serialization Support -------------- */

    /**
     * Stripped-down version of helper class used in previous version,
     * declared for the sake of serialization compatibility
     */
    static class Segment<K,V> implements Serializable {
        private static final long serialVersionUID = 2249069246763182397L;
        final float loadFactor;
        Segment(float lf) { this.loadFactor = lf; }
    }

    /**
     * Saves the state of the {@code ConcurrentHashMapV8} instance to a
     * stream (i.e., serializes it).
     * @param s the stream
     * @serialData
     * the key (Object) and value (Object)
     * for each key-value mapping, followed by a null pair.
     * The key-value mappings are emitted in no particular order.
     */
    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     * @param s the stream
     */
    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        UNSAFE.putObjectVolatile(this, counterOffset, new LongAdder());

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;
            int n;
            if (size >= (long)(MAXIMUM_CAPACITY >>> 1))
                n = MAXIMUM_CAPACITY;
            else {
                int sz = (int)size;
                n = tableSizeFor(sz + (sz >>> 1) + 1);
            }
            int sc = sizeCtl;
            boolean collide = false;
            if (n > sc &&
                    UNSAFE.compareAndSwapInt(this, sizeCtlOffset, sc, -1)) {
                try {
                    if (table == null) {
                        init = true;
                        Node[] tab = new Node[n];
                        int mask = n - 1;
                        while (p != null) {
                            int j = p.hash & mask;
                            Node next = p.next;
                            Node q = p.next = tabAt(tab, j);
                            setTabAt(tab, j, p);
                            if (!collide && q != null && q.hash == p.hash)
                                collide = true;
                            p = next;
                        }
                        table = tab;
                        counter.add(size);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                if (collide) { // rescan and convert to TreeBins
                    Node[] tab = table;
                    for (int i = 0; i < tab.length; ++i) {
                        int c = 0;
                        for (Node e = tabAt(tab, i); e != null; e = e.next) {
                            if (++c > TREE_THRESHOLD &&
                                    (e.key instanceof Comparable)) {
                                replaceWithTreeBin(tab, i, e.key);
                                break;
                            }
                        }
                    }
                }
            }
            if (!init) { // Can only happen if unsafely published.
                while (p != null) {
                    internalPut(p.key, p.val);
                    p = p.next;
                }
            }
        }
    }


    // -------------------------------------------------------

    // Sams
    /** Interface describing a void action of one argument */
    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7261,"        public R getRawResult() { return null; }
        public boolean exec() { return true; }"
7262,"        public boolean exec() { return true; }
    }"
7263,"    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);"
7264,"    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);"
7265,"    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }"
7266,"    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :"
7267,"    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }"
7268,"    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }"
7269,"    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }"
7270,"    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }"
7271,"    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }"
7272,"    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }"
7273,"    public boolean contains(Object value) {
        return containsValue(value);
    }"
7274,"    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }"
7275,"    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }"
7276,"    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }"
7277,"    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }"
7278,"    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }"
7279,"    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }"
7280,"    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }"
7281,"    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }"
7282,"    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }"
7283,"    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }"
7284,"    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }"
7285,"    public void clear() {
        internalClear();
    }"
7286,"    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }"
7287,"    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }"
7288,"    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }"
7289,"    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }"
7290,"    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }"
7291,"    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }"
7292,"    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }"
7293,"    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }"
7294,"    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }"
7295,"    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }"
7296,"    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }"
7297,"    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }"
7298,"        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }"
7299,"        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }"
7300,"        public final K nextElement() { return next(); }
    }"
7301,"        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }"
7302,"        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }"
7303,"        public final V nextElement() { return next(); }
    }"
7304,"        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }"
7305,"        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }"
7306,"        public final K getKey()       { return key; }
        public final V getValue()     { return val; }"
7307,"        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }"
7308,"        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }"
7309,"        public final String toString(){ return key + ""="" + val; }
"
7310,"        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7311,"        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }"
7312,"    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }"
7313,"    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        UNSAFE.putObjectVolatile(this, counterOffset, new LongAdder());

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;"
7314,"    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7315,"    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7316,"    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7317,"    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7318,"    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7319,"    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7320,"    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7321,"    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7322,"    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7323,"    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7324,"    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7325,"    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7326,"    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7327,"    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7328,"    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7329,"        public ConcurrentHashMapV8<K,V> getMap() { return map; }
"
7330,"        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }"
7331,"        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }"
7332,"        public final void clear()               { map.clear(); }
"
7333,"        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7334,"        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7335,"        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long counterOffset;
    private static final long sizeCtlOffset;
    private static final long ABASE;
    private static final int ASHIFT;

    static {
        int ss;
        try {
            UNSAFE = getUnsafe();
            Class<?> k = ConcurrentHashMapV8.class;
            counterOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""counter""));
            sizeCtlOffset = UNSAFE.objectFieldOffset
                    (k.getDeclaredField(""sizeCtl""));
            Class<?> sc = Node[].class;
            ABASE = UNSAFE.arrayBaseOffset(sc);
            ss = UNSAFE.arrayIndexScale(sc);
        } catch (Exception e) {
            throw new Error(e);
        }
        if ((ss & (ss-1)) != 0)
            throw new Error(""data type scale not a power of two"");
        ASHIFT = 31 - Integer.numberOfLeadingZeros(ss);
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }
}"
7336,"        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }"
7337,"        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }"
7338,"        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }"
7339,"        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }"
7340,"        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }"
7341,"        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }"
7342,"        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }"
7343,"        public V getMappedValue() { return value; }
"
7344,"        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }"
7345,"        public boolean remove(Object o)   { return map.remove(o) != null; }
"
7346,"        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {"
7347,"        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }"
7348,"        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }"
7349,"        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||"
7350,"        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {"
7351,"        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }"
7352,"        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }"
7353,"        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }"
7354,"        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }"
7355,"        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7356,"        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7357,"        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }"
7358,"        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }"
7359,"        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }"
7360,"        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||"
7361,"    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();"
7362,"                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});"
7363,"    final long fn(long v, long x) { return v + x; }
"
7364,"    public void add(long x) {
        Cell[] as; long b, v; HashCode hc; Cell a; int n;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;"
7365,"    public void increment() {
        add(1L);
    }"
7366,"    public void decrement() {
        add(-1L);
    }"
7367,"    public long sum() {
        long sum = base;
        Cell[] as = cells;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null)
                    sum += a.value;
            }
        }
        return sum;
    }"
7368,"    public void reset() {
        internalReset(0L);
    }"
7369,"    public long sumThenReset() {
        long sum = base;
        Cell[] as = cells;
        base = 0L;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null) {
                    sum += a.value;
                    a.value = 0L;
                }
            }
        }
        return sum;
    }"
7370,"    public String toString() {
        return Long.toString(sum());
    }"
7371,"    public long longValue() {
        return sum();
    }"
7372,"    public int intValue() {
        return (int)sum();
    }"
7373,"    public float floatValue() {
        return (float)sum();
    }"
7374,"    public double doubleValue() {
        return (double)sum();
    }"
7375,"    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        s.defaultWriteObject();
        s.writeLong(sum());
    }"
7376,"    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        busy = 0;
        cells = null;
        base = s.readLong();
    }"
7377,"        final boolean cas(long cmp, long val) {
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
        }"
7378,"        public HashCode initialValue() { return new HashCode(); }
    }"
7379,"    final boolean casBase(long cmp, long val) {
        return UNSAFE.compareAndSwapLong(this, baseOffset, cmp, val);
    }"
7380,"    final boolean casBusy() {
        return UNSAFE.compareAndSwapInt(this, busyOffset, 0, 1);
    }"
7381,"    abstract long fn(long currentValue, long newValue);

    /**
     * Handles cases of updates involving initialization, resizing,
     * creating new Cells, and/or contention. See above for
     * explanation. This method suffers the usual non-modularity
     * problems of optimistic retry code, relying on rechecked sets of
     * reads.
     *
     * @param x the value
     * @param hc the hash code holder
     * @param wasUncontended false if CAS failed before call
     */
    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {
                if ((a = as[(n - 1) & h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 && casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 && casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h << 13;                   // Rehash
                h ^= h >>> 17;
                h ^= h << 5;
            }
            else if (busy == 0 && cells == as && casBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }


    /**
     * Sets base and all cells to the given value.
     */
    final void internalReset(long initialValue) {
        Cell[] as = cells;
        base = initialValue;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null)
                    a.value = initialValue;
            }
        }
    }

    // Unsafe mechanics
    private static final sun.misc.Unsafe UNSAFE;
    private static final long baseOffset;
    private static final long busyOffset;
    static {
        try {
            UNSAFE = getUnsafe();
            Class<?> sk = Striped64.class;
            baseOffset = UNSAFE.objectFieldOffset
                    (sk.getDeclaredField(""base""));
            busyOffset = UNSAFE.objectFieldOffset
                    (sk.getDeclaredField(""busy""));
        } catch (Exception e) {
            throw new Error(e);
        }
    }

    /**
     * Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package.
     * Replace with a simple call to Unsafe.getUnsafe when integrating
     * into a jdk.
     *
     * @return a sun.misc.Unsafe
     */
    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            try {
                return java.security.AccessController.doPrivileged
                        (new java.security
                                .PrivilegedExceptionAction<sun.misc.Unsafe>() {
                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});
            } catch (java.security.PrivilegedActionException e) {
                throw new RuntimeException(""Could not initialize intrinsics"",
                        e.getCause());
            }
        }
    }

}"
7382,"    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {
                if ((a = as[(n - 1) & h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 && casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 && casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h << 13;                   // Rehash
                h ^= h >>> 17;
                h ^= h << 5;
            }
            else if (busy == 0 && cells == as && casBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }"
7383,"    final void internalReset(long initialValue) {
        Cell[] as = cells;
        base = initialValue;
        if (as != null) {
            int n = as.length;"
7384,"    private static sun.misc.Unsafe getUnsafe() {
        try {
            return sun.misc.Unsafe.getUnsafe();"
7385,"                            public sun.misc.Unsafe run() throws Exception {
                                java.lang.reflect.Field f = sun.misc
                                        .Unsafe.class.getDeclaredField(""theUnsafe"");
                                f.setAccessible(true);
                                return (sun.misc.Unsafe) f.get(null);
                            }});"
7386,"        Spliterator<T> split();
    }


    /*
     * Overview:
     *
     * The primary design goal of this hash table is to maintain
     * concurrent readability (typically method get(), but also
     * iterators and related methods) while minimizing update
     * contention. Secondary goals are to keep space consumption about
     * the same or better than java.util.HashMap, and to support high
     * initial insertion rates on an empty table by many threads.
     *
     * Each key-value mapping is held in a Node.  Because Node fields
     * can contain special values, they are defined using plain Object
     * types. Similarly in turn, all internal methods that use them
     * work off Object types. And similarly, so do the internal
     * methods of auxiliary iterator and view classes.  All public
     * generic typed methods relay in/out of these internal methods,
     * supplying null-checks and casts as needed. This also allows
     * many of the public methods to be factored into a smaller number
     * of internal methods (although sadly not so for the five
     * variants of put-related operations). The validation-based
     * approach explained below leads to a lot of code sprawl because
     * retry-control precludes factoring into smaller methods.
     *
     * The table is lazily initialized to a power-of-two size upon the
     * first insertion.  Each bin in the table normally contains a
     * list of Nodes (most often, the list has only zero or one Node).
     * Table accesses require volatile/atomic reads, writes, and
     * CASes.  Because there is no other way to arrange this without
     * adding further indirections, we use intrinsics
     * (sun.misc.Unsafe) operations.  The lists of nodes within bins
     * are always accurately traversable under volatile reads, so long
     * as lookups check hash code and non-nullness of value before
     * checking key equality.
     *
     * We use the top two bits of Node hash fields for control
     * purposes -- they are available anyway because of addressing
     * constraints.  As explained further below, these top bits are
     * used as follows:
     *  00 - Normal
     *  01 - Locked
     *  11 - Locked and may have a thread waiting for lock
     *  10 - Node is a forwarding node
     *
     * The lower 30 bits of each Node's hash field contain a
     * transformation of the key's hash code, except for forwarding
     * nodes, for which the lower bits are zero (and so always have
     * hash field == MOVED).
     *
     * Insertion (via put or its variants) of the first node in an
     * empty bin is performed by just CASing it to the bin.  This is
     * by far the most common case for put operations under most
     * key/hash distributions.  Other update operations (insert,
     * delete, and replace) require locks.  We do not want to waste
     * the space required to associate a distinct lock object with
     * each bin, so instead use the first node of a bin list itself as
     * a lock. Blocking support for these locks relies on the builtin
     * ""synchronized"" monitors.  However, we also need a tryLock
     * construction, so we overlay these by using bits of the Node
     * hash field for lock control (see above), and so normally use
     * builtin monitors only for blocking and signalling using
     * wait/notifyAll constructions. See Node.tryAwaitLock.
     *
     * Using the first node of a list as a lock does not by itself
     * suffice though: When a node is locked, any update must first
     * validate that it is still the first node after locking it, and
     * retry if not. Because new nodes are always appended to lists,
     * once a node is first in a bin, it remains first until deleted
     * or the bin becomes invalidated (upon resizing).  However,
     * operations that only conditionally update may inspect nodes
     * until the point of update. This is a converse of sorts to the
     * lazy locking technique described by Herlihy & Shavit.
     *
     * The main disadvantage of per-bin locks is that other update
     * operations on other nodes in a bin list protected by the same
     * lock can stall, for example when user equals() or mapping
     * functions take a long time.  However, statistically, under
     * random hash codes, this is not a common problem.  Ideally, the
     * frequency of nodes in bins follows a Poisson distribution
     * (http://en.wikipedia.org/wiki/Poisson_distribution) with a
     * parameter of about 0.5 on average, given the resizing threshold
     * of 0.75, although with a large variance because of resizing
     * granularity. Ignoring variance, the expected occurrences of
     * list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)). The
     * first values are:
     *
     * 0:    0.60653066
     * 1:    0.30326533
     * 2:    0.07581633
     * 3:    0.01263606
     * 4:    0.00157952
     * 5:    0.00015795
     * 6:    0.00001316
     * 7:    0.00000094
     * 8:    0.00000006
     * more: less than 1 in ten million
     *
     * Lock contention probability for two threads accessing distinct
     * elements is roughly 1 / (8 * #elements) under random hashes.
     *
     * Actual hash code distributions encountered in practice
     * sometimes deviate significantly from uniform randomness.  This
     * includes the case when N > (1<<30), so some keys MUST collide.
     * Similarly for dumb or hostile usages in which multiple keys are
     * designed to have identical hash codes. Also, although we guard
     * against the worst effects of this (see method spread), sets of
     * hashes may differ only in bits that do not impact their bin
     * index for a given power-of-two mask.  So we use a secondary
     * strategy that applies when the number of nodes in a bin exceeds
     * a threshold, and at least one of the keys implements
     * Comparable.  These TreeBins use a balanced tree to hold nodes
     * (a specialized form of red-black trees), bounding search time
     * to O(log N).  Each search step in a TreeBin is around twice as
     * slow as in a regular list, but given that N cannot exceed
     * (1<<64) (before running out of addresses) this bounds search
     * steps, lock hold times, etc, to reasonable constants (roughly
     * 100 nodes inspected per operation worst case) so long as keys
     * are Comparable (which is very common -- String, Long, etc).
     * TreeBin nodes (TreeNodes) also maintain the same ""next""
     * traversal pointers as regular nodes, so can be traversed in
     * iterators in the same way.
     *
     * The table is resized when occupancy exceeds a percentage
     * threshold (nominally, 0.75, but see below).  Only a single
     * thread performs the resize (using field ""sizeCtl"", to arrange
     * exclusion), but the table otherwise remains usable for reads
     * and updates. Resizing proceeds by transferring bins, one by
     * one, from the table to the next table.  Because we are using
     * power-of-two expansion, the elements from each bin must either
     * stay at same index, or move with a power of two offset. We
     * eliminate unnecessary node creation by catching cases where old
     * nodes can be reused because their next fields won't change.  On
     * average, only about one-sixth of them need cloning when a table
     * doubles. The nodes they replace will be garbage collectable as
     * soon as they are no longer referenced by any reader thread that
     * may be in the midst of concurrently traversing table.  Upon
     * transfer, the old table bin contains only a special forwarding
     * node (with hash field ""MOVED"") that contains the next table as
     * its key. On encountering a forwarding node, access and update
     * operations restart, using the new table.
     *
     * Each bin transfer requires its bin lock. However, unlike other
     * cases, a transfer can skip a bin if it fails to acquire its
     * lock, and revisit it later (unless it is a TreeBin). Method
     * rebuild maintains a buffer of TRANSFER_BUFFER_SIZE bins that
     * have been skipped because of failure to acquire a lock, and
     * blocks only if none are available (i.e., only very rarely).
     * The transfer operation must also ensure that all accessible
     * bins in both the old and new table are usable by any traversal.
     * When there are no lock acquisition failures, this is arranged
     * simply by proceeding from the last bin (table.length - 1) up
     * towards the first.  Upon seeing a forwarding node, traversals
     * (see class Iter) arrange to move to the new table
     * without revisiting nodes.  However, when any node is skipped
     * during a transfer, all earlier table bins may have become
     * visible, so are initialized with a reverse-forwarding node back
     * to the old table until the new ones are established. (This
     * sometimes requires transiently locking a forwarding node, which
     * is possible under the above encoding.) These more expensive
     * mechanics trigger only when necessary.
     *
     * The traversal scheme also applies to partial traversals of
     * ranges of bins (via an alternate Traverser constructor)
     * to support partitioned aggregate operations.  Also, read-only
     * operations give up if ever forwarded to a null table, which
     * provides support for shutdown-style clearing, which is also not
     * currently implemented.
     *
     * Lazy table initialization minimizes footprint until first use,
     * and also avoids resizings when the first operation is from a
     * putAll, constructor with map argument, or deserialization.
     * These cases attempt to override the initial capacity settings,
     * but harmlessly fail to take effect in cases of races.
     *
     * The element count is maintained using a LongAdder, which avoids
     * contention on updates but can encounter cache thrashing if read
     * too frequently during concurrent access. To avoid reading so
     * often, resizing is attempted either when a bin lock is
     * contended, or upon adding to a bin already holding two or more
     * nodes (checked before adding in the xIfAbsent methods, after
     * adding in others). Under uniform hash distributions, the
     * probability of this occurring at threshold is around 13%,
     * meaning that only about 1 in 8 puts check threshold (and after
     * resizing, many fewer do so). But this approximation has high
     * variance for small table sizes, so we check on any collision
     * for sizes <= 64. The bulk putAll operation further reduces
     * contention by only committing count updates upon these size
     * checks.
     *
     * Maintaining API and serialization compatibility with previous
     * versions of this class introduces several oddities. Mainly: We
     * leave untouched but unused constructor arguments refering to
     * concurrencyLevel. We accept a loadFactor constructor argument,
     * but apply it only to initial table capacity (which is the only
     * time that we can guarantee to honor it.) We also declare an
     * unused ""Segment"" class that is instantiated in minimal form
     * only when serializing.
     */

    /* ---------------- Constants -------------- */

    /**
     * The largest possible table capacity.  This value must be
     * exactly 1<<30 to stay within Java array allocation and indexing
     * bounds for power of two table sizes, and is further required
     * because the top two bits of 32bit hash fields are used for
     * control purposes.
     */
    private static final int MAXIMUM_CAPACITY = 1 << 30;

    /**
     * The default initial table capacity.  Must be a power of 2
     * (i.e., at least 1) and at most MAXIMUM_CAPACITY.
     */
    private static final int DEFAULT_CAPACITY = 16;

    /**
     * The largest possible (non-power of two) array size.
     * Needed by toArray and related methods.
     */
    static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

    /**
     * The default concurrency level for this table. Unused but
     * defined for compatibility with previous versions of this class.
     */
    private static final int DEFAULT_CONCURRENCY_LEVEL = 16;

    /**
     * The load factor for this table. Overrides of this value in
     * constructors affect only the initial table capacity.  The
     * actual floating point value isn't normally used -- it is
     * simpler to use expressions such as {@code n - (n >>> 2)} for
     * the associated resizing threshold.
     */
    private static final float LOAD_FACTOR = 0.75f;

    /**
     * The buffer size for skipped bins during transfers. The
     * value is arbitrary but should be large enough to avoid
     * most locking stalls during resizes.
     */
    private static final int TRANSFER_BUFFER_SIZE = 32;

    /**
     * The bin count threshold for using a tree rather than list for a
     * bin.  The value reflects the approximate break-even point for
     * using tree-based operations.
     * Note that Doug's version defaults to 8, but when dealing with
     * Ruby objects it is actually beneficial to avoid TreeNodes
     * as long as possible as it usually means going into Ruby land.
     */
    private static final int TREE_THRESHOLD = 16;

    /*
     * Encodings for special uses of Node hash fields. See above for
     * explanation.
     */
    static final int MOVED     = 0x80000000; // hash field for forwarding nodes
    static final int LOCKED    = 0x40000000; // set/tested only as a bit
    static final int WAITING   = 0xc0000000; // both bits set/tested together
    static final int HASH_BITS = 0x3fffffff; // usable bits of normal node hash

    /* ---------------- Fields -------------- */

    /**
     * The array of bins. Lazily initialized upon first insertion.
     * Size is always a power of two. Accessed directly by iterators.
     */
    transient volatile AtomicReferenceArray<Node> table;

    /**
     * The counter maintaining number of elements.
     */
    private transient LongAdder counter;

    /**
     * Table initialization and resizing control.  When negative, the
     * table is being initialized or resized. Otherwise, when table is
     * null, holds the initial table size to use upon creation, or 0
     * for default. After initialization, holds the next element count
     * value upon which to resize the table.
     */
    private transient volatile int sizeCtl;

    // views
    private transient KeySetView<K,V> keySet;
    private transient ValuesView<K,V> values;
    private transient EntrySetView<K,V> entrySet;

    /** For serialization compatibility. Null unless serialized; see below */
    private Segment<K,V>[] segments;

    static AtomicIntegerFieldUpdater SIZE_CTRL_UPDATER = AtomicIntegerFieldUpdater.newUpdater(ConcurrentHashMapV8.class, ""sizeCtl"");

    /* ---------------- Table element access -------------- */

    /*
     * Volatile access methods are used for table elements as well as
     * elements of in-progress next table while resizing.  Uses are
     * null checked by callers, and implicitly bounds-checked, relying
     * on the invariants that tab arrays have non-zero size, and all
     * indices are masked with (tab.length - 1) which is never
     * negative and always less than length. Note that, to be correct
     * wrt arbitrary concurrency errors by users, bounds checks must
     * operate on local variables, which accounts for some odd-looking
     * inline assignments below.
     */

    static final Node tabAt(AtomicReferenceArray<Node> tab, int i) { // used by Iter
        return tab.get(i);
    }

    private static final boolean casTabAt(AtomicReferenceArray<Node> tab, int i, Node c, Node v) {
        return tab.compareAndSet(i, c, v);
    }

    private static final void setTabAt(AtomicReferenceArray<Node> tab, int i, Node v) {
        tab.set(i, v);
    }

    /* ---------------- Nodes -------------- */

    /**
     * Key-value entry. Note that this is never exported out as a
     * user-visible Map.Entry (see MapEntry below). Nodes with a hash
     * field of MOVED are special, and do not contain user keys or
     * values.  Otherwise, keys are never null, and null val fields
     * indicate that a node is in the process of being deleted or
     * created. For purposes of read-only access, a key may be read
     * before a val, but can only be used after checking val to be
     * non-null.
     */
    static class Node {
        volatile int hash;
        final Object key;
        volatile Object val;
        volatile Node next;

        static AtomicIntegerFieldUpdater HASH_UPDATER = AtomicIntegerFieldUpdater.newUpdater(Node.class, ""hash"");

        Node(int hash, Object key, Object val, Node next) {
            this.hash = hash;
            this.key = key;
            this.val = val;
            this.next = next;
        }

        /** CompareAndSet the hash field */
        final boolean casHash(int cmp, int val) {
            return HASH_UPDATER.compareAndSet(this, cmp, val);
        }

        /** The number of spins before blocking for a lock */
        static final int MAX_SPINS =
                Runtime.getRuntime().availableProcessors() > 1 ? 64 : 1;

        /**
         * Spins a while if LOCKED bit set and this node is the first
         * of its bin, and then sets WAITING bits on hash field and
         * blocks (once) if they are still set.  It is OK for this
         * method to return even if lock is not available upon exit,
         * which enables these simple single-wait mechanics.
         *
         * The corresponding signalling operation is performed within
         * callers: Upon detecting that WAITING has been set when
         * unlocking lock (via a failed CAS from non-waiting LOCKED
         * state), unlockers acquire the sync lock and perform a
         * notifyAll.
         *
         * The initial sanity check on tab and bounds is not currently
         * necessary in the only usages of this method, but enables
         * use in other future contexts.
         */
        final void tryAwaitLock(AtomicReferenceArray<Node> tab, int i) {
            if (tab != null && i >= 0 && i < tab.length()) { // sanity check
                int r = ThreadLocalRandom.current().nextInt(); // randomize spins
                int spins = MAX_SPINS, h;
                while (tabAt(tab, i) == this && ((h = hash) & LOCKED) != 0) {
                    if (spins >= 0) {
                        r ^= r << 1; r ^= r >>> 3; r ^= r << 10; // xorshift
                        if (r >= 0 && --spins == 0)
                            Thread.yield();  // yield before block
                    }
                    else if (casHash(h, h | WAITING)) {
                        synchronized (this) {
                            if (tabAt(tab, i) == this &&
                                    (hash & WAITING) == WAITING) {
                                try {
                                    wait();
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                }
                            }
                            else
                                notifyAll(); // possibly won race vs signaller
                        }
                        break;
                    }
                }
            }
        }
    }

    /* ---------------- TreeBins -------------- */

    /**
     * Nodes for use in TreeBins
     */
    static final class TreeNode extends Node {
        TreeNode parent;  // red-black tree links
        TreeNode left;
        TreeNode right;
        TreeNode prev;    // needed to unlink next upon deletion
        boolean red;

        TreeNode(int hash, Object key, Object val, Node next, TreeNode parent) {
            super(hash, key, val, next);
            this.parent = parent;
        }
    }

    /**
     * A specialized form of red-black tree for use in bins
     * whose size exceeds a threshold.
     *
     * TreeBins use a special form of comparison for search and
     * related operations (which is the main reason we cannot use
     * existing collections such as TreeMaps). TreeBins contain
     * Comparable elements, but may contain others, as well as
     * elements that are Comparable but not necessarily Comparable<T>
     * for the same T, so we cannot invoke compareTo among them. To
     * handle this, the tree is ordered primarily by hash value, then
     * by getClass().getName() order, and then by Comparator order
     * among elements of the same class.  On lookup at a node, if
     * elements are not comparable or compare as 0, both left and
     * right children may need to be searched in the case of tied hash
     * values. (This corresponds to the full list search that would be
     * necessary if all elements were non-Comparable and had tied
     * hashes.)  The red-black balancing code is updated from
     * pre-jdk-collections
     * (http://gee.cs.oswego.edu/dl/classes/collections/RBCell.java)
     * based in turn on Cormen, Leiserson, and Rivest ""Introduction to
     * Algorithms"" (CLR).
     *
     * TreeBins also maintain a separate locking discipline than
     * regular bins. Because they are forwarded via special MOVED
     * nodes at bin heads (which can never change once established),
     * we cannot use those nodes as locks. Instead, TreeBin
     * extends AbstractQueuedSynchronizer to support a simple form of
     * read-write lock. For update operations and table validation,
     * the exclusive form of lock behaves in the same way as bin-head
     * locks. However, lookups use shared read-lock mechanics to allow
     * multiple readers in the absence of writers.  Additionally,
     * these lookups do not ever block: While the lock is not
     * available, they proceed along the slow traversal path (via
     * next-pointers) until the lock becomes available or the list is
     * exhausted, whichever comes first. (These cases are not fast,
     * but maximize aggregate expected throughput.)  The AQS mechanics
     * for doing this are straightforward.  The lock state is held as
     * AQS getState().  Read counts are negative; the write count (1)
     * is positive.  There are no signalling preferences among readers
     * and writers. Since we don't need to export full Lock API, we
     * just override the minimal AQS methods and use them directly.
     */
    static final class TreeBin extends AbstractQueuedSynchronizer {
        private static final long serialVersionUID = 2249069246763182397L;
        transient TreeNode root;  // root of tree
        transient TreeNode first; // head of next-pointer list

        /* AQS overrides */
        public final boolean isHeldExclusively() { return getState() > 0; }
        public final boolean tryAcquire(int ignore) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }
        public final boolean tryRelease(int ignore) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }
        public final int tryAcquireShared(int ignore) {
            for (int c;;) {
                if ((c = getState()) > 0)
                    return -1;
                if (compareAndSetState(c, c -1))
                    return 1;
            }
        }
        public final boolean tryReleaseShared(int ignore) {
            int c;
            do {} while (!compareAndSetState(c = getState(), c + 1));
            return c == -1;
        }

        /** From CLR */
        private void rotateLeft(TreeNode p) {
            if (p != null) {
                TreeNode r = p.right, pp, rl;
                if ((rl = p.right = r.left) != null)
                    rl.parent = p;
                if ((pp = r.parent = p.parent) == null)
                    root = r;
                else if (pp.left == p)
                    pp.left = r;
                else
                    pp.right = r;
                r.left = p;
                p.parent = r;
            }
        }

        /** From CLR */
        private void rotateRight(TreeNode p) {
            if (p != null) {
                TreeNode l = p.left, pp, lr;
                if ((lr = p.left = l.right) != null)
                    lr.parent = p;
                if ((pp = l.parent = p.parent) == null)
                    root = l;
                else if (pp.right == p)
                    pp.right = l;
                else
                    pp.left = l;
                l.right = p;
                p.parent = l;
            }
        }

        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, Object k, TreeNode p) {
            return getTreeNode(h, (RubyObject)k, p);
        }

        /**
         * Returns the TreeNode (or null if not found) for the given key
         * starting at given root.
         */
        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, RubyObject k, TreeNode p) {
            RubyClass c = k.getMetaClass(); boolean kNotComparable = !k.respondsTo(""<=>"");
            while (p != null) {
                int dir, ph;  RubyObject pk; RubyClass pc;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = (RubyClass)pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pl, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            // try to continue iterating on the left side
                            else if ((pl = p.left) != null && h <= pl.hash)
                                dir = -1;
                            else // no matching node found
                                return null;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                p = (dir > 0) ? p.right : p.left;
            }
            return null;
        }

        int rubyCompare(RubyObject l, RubyObject r) {
            ThreadContext context = l.getMetaClass().getRuntime().getCurrentContext();
            IRubyObject result;
            try {
                result = l.callMethod(context, ""<=>"", r);
            } catch (RaiseException e) {
                // handle objects ""lying"" about responding to <=>, ie: an Array containing non-comparable keys
                if (context.runtime.getNoMethodError().isInstance(e.getException())) {
                    return 0;
                }
                throw e;
            }

            return result.isNil() ? 0 : RubyNumeric.num2int(result.convertToInteger());
        }

        /**
         * Wrapper for getTreeNode used by CHM.get. Tries to obtain
         * read-lock to call getTreeNode, but during failure to get
         * lock, searches along next links.
         */
        final Object getValue(int h, Object k) {
            Node r = null;
            int c = getState(); // Must read lock state first
            for (Node e = first; e != null; e = e.next) {
                if (c <= 0 && compareAndSetState(c, c - 1)) {
                    try {
                        r = getTreeNode(h, k, root);
                    } finally {
                        releaseShared(0);
                    }
                    break;
                }
                else if ((e.hash & HASH_BITS) == h && k.equals(e.key)) {
                    r = e;
                    break;
                }
                else
                    c = getState();
            }
            return r == null ? null : r.val;
        }

        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
                (int h, Object k, Object v) {
            return putTreeNode(h, (RubyObject)k, v);
        }

        /**
         * Finds or adds a node.
         * @return null if added
         */
        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
        (int h, RubyObject k, Object v) {
            RubyClass c = k.getMetaClass();
            boolean kNotComparable = !k.respondsTo(""<=>"");
            TreeNode pp = root, p = null;
            int dir = 0;
            while (pp != null) { // find existing node or leaf to insert at
                int ph;  RubyObject pk; RubyClass pc;
                p = pp;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            else // continue descending down the left subtree
                                dir = -1;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                pp = (dir > 0) ? p.right : p.left;
            }

            TreeNode f = first;
            TreeNode x = first = new TreeNode(h, (Object)k, v, f, p);
            if (p == null)
                root = x;
            else { // attach and rebalance; adapted from CLR
                TreeNode xp, xpp;
                if (f != null)
                    f.prev = x;
                if (dir <= 0)
                    p.left = x;
                else
                    p.right = x;
                x.red = true;
                while (x != null && (xp = x.parent) != null && xp.red &&
                        (xpp = xp.parent) != null) {
                    TreeNode xppl = xpp.left;
                    if (xp == xppl) {
                        TreeNode y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }
                    else {
                        TreeNode y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }
                }
                TreeNode r = root;
                if (r != null && r.red)
                    r.red = false;
            }
            return null;
        }

        /**
         * Removes the given node, that must be present before this
         * call.  This is messier than typical red-black deletion code
         * because we cannot swap the contents of an interior node
         * with a leaf successor that is pinned by ""next"" pointers
         * that are accessible independently of lock. So instead we
         * swap the tree linkages.
         */
        final void deleteTreeNode(TreeNode p) {
            TreeNode next = (TreeNode)p.next; // unlink traversal pointers
            TreeNode pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode replacement;
            TreeNode pl = p.left;
            TreeNode pr = p.right;
            if (pl != null && pr != null) {
                TreeNode s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode sr = s.right;
                TreeNode pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode x = replacement;
                while (x != null) {
                    TreeNode xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                    (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ? null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                    (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ? null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers
                    pp.left = null;
                else if (p == pp.right)
                    pp.right = null;
                p.parent = null;
            }
        }
    }

    /* ---------------- Collision reduction methods -------------- */

    /**
     * Spreads higher bits to lower, and also forces top 2 bits to 0.
     * Because the table uses power-of-two masking, sets of hashes
     * that vary only in bits above the current mask will always
     * collide. (Among known examples are sets of Float keys holding
     * consecutive whole numbers in small tables.)  To counter this,
     * we apply a transform that spreads the impact of higher bits
     * downward. There is a tradeoff between speed, utility, and
     * quality of bit-spreading. Because many common sets of hashes
     * are already reasonably distributed across bits (so don't benefit
     * from spreading), and because we use trees to handle large sets
     * of collisions in bins, we don't need excessively high quality.
     */
    private static final int spread(int h) {
        h ^= (h >>> 18) ^ (h >>> 12);
        return (h ^ (h >>> 10)) & HASH_BITS;
    }

    /**
     * Replaces a list bin with a tree bin. Call only when locked.
     * Fails to replace if the given key is non-comparable or table
     * is, or needs, resizing.
     */
    private final void replaceWithTreeBin(AtomicReferenceArray<Node> tab, int index, Object key) {
        if ((key instanceof Comparable) &&
                (tab.length() >= MAXIMUM_CAPACITY || counter.sum() < (long)sizeCtl)) {
            TreeBin t = new TreeBin();
            for (Node e = tabAt(tab, index); e != null; e = e.next)
                t.putTreeNode(e.hash & HASH_BITS, e.key, e.val);
            setTabAt(tab, index, new Node(MOVED, t, null, null));
        }
    }

    /* ---------------- Internal access and update methods -------------- */

    /** Implementation for get and containsKey */
    private final Object internalGet(Object k) {
        int h = spread(k.hashCode());
        retry: for (AtomicReferenceArray<Node> tab = table; tab != null;) {
            Node e, p; Object ek, ev; int eh;      // locals to read fields once
            for (e = tabAt(tab, (tab.length() - 1) & h); e != null; e = e.next) {
                if ((eh = e.hash) == MOVED) {
                    if ((ek = e.key) instanceof TreeBin)  // search TreeBin
                        return ((TreeBin)ek).getValue(h, k);
                    else {                        // restart with new table
                        tab = (AtomicReferenceArray<Node>)ek;
                        continue retry;
                    }
                }
                else if ((eh & HASH_BITS) == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                    return ev;
            }
            break;
        }
        return null;
    }

    /**
     * Implementation for the four public remove/replace methods:
     * Replaces node value with v, conditional upon match of cv if
     * non-null.  If resulting value is null, delete.
     */
    private final Object internalReplace(Object k, Object v, Object cv) {
        int h = spread(k.hashCode());
        Object oldVal = null;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null ||
                    (f = tabAt(tab, i = (tab.length() - 1) & h)) == null)
                break;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    boolean deleted = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null) {
                                Object pv = p.val;
                                if (cv == null || cv == pv || cv.equals(pv)) {
                                    oldVal = pv;
                                    if ((p.val = v) == null) {
                                        deleted = true;
                                        t.deleteTreeNode(p);
                                    }
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (validated) {
                        if (deleted)
                            counter.add(-1L);
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) != h && f.next == null) // precheck
                break;                          // rules out possible existence
            else if ((fh & LOCKED) != 0) {
                checkForResize();               // try resizing if can't get lock
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                boolean validated = false;
                boolean deleted = false;
                try {
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        for (Node e = f, pred = null;;) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    ((ev = e.val) != null) &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                if (cv == null || cv == ev || cv.equals(ev)) {
                                    oldVal = ev;
                                    if ((e.val = v) == null) {
                                        deleted = true;
                                        Node en = e.next;
                                        if (pred != null)
                                            pred.next = en;
                                        else
                                            setTabAt(tab, i, en);
                                    }
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (validated) {
                    if (deleted)
                        counter.add(-1L);
                    break;
                }
            }
        }
        return oldVal;
    }

    /*
     * Internal versions of the six insertion methods, each a
     * little more complicated than the last. All have
     * the same basic structure as the first (internalPut):
     *  1. If table uninitialized, create
     *  2. If bin empty, try to CAS new node
     *  3. If bin stale, use new table
     *  4. if bin converted to TreeBin, validate and relay to TreeBin methods
     *  5. Lock and validate; if valid, scan and add or update
     *
     * The others interweave other checks and/or alternative actions:
     *  * Plain put checks for and performs resize after insertion.
     *  * putIfAbsent prescans for mapping without lock (and fails to add
     *    if present), which also makes pre-emptive resize checks worthwhile.
     *  * computeIfAbsent extends form used in putIfAbsent with additional
     *    mechanics to deal with, calls, potential exceptions and null
     *    returns from function call.
     *  * compute uses the same function-call mechanics, but without
     *    the prescans
     *  * merge acts as putIfAbsent in the absent case, but invokes the
     *    update function if present
     *  * putAll attempts to pre-allocate enough table space
     *    and more lazily performs count updates and checks.
     *
     * Someday when details settle down a bit more, it might be worth
     * some factoring to reduce sprawl.
     */

    /** Implementation for put */
    private final Object internalPut(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null) {
                                oldVal = p.val;
                                p.val = v;
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                Object oldVal = null;
                try {                        // needed in case equals() throws
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                oldVal = ev;
                                e.val = v;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                last.next = new Node(h, k, v, null);
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {                  // unlock and signal if needed
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (oldVal != null)
                        return oldVal;
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }

    /** Implementation for putIfAbsent */
    private final Object internalPutIfAbsent(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null)
                                oldVal = p.val;
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) { // at least 2 nodes -- search and maybe resize
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    Object oldVal = null;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    oldVal = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    last.next = new Node(h, k, v, null);
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        if (tab.length() <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }

    /** Implementation for computeIfAbsent */
    private final Object internalComputeIfAbsent(K k,
                                                 Fun<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.apply(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.apply(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length() <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val != null) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for compute */
    @SuppressWarnings(""unchecked"") private final Object internalCompute
    (K k, boolean onlyIfPresent, BiFun<? super K, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.apply(k, null)) != null) {
                            node.val = val;
                            delta = 1;
                        }
                    } finally {
                        if (delta == 0)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv;
                            if (p == null) {
                                if (onlyIfPresent)
                                    break;
                                pv = null;
                            } else
                                pv = p.val;
                            if ((val = mf.apply(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent && (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node(h, k, val, null);
                                    delta = 1;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for merge */
    @SuppressWarnings(""unchecked"") private final Object internalMerge
    (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply((V)p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply((V)ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node(h, k, val, null);
                                delta = 1;
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }

    /** Implementation for putAll */
    private final void internalPutAll(Map<?, ?> m) {
        tryPresize(m.size());
        long delta = 0L;     // number of uncommitted additions
        boolean npe = false; // to throw exception on exit for nulls
        try {                // to clean up counts on other exceptions
            for (Map.Entry<?, ?> entry : m.entrySet()) {
                Object k, v;
                if (entry == null || (k = entry.getKey()) == null ||
                        (v = entry.getValue()) == null) {
                    npe = true;
                    break;
                }
                int h = spread(k.hashCode());
                for (AtomicReferenceArray<Node> tab = table;;) {
                    int i; Node f; int fh; Object fk;
                    if (tab == null)
                        tab = initTable();
                    else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null){
                        if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                            ++delta;
                            break;
                        }
                    }
                    else if ((fh = f.hash) == MOVED) {
                        if ((fk = f.key) instanceof TreeBin) {
                            TreeBin t = (TreeBin)fk;
                            boolean validated = false;
                            t.acquire(0);
                            try {
                                if (tabAt(tab, i) == f) {
                                    validated = true;
                                    TreeNode p = t.getTreeNode(h, k, t.root);
                                    if (p != null)
                                        p.val = v;
                                    else {
                                        t.putTreeNode(h, k, v);
                                        ++delta;
                                    }
                                }
                            } finally {
                                t.release(0);
                            }
                            if (validated)
                                break;
                        }
                        else
                            tab = (AtomicReferenceArray<Node>)fk;
                    }
                    else if ((fh & LOCKED) != 0) {
                        counter.add(delta);
                        delta = 0L;
                        checkForResize();
                        f.tryAwaitLock(tab, i);
                    }
                    else if (f.casHash(fh, fh | LOCKED)) {
                        int count = 0;
                        try {
                            if (tabAt(tab, i) == f) {
                                count = 1;
                                for (Node e = f;; ++count) {
                                    Object ek, ev;
                                    if ((e.hash & HASH_BITS) == h &&
                                            (ev = e.val) != null &&
                                            ((ek = e.key) == k || k.equals(ek))) {
                                        e.val = v;
                                        break;
                                    }
                                    Node last = e;
                                    if ((e = e.next) == null) {
                                        ++delta;
                                        last.next = new Node(h, k, v, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                        break;
                                    }
                                }
                            }
                        } finally {
                            if (!f.casHash(fh | LOCKED, fh)) {
                                f.hash = fh;
                                synchronized (f) { f.notifyAll(); };
                            }
                        }
                        if (count != 0) {
                            if (count > 1) {
                                counter.add(delta);
                                delta = 0L;
                                checkForResize();
                            }
                            break;
                        }
                    }
                }
            }
        } finally {
            if (delta != 0)
                counter.add(delta);
        }
        if (npe)
            throw new NullPointerException();
    }

    /* ---------------- Table Initialization and Resizing -------------- */

    /**
     * Returns a power of two table size for the given desired capacity.
     * See Hackers Delight, sec 3.2
     */
    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }

    /**
     * Initializes table, using the size recorded in sizeCtl.
     */
    private final AtomicReferenceArray<Node> initTable() {
        AtomicReferenceArray<Node> tab; int sc;
        while ((tab = table) == null) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                try {
                    if ((tab = table) == null) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        tab = table = new AtomicReferenceArray<Node>(n);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }

    /**
     * If table is too small and not already resizing, creates next
     * table and transfers bins.  Rechecks occupancy after a transfer
     * to see if another resize is already needed because resizings
     * are lagging additions.
     */
    private final void checkForResize() {
        AtomicReferenceArray<Node> tab; int n, sc;
        while ((tab = table) != null &&
                (n = tab.length()) < MAXIMUM_CAPACITY &&
                (sc = sizeCtl) >= 0 && counter.sum() >= (long)sc &&
                SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
            try {
                if (tab == table) {
                    table = rebuild(tab);
                    sc = (n << 1) - (n >>> 1);
                }
            } finally {
                sizeCtl = sc;
            }
        }
    }

    /**
     * Tries to presize table to accommodate the given number of elements.
     *
     * @param size number of elements (doesn't need to be perfectly accurate)
     */
    private final void tryPresize(int size) {
        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
                tableSizeFor(size + (size >>> 1) + 1);
        int sc;
        while ((sc = sizeCtl) >= 0) {
            AtomicReferenceArray<Node> tab = table; int n;
            if (tab == null || (n = tab.length()) == 0) {
                n = (sc > c) ? sc : c;
                if (SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                    try {
                        if (table == tab) {
                            table = new AtomicReferenceArray<Node>(n);
                            sc = n - (n >>> 2);
                        }
                    } finally {
                        sizeCtl = sc;
                    }
                }
            }
            else if (c <= sc || n >= MAXIMUM_CAPACITY)
                break;
            else if (SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                try {
                    if (table == tab) {
                        table = rebuild(tab);
                        sc = (n << 1) - (n >>> 1);
                    }
                } finally {
                    sizeCtl = sc;
                }
            }
        }
    }

    /*
     * Moves and/or copies the nodes in each bin to new table. See
     * above for explanation.
     *
     * @return the new table
     */
    private static final AtomicReferenceArray<Node> rebuild(AtomicReferenceArray<Node> tab) {
        int n = tab.length();
        AtomicReferenceArray<Node> nextTab = new AtomicReferenceArray<Node>(n << 1);
        Node fwd = new Node(MOVED, nextTab, null, null);
        int[] buffer = null;       // holds bins to revisit; null until needed
        Node rev = null;           // reverse forwarder; null until needed
        int nbuffered = 0;         // the number of bins in buffer list
        int bufferIndex = 0;       // buffer index of current buffered bin
        int bin = n - 1;           // current non-buffered bin or -1 if none

        for (int i = bin;;) {      // start upwards sweep
            int fh; Node f;
            if ((f = tabAt(tab, i)) == null) {
                if (bin >= 0) {    // Unbuffered; no lock needed (or available)
                    if (!casTabAt(tab, i, f, fwd))
                        continue;
                }
                else {             // transiently use a locked forwarding node
                    Node g = new Node(MOVED|LOCKED, nextTab, null, null);
                    if (!casTabAt(tab, i, f, g))
                        continue;
                    setTabAt(nextTab, i, null);
                    setTabAt(nextTab, i + n, null);
                    setTabAt(tab, i, fwd);
                    if (!g.casHash(MOVED|LOCKED, MOVED)) {
                        g.hash = MOVED;
                        synchronized (g) { g.notifyAll(); }
                    }
                }
            }
            else if ((fh = f.hash) == MOVED) {
                Object fk = f.key;
                if (fk instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            splitTreeBin(nextTab, i, t);
                            setTabAt(tab, i, fwd);
                        }
                    } finally {
                        t.release(0);
                    }
                    if (!validated)
                        continue;
                }
            }
            else if ((fh & LOCKED) == 0 && f.casHash(fh, fh|LOCKED)) {
                boolean validated = false;
                try {              // split to lo and hi lists; copying as needed
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        splitBin(nextTab, i, f);
                        setTabAt(tab, i, fwd);
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (!validated)
                    continue;
            }
            else {
                if (buffer == null) // initialize buffer for revisits
                    buffer = new int[TRANSFER_BUFFER_SIZE];
                if (bin < 0 && bufferIndex > 0) {
                    int j = buffer[--bufferIndex];
                    buffer[bufferIndex] = i;
                    i = j;         // swap with another bin
                    continue;
                }
                if (bin < 0 || nbuffered >= TRANSFER_BUFFER_SIZE) {
                    f.tryAwaitLock(tab, i);
                    continue;      // no other options -- block
                }
                if (rev == null)   // initialize reverse-forwarder
                    rev = new Node(MOVED, tab, null, null);
                if (tabAt(tab, i) != f || (f.hash & LOCKED) == 0)
                    continue;      // recheck before adding to list
                buffer[nbuffered++] = i;
                setTabAt(nextTab, i, rev);     // install place-holders
                setTabAt(nextTab, i + n, rev);
            }

            if (bin > 0)
                i = --bin;
            else if (buffer != null && nbuffered > 0) {
                bin = -1;
                i = buffer[bufferIndex = --nbuffered];
            }
            else
                return nextTab;
        }
    }

    /**
     * Splits a normal bin with list headed by e into lo and hi parts;
     * installs in given table.
     */
    private static void splitBin(AtomicReferenceArray<Node> nextTab, int i, Node e) {
        int bit = nextTab.length() >>> 1; // bit to split on
        int runBit = e.hash & bit;
        Node lastRun = e, lo = null, hi = null;
        for (Node p = e.next; p != null; p = p.next) {
            int b = p.hash & bit;
            if (b != runBit) {
                runBit = b;
                lastRun = p;
            }
        }
        if (runBit == 0)
            lo = lastRun;
        else
            hi = lastRun;
        for (Node p = e; p != lastRun; p = p.next) {
            int ph = p.hash & HASH_BITS;
            Object pk = p.key, pv = p.val;
            if ((ph & bit) == 0)
                lo = new Node(ph, pk, pv, lo);
            else
                hi = new Node(ph, pk, pv, hi);
        }
        setTabAt(nextTab, i, lo);
        setTabAt(nextTab, i + bit, hi);
    }

    /**
     * Splits a tree bin into lo and hi parts; installs in given table.
     */
    private static void splitTreeBin(AtomicReferenceArray<Node> nextTab, int i, TreeBin t) {
        int bit = nextTab.length() >>> 1;
        TreeBin lt = new TreeBin();
        TreeBin ht = new TreeBin();
        int lc = 0, hc = 0;
        for (Node e = t.first; e != null; e = e.next) {
            int h = e.hash & HASH_BITS;
            Object k = e.key, v = e.val;
            if ((h & bit) == 0) {
                ++lc;
                lt.putTreeNode(h, k, v);
            }
            else {
                ++hc;
                ht.putTreeNode(h, k, v);
            }
        }
        Node ln, hn; // throw away trees if too small
        if (lc <= (TREE_THRESHOLD >>> 1)) {
            ln = null;
            for (Node p = lt.first; p != null; p = p.next)
                ln = new Node(p.hash, p.key, p.val, ln);
        }
        else
            ln = new Node(MOVED, lt, null, null);
        setTabAt(nextTab, i, ln);
        if (hc <= (TREE_THRESHOLD >>> 1)) {
            hn = null;
            for (Node p = ht.first; p != null; p = p.next)
                hn = new Node(p.hash, p.key, p.val, hn);
        }
        else
            hn = new Node(MOVED, ht, null, null);
        setTabAt(nextTab, i + bit, hn);
    }

    /**
     * Implementation for clear. Steps through each bin, removing all
     * nodes.
     */
    private final void internalClear() {
        long delta = 0L; // negative number of deletions
        int i = 0;
        AtomicReferenceArray<Node> tab = table;
        while (tab != null && i < tab.length()) {
            int fh; Object fk;
            Node f = tabAt(tab, i);
            if (f == null)
                ++i;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            for (Node p = t.first; p != null; p = p.next) {
                                if (p.val != null) { // (currently always true)
                                    p.val = null;
                                    --delta;
                                }
                            }
                            t.first = null;
                            t.root = null;
                            ++i;
                        }
                    } finally {
                        t.release(0);
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                counter.add(delta); // opportunistically update count
                delta = 0L;
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        for (Node e = f; e != null; e = e.next) {
                            if (e.val != null) {  // (currently always true)
                                e.val = null;
                                --delta;
                            }
                        }
                        setTabAt(tab, i, null);
                        ++i;
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
            }
        }
        if (delta != 0)
            counter.add(delta);
    }

    /* ----------------Table Traversal -------------- */

    /**
     * Encapsulates traversal for methods such as containsValue; also
     * serves as a base class for other iterators and bulk tasks.
     *
     * At each step, the iterator snapshots the key (""nextKey"") and
     * value (""nextVal"") of a valid node (i.e., one that, at point of
     * snapshot, has a non-null user value). Because val fields can
     * change (including to null, indicating deletion), field nextVal
     * might not be accurate at point of use, but still maintains the
     * weak consistency property of holding a value that was once
     * valid. To support iterator.remove, the nextKey field is not
     * updated (nulled out) when the iterator cannot advance.
     *
     * Internal traversals directly access these fields, as in:
     * {@code while (it.advance() != null) { process(it.nextKey); }}
     *
     * Exported iterators must track whether the iterator has advanced
     * (in hasNext vs next) (by setting/checking/nulling field
     * nextVal), and then extract key, value, or key-value pairs as
     * return values of next().
     *
     * The iterator visits once each still-valid node that was
     * reachable upon iterator construction. It might miss some that
     * were added to a bin after the bin was visited, which is OK wrt
     * consistency guarantees. Maintaining this property in the face
     * of possible ongoing resizes requires a fair amount of
     * bookkeeping state that is difficult to optimize away amidst
     * volatile accesses.  Even so, traversal maintains reasonable
     * throughput.
     *
     * Normally, iteration proceeds bin-by-bin traversing lists.
     * However, if the table has been resized, then all future steps
     * must traverse both the bin at the current index as well as at
     * (index + baseSize); and so on for further resizings. To
     * paranoically cope with potential sharing by users of iterators
     * across threads, iteration terminates if a bounds checks fails
     * for a table read.
     *
     * This class extends ForkJoinTask to streamline parallel
     * iteration in bulk operations (see BulkTask). This adds only an
     * int of space overhead, which is close enough to negligible in
     * cases where it is not needed to not worry about it.  Because
     * ForkJoinTask is Serializable, but iterators need not be, we
     * need to add warning suppressions.
     */
    @SuppressWarnings(""serial"") static class Traverser<K,V,R> {
        final ConcurrentHashMapV8<K, V> map;
        Node next;           // the next entry to use
        K nextKey;      // cached key field of next
        V nextVal;      // cached val field of next
        AtomicReferenceArray<Node> tab;          // current table; updated if resized
        int index;           // index of bin to use next
        int baseIndex;       // current index of initial table
        int baseLimit;       // index bound for initial table
        int baseSize;        // initial table size

        /** Creates iterator for all entries in the table. */
        Traverser(ConcurrentHashMapV8<K, V> map) {
            this.map = map;
        }

        /** Creates iterator for split() methods */
        Traverser(Traverser<K,V,?> it) {
            ConcurrentHashMapV8<K, V> m; AtomicReferenceArray<Node> t;
            if ((m = this.map = it.map) == null)
                t = null;
            else if ((t = it.tab) == null && // force parent tab initialization
                    (t = it.tab = m.table) != null)
                it.baseLimit = it.baseSize = t.length();
            this.tab = t;
            this.baseSize = it.baseSize;
            it.baseLimit = this.index = this.baseIndex =
                    ((this.baseLimit = it.baseLimit) + it.baseIndex + 1) >>> 1;
        }

        /**
         * Advances next; returns nextVal or null if terminated.
         * See above for explanation.
         */
        final V advance() {
            Node e = next;
            V ev = null;
            outer: do {
                if (e != null)                  // advance past used/skipped node
                    e = e.next;
                while (e == null) {             // get to next non-null bin
                    ConcurrentHashMapV8<K, V> m;
                    AtomicReferenceArray<Node> t; int b, i, n; Object ek; // checks must use locals
                    if ((t = tab) != null)
                        n = t.length();
                    else if ((m = map) != null && (t = tab = m.table) != null)
                        n = baseLimit = baseSize = t.length();
                    else
                        break outer;
                    if ((b = baseIndex) >= baseLimit ||
                            (i = index) < 0 || i >= n)
                        break outer;
                    if ((e = tabAt(t, i)) != null && e.hash == MOVED) {
                        if ((ek = e.key) instanceof TreeBin)
                            e = ((TreeBin)ek).first;
                        else {
                            tab = (AtomicReferenceArray<Node>)ek;
                            continue;           // restarts due to null val
                        }
                    }                           // visit upper slots if present
                    index = (i += baseSize) < n ? i : (baseIndex = b + 1);
                }
                nextKey = (K) e.key;
            } while ((ev = (V) e.val) == null);    // skip deleted or special nodes
            next = e;
            return nextVal = ev;
        }

        public final void remove() {
            Object k = nextKey;
            if (k == null && (advance() == null || (k = nextKey) == null))
                throw new IllegalStateException();
            map.internalReplace(k, null, null);
        }

        public final boolean hasNext() {
            return nextVal != null || advance() != null;
        }

        public final boolean hasMoreElements() { return hasNext(); }
        public final void setRawResult(Object x) { }
        public R getRawResult() { return null; }
        public boolean exec() { return true; }
    }

    /* ---------------- Public operations -------------- */

    /**
     * Creates a new, empty map with the default initial table size (16).
     */
    public ConcurrentHashMapV8() {
        this.counter = new LongAdder();
    }

    /**
     * Creates a new, empty map with an initial table size
     * accommodating the specified number of elements without the need
     * to dynamically resize.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     */
    public ConcurrentHashMapV8(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                MAXIMUM_CAPACITY :
                tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new map with the same mappings as the given map.
     *
     * @param m the map
     */
    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {
        this.counter = new LongAdder();
        this.sizeCtl = DEFAULT_CAPACITY;
        internalPutAll(m);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}) and
     * initial table density ({@code loadFactor}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative or the load factor is nonpositive
     *
     * @since 1.6
     */
    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}), table
     * density ({@code loadFactor}), and number of concurrently
     * updating threads ({@code concurrencyLevel}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation may use this value as
     * a sizing hint.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive
     */
    public ConcurrentHashMapV8(int initialCapacity,
                               float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
                MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);
    }

    /**
     * {@inheritDoc}
     */
    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }

    /**
     * {@inheritDoc}
     */
    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                        (int)n);
    }

    /**
     * Returns the number of mappings. This method should be used
     * instead of {@link #size} because a ConcurrentHashMapV8 may
     * contain more mappings than can be represented as an int. The
     * value returned is a snapshot; the actual count may differ if
     * there are ongoing concurrent insertions or removals.
     *
     * @return the number of mappings
     */
    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * <p>More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or the given defaultValue if this map contains no mapping for the key.
     *
     * @param key the key
     * @param defaultValue the value to return if this map contains
     * no mapping for the given key
     * @return the mapping for the key, if present; else the defaultValue
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }

    /**
     * Tests if the specified object is a key in this table.
     *
     * @param  key   possible key
     * @return {@code true} if and only if the specified object
     *         is a key in this table, as determined by the
     *         {@code equals} method; {@code false} otherwise
     * @throws NullPointerException if the specified key is null
     */
    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value. Note: This method may require a full traversal
     * of the map, and is much slower than method {@code containsKey}.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if this map maps one or more keys to the
     *         specified value
     * @throws NullPointerException if the specified value is null
     */
    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }

    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }

    /**
     * Legacy method testing if some key maps into the specified value
     * in this table.  This method is identical in functionality to
     * {@link #containsValue}, and exists solely to ensure
     * full compatibility with class {@link java.util.Hashtable},
     * which supported this method prior to introduction of the
     * Java Collections framework.
     *
     * @param  value a value to search for
     * @return {@code true} if and only if some key maps to the
     *         {@code value} argument in this table as
     *         determined by the {@code equals} method;
     *         {@code false} otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean contains(Object value) {
        return containsValue(value);
    }

    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * <p>The value can be retrieved by calling the {@code get} method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }

    /**
     * Copies all of the mappings from the specified map to this one.
     * These mappings replace any mappings that this map had for any of the
     * keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     */
    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }

    /**
     * If the specified key is not already associated with a value,
     * computes its value using the given mappingFunction and enters
     * it into the map unless null.  This is equivalent to
     * <pre> {@code
     * if (map.containsKey(key))
     *   return map.get(key);
     * value = mappingFunction.apply(key);
     * if (value != null)
     *   map.put(key, value);
     * return value;}</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null} no mapping is recorded. If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and no mapping is recorded.  Some
     * attempted update operations on this map by other threads may be
     * blocked while computation is in progress, so the computation
     * should be short and simple, and must not attempt to update any
     * other mappings of this Map. The most appropriate usage is to
     * construct a new object serving as an initial mapped value, or
     * memoized result, as in:
     *
     *  <pre> {@code
     * map.computeIfAbsent(key, new Fun<K, V>() {
     *   public V map(K k) { return new Value(f(k)); }});}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param mappingFunction the function to compute a value
     * @return the current (existing or computed) value associated with
     *         the specified key, or null if the computed value is null
     * @throws NullPointerException if the specified key or mappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the mappingFunction does so,
     *         in which case the mapping is left unestablished
     */
    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }

    /**
     * If the given key is present, computes a new mapping value given a key and
     * its current mapped value. This is equivalent to
     *  <pre> {@code
     *   if (map.containsKey(key)) {
     *     value = remappingFunction.apply(key, map.get(key));
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }

    /**
     * Computes a new mapping value given a key and
     * its current mapped value (or {@code null} if there is no current
     * mapping). This is equivalent to
     *  <pre> {@code
     *   value = remappingFunction.apply(key, map.get(key));
     *   if (value != null)
     *     map.put(key, value);
     *   else
     *     map.remove(key);
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * <pre> {@code
     * Map<Key, String> map = ...;
     * final String msg = ...;
     * map.compute(key, new BiFun<Key, String, String>() {
     *   public String apply(Key k, String v) {
     *    return (v == null) ? msg : v + msg;});}}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }

    /**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * Otherwise, replace the value with the results of
     * the given remapping function. This is equivalent to:
     *  <pre> {@code
     *   if (!map.containsKey(key))
     *     map.put(value);
     *   else {
     *     newValue = remappingFunction.apply(map.get(key), value);
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map.
     */
    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }

    /**
     * Removes the key (and its corresponding value) from this map.
     * This method does nothing if the key is not in the map.
     *
     * @param  key the key that needs to be removed
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if the specified key is null
     */
    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if any of the arguments are null
     */
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }

    /**
     * Removes all of the mappings from this map.
     */
    public void clear() {
        internalClear();
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.
     *
     * @return the set view
     */
    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }

    /**
     * Returns a {@link Set} view of the keys in this map, using the
     * given common mapped value for any additions (i.e., {@link
     * Collection#add} and {@link Collection#addAll}). This is of
     * course only appropriate if it is acceptable to use the same
     * value for all additions from this view.
     *
     * @param mappedValue the mapped value to use for any
     * additions.
     * @return the set view
     * @throws NullPointerException if the mappedValue is null
     */
    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.
     */
    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or
     * {@code addAll} operations.
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }

    /**
     * Returns an enumeration of the keys in this table.
     *
     * @return an enumeration of the keys in this table
     * @see #keySet()
     */
    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns an enumeration of the values in this table.
     *
     * @return an enumeration of the values in this table
     * @see #values()
     */
    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the keys in this map.
     *
     * @return a partitionable iterator of the keys in this map
     */
    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the values in this map.
     *
     * @return a partitionable iterator of the values in this map
     */
    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the entries in this map.
     *
     * @return a partitionable iterator of the entries in this map
     */
    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }

    /**
     * Returns the hash code value for this {@link Map}, i.e.,
     * the sum of, for each key-value pair in the map,
     * {@code key.hashCode() ^ value.hashCode()}.
     *
     * @return the hash code value for this map
     */
    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }

    /**
     * Returns a string representation of this map.  The string
     * representation consists of a list of key-value mappings (in no
     * particular order) enclosed in braces (""{@code {}}"").  Adjacent
     * mappings are separated by the characters {@code "", ""} (comma
     * and space).  Each key-value mapping is rendered as the key
     * followed by an equals sign (""{@code =}"") followed by the
     * associated value.
     *
     * @return a string representation of this map
     */
    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }

    /**
     * Compares the specified object with this map for equality.
     * Returns {@code true} if the given object is a map with the same
     * mappings as this map.  This operation may return misleading
     * results if either map is concurrently modified during execution
     * of this method.
     *
     * @param o object to be compared for equality with this map
     * @return {@code true} if the specified object is equal to this map
     */
    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }

    /* ----------------Iterators -------------- */

    @SuppressWarnings(""serial"") static final class KeyIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<K>, Enumeration<K> {
        KeyIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        KeyIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }
        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }

        public final K nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class ValueIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<V>, Enumeration<V> {
        ValueIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        ValueIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }

        public final V nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class EntryIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<Map.Entry<K,V>> {
        EntryIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        EntryIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }
    }

    /**
     * Exported Entry for iterators
     */
    static final class MapEntry<K,V> implements Map.Entry<K, V> {
        final K key; // non-null
        V val;       // non-null
        final ConcurrentHashMapV8<K, V> map;
        MapEntry(K key, V val, ConcurrentHashMapV8<K, V> map) {
            this.key = key;
            this.val = val;
            this.map = map;
        }
        public final K getKey()       { return key; }
        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }

        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == val || v.equals(val)));
        }

        /**
         * Sets our entry's value and writes through to the map. The
         * value to return is somewhat arbitrary here. Since we do not
         * necessarily track asynchronous changes, the most recent
         * ""previous"" value could be different from what we return (or
         * could even have been removed in which case the put will
         * re-establish). We do not and cannot guarantee more.
         */
        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }
    }

    /* ---------------- Serialization Support -------------- */

    /**
     * Stripped-down version of helper class used in previous version,
     * declared for the sake of serialization compatibility
     */
    static class Segment<K,V> implements Serializable {
        private static final long serialVersionUID = 2249069246763182397L;
        final float loadFactor;
        Segment(float lf) { this.loadFactor = lf; }
    }

    /**
     * Saves the state of the {@code ConcurrentHashMapV8} instance to a
     * stream (i.e., serializes it).
     * @param s the stream
     * @serialData
     * the key (Object) and value (Object)
     * for each key-value mapping, followed by a null pair.
     * The key-value mappings are emitted in no particular order.
     */
    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     * @param s the stream
     */
    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        this.counter = new LongAdder();

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;
            int n;
            if (size >= (long)(MAXIMUM_CAPACITY >>> 1))
                n = MAXIMUM_CAPACITY;
            else {
                int sz = (int)size;
                n = tableSizeFor(sz + (sz >>> 1) + 1);
            }
            int sc = sizeCtl;
            boolean collide = false;
            if (n > sc &&
                    SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                try {
                    if (table == null) {
                        init = true;
                        AtomicReferenceArray<Node> tab = new AtomicReferenceArray<Node>(n);
                        int mask = n - 1;
                        while (p != null) {
                            int j = p.hash & mask;
                            Node next = p.next;
                            Node q = p.next = tabAt(tab, j);
                            setTabAt(tab, j, p);
                            if (!collide && q != null && q.hash == p.hash)
                                collide = true;
                            p = next;
                        }
                        table = tab;
                        counter.add(size);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                if (collide) { // rescan and convert to TreeBins
                    AtomicReferenceArray<Node> tab = table;
                    for (int i = 0; i < tab.length(); ++i) {
                        int c = 0;
                        for (Node e = tabAt(tab, i); e != null; e = e.next) {
                            if (++c > TREE_THRESHOLD &&
                                    (e.key instanceof Comparable)) {
                                replaceWithTreeBin(tab, i, e.key);
                                break;
                            }
                        }
                    }
                }
            }
            if (!init) { // Can only happen if unsafely published.
                while (p != null) {
                    internalPut(p.key, p.val);
                    p = p.next;
                }
            }
        }
    }


    // -------------------------------------------------------

    // Sams
    /** Interface describing a void action of one argument */
    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7387,"    static final Node tabAt(AtomicReferenceArray<Node> tab, int i) { // used by Iter
        return tab.get(i);
    }"
7388,"    private static final boolean casTabAt(AtomicReferenceArray<Node> tab, int i, Node c, Node v) {
        return tab.compareAndSet(i, c, v);
    }"
7389,"    private static final void setTabAt(AtomicReferenceArray<Node> tab, int i, Node v) {
        tab.set(i, v);
    }"
7390,"        final boolean casHash(int cmp, int val) {
            return HASH_UPDATER.compareAndSet(this, cmp, val);
        }"
7391,"        final void tryAwaitLock(AtomicReferenceArray<Node> tab, int i) {
            if (tab != null && i >= 0 && i < tab.length()) { // sanity check
                int r = ThreadLocalRandom.current().nextInt(); // randomize spins"
7392,"        public final boolean isHeldExclusively() { return getState() > 0; }
        public final boolean tryAcquire(int ignore) {"
7393,"        public final boolean tryAcquire(int ignore) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }"
7394,"        public final boolean tryRelease(int ignore) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }"
7395,"        public final int tryAcquireShared(int ignore) {
            for (int c;;) {
                if ((c = getState()) > 0)"
7396,"        public final boolean tryReleaseShared(int ignore) {
            int c;
            do {} while (!compareAndSetState(c = getState(), c + 1));
            return c == -1;
        }"
7397,"        private void rotateLeft(TreeNode p) {
            if (p != null) {
                TreeNode r = p.right, pp, rl;"
7398,"        private void rotateRight(TreeNode p) {
            if (p != null) {
                TreeNode l = p.left, pp, lr;"
7399,"        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, Object k, TreeNode p) {
            return getTreeNode(h, (RubyObject)k, p);
        }"
7400,"        @SuppressWarnings(""unchecked"") final TreeNode getTreeNode
        (int h, RubyObject k, TreeNode p) {
            RubyClass c = k.getMetaClass(); boolean kNotComparable = !k.respondsTo(""<=>"");
            while (p != null) {
                int dir, ph;  RubyObject pk; RubyClass pc;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = (RubyClass)pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pl, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            // try to continue iterating on the left side
                            else if ((pl = p.left) != null && h <= pl.hash)
                                dir = -1;
                            else // no matching node found
                                return null;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                p = (dir > 0) ? p.right : p.left;
            }
            return null;
        }"
7401,"        int rubyCompare(RubyObject l, RubyObject r) {
            ThreadContext context = l.getMetaClass().getRuntime().getCurrentContext();
            IRubyObject result;
            try {
                result = l.callMethod(context, ""<=>"", r);
            } catch (RaiseException e) {
                // handle objects ""lying"" about responding to <=>, ie: an Array containing non-comparable keys
                if (context.runtime.getNoMethodError().isInstance(e.getException())) {
                    return 0;
                }
                throw e;
            }

            return result.isNil() ? 0 : RubyNumeric.num2int(result.convertToInteger());
        }"
7402,"        final Object getValue(int h, Object k) {
            Node r = null;
            int c = getState(); // Must read lock state first
            for (Node e = first; e != null; e = e.next) {
                if (c <= 0 && compareAndSetState(c, c - 1)) {
                    try {
                        r = getTreeNode(h, k, root);
                    } finally {
                        releaseShared(0);
                    }
                    break;
                }
                else if ((e.hash & HASH_BITS) == h && k.equals(e.key)) {
                    r = e;
                    break;
                }
                else
                    c = getState();
            }
            return r == null ? null : r.val;
        }"
7403,"        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
                (int h, Object k, Object v) {
            return putTreeNode(h, (RubyObject)k, v);
        }"
7404,"        @SuppressWarnings(""unchecked"") final TreeNode putTreeNode
        (int h, RubyObject k, Object v) {
            RubyClass c = k.getMetaClass();
            boolean kNotComparable = !k.respondsTo(""<=>"");
            TreeNode pp = root, p = null;
            int dir = 0;
            while (pp != null) { // find existing node or leaf to insert at
                int ph;  RubyObject pk; RubyClass pc;
                p = pp;
                if ((ph = p.hash) == h) {
                    if ((pk = (RubyObject)p.key) == k || k.equals(pk))
                        return p;
                    if (c != (pc = pk.getMetaClass()) ||
                            kNotComparable ||
                            (dir = rubyCompare(k, pk)) == 0) {
                        dir = (c == pc) ? 0 : c.getName().compareTo(pc.getName());
                        if (dir == 0) { // if still stuck, need to check both sides
                            TreeNode r = null, pr;
                            // try to recurse on the right
                            if ((pr = p.right) != null && h >= pr.hash && (r = getTreeNode(h, k, pr)) != null)
                                return r;
                            else // continue descending down the left subtree
                                dir = -1;
                        }
                    }
                }
                else
                    dir = (h < ph) ? -1 : 1;
                pp = (dir > 0) ? p.right : p.left;
            }

            TreeNode f = first;
            TreeNode x = first = new TreeNode(h, (Object)k, v, f, p);
            if (p == null)
                root = x;
            else { // attach and rebalance; adapted from CLR
                TreeNode xp, xpp;
                if (f != null)
                    f.prev = x;
                if (dir <= 0)
                    p.left = x;
                else
                    p.right = x;
                x.red = true;
                while (x != null && (xp = x.parent) != null && xp.red &&
                        (xpp = xp.parent) != null) {
                    TreeNode xppl = xpp.left;
                    if (xp == xppl) {
                        TreeNode y = xpp.right;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.right) {
                                rotateLeft(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateRight(xpp);
                                }
                            }
                        }
                    }
                    else {
                        TreeNode y = xppl;
                        if (y != null && y.red) {
                            y.red = false;
                            xp.red = false;
                            xpp.red = true;
                            x = xpp;
                        }
                        else {
                            if (x == xp.left) {
                                rotateRight(x = xp);
                                xpp = (xp = x.parent) == null ? null : xp.parent;
                            }
                            if (xp != null) {
                                xp.red = false;
                                if (xpp != null) {
                                    xpp.red = true;
                                    rotateLeft(xpp);
                                }
                            }
                        }
                    }
                }
                TreeNode r = root;
                if (r != null && r.red)
                    r.red = false;
            }
            return null;
        }"
7405,"        final void deleteTreeNode(TreeNode p) {
            TreeNode next = (TreeNode)p.next; // unlink traversal pointers
            TreeNode pred = p.prev;
            if (pred == null)
                first = next;
            else
                pred.next = next;
            if (next != null)
                next.prev = pred;
            TreeNode replacement;
            TreeNode pl = p.left;
            TreeNode pr = p.right;
            if (pl != null && pr != null) {
                TreeNode s = pr, sl;
                while ((sl = s.left) != null) // find successor
                    s = sl;
                boolean c = s.red; s.red = p.red; p.red = c; // swap colors
                TreeNode sr = s.right;
                TreeNode pp = p.parent;
                if (s == pr) { // p was s's direct parent
                    p.parent = s;
                    s.right = p;
                }
                else {
                    TreeNode sp = s.parent;
                    if ((p.parent = sp) != null) {
                        if (s == sp.left)
                            sp.left = p;
                        else
                            sp.right = p;
                    }
                    if ((s.right = pr) != null)
                        pr.parent = s;
                }
                p.left = null;
                if ((p.right = sr) != null)
                    sr.parent = p;
                if ((s.left = pl) != null)
                    pl.parent = s;
                if ((s.parent = pp) == null)
                    root = s;
                else if (p == pp.left)
                    pp.left = s;
                else
                    pp.right = s;
                replacement = sr;
            }
            else
                replacement = (pl != null) ? pl : pr;
            TreeNode pp = p.parent;
            if (replacement == null) {
                if (pp == null) {
                    root = null;
                    return;
                }
                replacement = p;
            }
            else {
                replacement.parent = pp;
                if (pp == null)
                    root = replacement;
                else if (p == pp.left)
                    pp.left = replacement;
                else
                    pp.right = replacement;
                p.left = p.right = p.parent = null;
            }
            if (!p.red) { // rebalance, from CLR
                TreeNode x = replacement;
                while (x != null) {
                    TreeNode xp, xpl;
                    if (x.red || (xp = x.parent) == null) {
                        x.red = false;
                        break;
                    }
                    if (x == (xpl = xp.left)) {
                        TreeNode sib = xp.right;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateLeft(xp);
                            sib = (xp = x.parent) == null ? null : xp.right;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sr == null || !sr.red) &&
                                    (sl == null || !sl.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sr == null || !sr.red) {
                                    if (sl != null)
                                        sl.red = false;
                                    sib.red = true;
                                    rotateRight(sib);
                                    sib = (xp = x.parent) == null ? null : xp.right;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sr = sib.right) != null)
                                        sr.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateLeft(xp);
                                }
                                x = root;
                            }
                        }
                    }
                    else { // symmetric
                        TreeNode sib = xpl;
                        if (sib != null && sib.red) {
                            sib.red = false;
                            xp.red = true;
                            rotateRight(xp);
                            sib = (xp = x.parent) == null ? null : xp.left;
                        }
                        if (sib == null)
                            x = xp;
                        else {
                            TreeNode sl = sib.left, sr = sib.right;
                            if ((sl == null || !sl.red) &&
                                    (sr == null || !sr.red)) {
                                sib.red = true;
                                x = xp;
                            }
                            else {
                                if (sl == null || !sl.red) {
                                    if (sr != null)
                                        sr.red = false;
                                    sib.red = true;
                                    rotateLeft(sib);
                                    sib = (xp = x.parent) == null ? null : xp.left;
                                }
                                if (sib != null) {
                                    sib.red = (xp == null) ? false : xp.red;
                                    if ((sl = sib.left) != null)
                                        sl.red = false;
                                }
                                if (xp != null) {
                                    xp.red = false;
                                    rotateRight(xp);
                                }
                                x = root;
                            }
                        }
                    }
                }
            }
            if (p == replacement && (pp = p.parent) != null) {
                if (p == pp.left) // detach pointers"
7406,"    private static final int spread(int h) {
        h ^= (h >>> 18) ^ (h >>> 12);
        return (h ^ (h >>> 10)) & HASH_BITS;
    }"
7407,"    private final void replaceWithTreeBin(AtomicReferenceArray<Node> tab, int index, Object key) {
        if ((key instanceof Comparable) &&
                (tab.length() >= MAXIMUM_CAPACITY || counter.sum() < (long)sizeCtl)) {"
7408,"    private final Object internalGet(Object k) {
        int h = spread(k.hashCode());
        retry: for (AtomicReferenceArray<Node> tab = table; tab != null;) {
            Node e, p; Object ek, ev; int eh;      // locals to read fields once
            for (e = tabAt(tab, (tab.length() - 1) & h); e != null; e = e.next) {
                if ((eh = e.hash) == MOVED) {
                    if ((ek = e.key) instanceof TreeBin)  // search TreeBin
                        return ((TreeBin)ek).getValue(h, k);
                    else {                        // restart with new table
                        tab = (AtomicReferenceArray<Node>)ek;
                        continue retry;
                    }
                }
                else if ((eh & HASH_BITS) == h && (ev = e.val) != null &&
                        ((ek = e.key) == k || k.equals(ek)))
                    return ev;
            }
            break;
        }
        return null;
    }"
7409,"    private final Object internalReplace(Object k, Object v, Object cv) {
        int h = spread(k.hashCode());
        Object oldVal = null;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null ||
                    (f = tabAt(tab, i = (tab.length() - 1) & h)) == null)
                break;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean validated = false;
                    boolean deleted = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            validated = true;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null) {
                                Object pv = p.val;
                                if (cv == null || cv == pv || cv.equals(pv)) {
                                    oldVal = pv;
                                    if ((p.val = v) == null) {
                                        deleted = true;
                                        t.deleteTreeNode(p);
                                    }
                                }
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (validated) {
                        if (deleted)
                            counter.add(-1L);
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) != h && f.next == null) // precheck
                break;                          // rules out possible existence
            else if ((fh & LOCKED) != 0) {
                checkForResize();               // try resizing if can't get lock
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                boolean validated = false;
                boolean deleted = false;
                try {
                    if (tabAt(tab, i) == f) {
                        validated = true;
                        for (Node e = f, pred = null;;) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    ((ev = e.val) != null) &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                if (cv == null || cv == ev || cv.equals(ev)) {
                                    oldVal = ev;
                                    if ((e.val = v) == null) {
                                        deleted = true;
                                        Node en = e.next;
                                        if (pred != null)
                                            pred.next = en;
                                        else
                                            setTabAt(tab, i, en);
                                    }
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null)
                                break;
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (validated) {
                    if (deleted)
                        counter.add(-1L);
                    break;
                }
            }
        }
        return oldVal;
    }"
7410,"    private final Object internalPut(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;                   // no lock when adding to empty bin
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null) {
                                oldVal = p.val;
                                p.val = v;
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                Object oldVal = null;
                try {                        // needed in case equals() throws
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                oldVal = ev;
                                e.val = v;
                                break;
                            }
                            Node last = e;
                            if ((e = e.next) == null) {
                                last.next = new Node(h, k, v, null);
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {                  // unlock and signal if needed
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (oldVal != null)
                        return oldVal;
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }"
7411,"    private final Object internalPutIfAbsent(Object k, Object v) {
        int h = spread(k.hashCode());
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null)))
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    Object oldVal = null;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 2;
                            TreeNode p = t.putTreeNode(h, k, v);
                            if (p != null)
                                oldVal = p.val;
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) { // at least 2 nodes -- search and maybe resize
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    Object oldVal = null;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    oldVal = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    last.next = new Node(h, k, v, null);
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (oldVal != null)
                            return oldVal;
                        if (tab.length() <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        counter.add(1L);
        if (count > 1)
            checkForResize();
        return null;
    }"
7412,"    private final Object internalComputeIfAbsent(K k,
                                                 Fun<? super K, ?> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    count = 1;
                    try {
                        if ((val = mf.apply(k)) != null)
                            node.val = val;
                    } finally {
                        if (val == null)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    boolean added = false;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            if (p != null)
                                val = p.val;
                            else if ((val = mf.apply(k)) != null) {
                                added = true;
                                count = 2;
                                t.putTreeNode(h, k, val);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        break;
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & HASH_BITS) == h && (fv = f.val) != null &&
                    ((fk = f.key) == k || k.equals(fk)))
                return fv;
            else {
                Node g = f.next;
                if (g != null) {
                    for (Node e = g;;) {
                        Object ek, ev;
                        if ((e.hash & HASH_BITS) == h && (ev = e.val) != null &&
                                ((ek = e.key) == k || k.equals(ek)))
                            return ev;
                        if ((e = e.next) == null) {
                            checkForResize();
                            break;
                        }
                    }
                }
                if (((fh = f.hash) & LOCKED) != 0) {
                    checkForResize();
                    f.tryAwaitLock(tab, i);
                }
                else if (tabAt(tab, i) == f && f.casHash(fh, fh | LOCKED)) {
                    boolean added = false;
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            for (Node e = f;; ++count) {
                                Object ek, ev;
                                if ((e.hash & HASH_BITS) == h &&
                                        (ev = e.val) != null &&
                                        ((ek = e.key) == k || k.equals(ek))) {
                                    val = ev;
                                    break;
                                }
                                Node last = e;
                                if ((e = e.next) == null) {
                                    if ((val = mf.apply(k)) != null) {
                                        added = true;
                                        last.next = new Node(h, k, val, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                    }
                                    break;
                                }
                            }
                        }
                    } finally {
                        if (!f.casHash(fh | LOCKED, fh)) {
                            f.hash = fh;
                            synchronized (f) { f.notifyAll(); };
                        }
                    }
                    if (count != 0) {
                        if (!added)
                            return val;
                        if (tab.length() <= 64)
                            count = 2;
                        break;
                    }
                }
            }
        }
        if (val != null) {
            counter.add(1L);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7413,"    @SuppressWarnings(""unchecked"") private final Object internalCompute
    (K k, boolean onlyIfPresent, BiFun<? super K, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            Node f; int i, fh; Object fk;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (onlyIfPresent)
                    break;
                Node node = new Node(fh = h | LOCKED, k, null, null);
                if (casTabAt(tab, i, null, node)) {
                    try {
                        count = 1;
                        if ((val = mf.apply(k, null)) != null) {
                            node.val = val;
                            delta = 1;
                        }
                    } finally {
                        if (delta == 0)
                            setTabAt(tab, i, null);
                        if (!node.casHash(fh, h)) {
                            node.hash = h;
                            synchronized (node) { node.notifyAll(); };
                        }
                    }
                }
                if (count != 0)
                    break;
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            Object pv;
                            if (p == null) {
                                if (onlyIfPresent)
                                    break;
                                pv = null;
                            } else
                                pv = p.val;
                            if ((val = mf.apply(k, (V)pv)) != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply(k, (V)ev);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                if (!onlyIfPresent && (val = mf.apply(k, null)) != null) {
                                    pred.next = new Node(h, k, val, null);
                                    delta = 1;
                                    if (count >= TREE_THRESHOLD)
                                        replaceWithTreeBin(tab, i, k);
                                }
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7414,"    @SuppressWarnings(""unchecked"") private final Object internalMerge
    (K k, V v, BiFun<? super V, ? super V, ? extends V> mf) {
        int h = spread(k.hashCode());
        Object val = null;
        int delta = 0;
        int count = 0;
        for (AtomicReferenceArray<Node> tab = table;;) {
            int i; Node f; int fh; Object fk, fv;
            if (tab == null)
                tab = initTable();
            else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null) {
                if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                    delta = 1;
                    val = v;
                    break;
                }
            }
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            count = 1;
                            TreeNode p = t.getTreeNode(h, k, t.root);
                            val = (p == null) ? v : mf.apply((V)p.val, v);
                            if (val != null) {
                                if (p != null)
                                    p.val = val;
                                else {
                                    count = 2;
                                    delta = 1;
                                    t.putTreeNode(h, k, val);
                                }
                            }
                            else if (p != null) {
                                delta = -1;
                                t.deleteTreeNode(p);
                            }
                        }
                    } finally {
                        t.release(0);
                    }
                    if (count != 0)
                        break;
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                checkForResize();
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        count = 1;
                        for (Node e = f, pred = null;; ++count) {
                            Object ek, ev;
                            if ((e.hash & HASH_BITS) == h &&
                                    (ev = e.val) != null &&
                                    ((ek = e.key) == k || k.equals(ek))) {
                                val = mf.apply((V)ev, v);
                                if (val != null)
                                    e.val = val;
                                else {
                                    delta = -1;
                                    Node en = e.next;
                                    if (pred != null)
                                        pred.next = en;
                                    else
                                        setTabAt(tab, i, en);
                                }
                                break;
                            }
                            pred = e;
                            if ((e = e.next) == null) {
                                val = v;
                                pred.next = new Node(h, k, val, null);
                                delta = 1;
                                if (count >= TREE_THRESHOLD)
                                    replaceWithTreeBin(tab, i, k);
                                break;
                            }
                        }
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
                if (count != 0) {
                    if (tab.length() <= 64)
                        count = 2;
                    break;
                }
            }
        }
        if (delta != 0) {
            counter.add((long)delta);
            if (count > 1)
                checkForResize();
        }
        return val;
    }"
7415,"    private final void internalPutAll(Map<?, ?> m) {
        tryPresize(m.size());
        long delta = 0L;     // number of uncommitted additions
        boolean npe = false; // to throw exception on exit for nulls
        try {                // to clean up counts on other exceptions
            for (Map.Entry<?, ?> entry : m.entrySet()) {
                Object k, v;
                if (entry == null || (k = entry.getKey()) == null ||
                        (v = entry.getValue()) == null) {
                    npe = true;
                    break;
                }
                int h = spread(k.hashCode());
                for (AtomicReferenceArray<Node> tab = table;;) {
                    int i; Node f; int fh; Object fk;
                    if (tab == null)
                        tab = initTable();
                    else if ((f = tabAt(tab, i = (tab.length() - 1) & h)) == null){
                        if (casTabAt(tab, i, null, new Node(h, k, v, null))) {
                            ++delta;
                            break;
                        }
                    }
                    else if ((fh = f.hash) == MOVED) {
                        if ((fk = f.key) instanceof TreeBin) {
                            TreeBin t = (TreeBin)fk;
                            boolean validated = false;
                            t.acquire(0);
                            try {
                                if (tabAt(tab, i) == f) {
                                    validated = true;
                                    TreeNode p = t.getTreeNode(h, k, t.root);
                                    if (p != null)
                                        p.val = v;
                                    else {
                                        t.putTreeNode(h, k, v);
                                        ++delta;
                                    }
                                }
                            } finally {
                                t.release(0);
                            }
                            if (validated)
                                break;
                        }
                        else
                            tab = (AtomicReferenceArray<Node>)fk;
                    }
                    else if ((fh & LOCKED) != 0) {
                        counter.add(delta);
                        delta = 0L;
                        checkForResize();
                        f.tryAwaitLock(tab, i);
                    }
                    else if (f.casHash(fh, fh | LOCKED)) {
                        int count = 0;
                        try {
                            if (tabAt(tab, i) == f) {
                                count = 1;
                                for (Node e = f;; ++count) {
                                    Object ek, ev;
                                    if ((e.hash & HASH_BITS) == h &&
                                            (ev = e.val) != null &&
                                            ((ek = e.key) == k || k.equals(ek))) {
                                        e.val = v;
                                        break;
                                    }
                                    Node last = e;
                                    if ((e = e.next) == null) {
                                        ++delta;
                                        last.next = new Node(h, k, v, null);
                                        if (count >= TREE_THRESHOLD)
                                            replaceWithTreeBin(tab, i, k);
                                        break;
                                    }
                                }
                            }
                        } finally {
                            if (!f.casHash(fh | LOCKED, fh)) {
                                f.hash = fh;
                                synchronized (f) { f.notifyAll(); };
                            }
                        }
                        if (count != 0) {
                            if (count > 1) {
                                counter.add(delta);
                                delta = 0L;
                                checkForResize();
                            }
                            break;
                        }
                    }
                }
            }
        } finally {
            if (delta != 0)
                counter.add(delta);
        }
        if (npe)
            throw new NullPointerException();"
7416,"    private static final int tableSizeFor(int c) {
        int n = c - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }"
7417,"    private final AtomicReferenceArray<Node> initTable() {
        AtomicReferenceArray<Node> tab; int sc;
        while ((tab = table) == null) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            else if (SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                try {
                    if ((tab = table) == null) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        tab = table = new AtomicReferenceArray<Node>(n);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }"
7418,"    private final void checkForResize() {
        AtomicReferenceArray<Node> tab; int n, sc;
        while ((tab = table) != null &&
                (n = tab.length()) < MAXIMUM_CAPACITY &&"
7419,"    private final void tryPresize(int size) {
        int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY :
                tableSizeFor(size + (size >>> 1) + 1);
        int sc;
        while ((sc = sizeCtl) >= 0) {
            AtomicReferenceArray<Node> tab = table; int n;"
7420,"    private static final AtomicReferenceArray<Node> rebuild(AtomicReferenceArray<Node> tab) {
        int n = tab.length();
        AtomicReferenceArray<Node> nextTab = new AtomicReferenceArray<Node>(n << 1);
        Node fwd = new Node(MOVED, nextTab, null, null);
        int[] buffer = null;       // holds bins to revisit; null until needed
        Node rev = null;           // reverse forwarder; null until needed
        int nbuffered = 0;         // the number of bins in buffer list
        int bufferIndex = 0;       // buffer index of current buffered bin
        int bin = n - 1;           // current non-buffered bin or -1 if none

        for (int i = bin;;) {      // start upwards sweep
            int fh; Node f;"
7421,"    private static void splitBin(AtomicReferenceArray<Node> nextTab, int i, Node e) {
        int bit = nextTab.length() >>> 1; // bit to split on
        int runBit = e.hash & bit;
        Node lastRun = e, lo = null, hi = null;
        for (Node p = e.next; p != null; p = p.next) {
            int b = p.hash & bit;
            if (b != runBit) {
                runBit = b;
                lastRun = p;
            }
        }
        if (runBit == 0)
            lo = lastRun;
        else
            hi = lastRun;
        for (Node p = e; p != lastRun; p = p.next) {
            int ph = p.hash & HASH_BITS;
            Object pk = p.key, pv = p.val;
            if ((ph & bit) == 0)
                lo = new Node(ph, pk, pv, lo);
            else
                hi = new Node(ph, pk, pv, hi);
        }
        setTabAt(nextTab, i, lo);
        setTabAt(nextTab, i + bit, hi);
    }"
7422,"    private static void splitTreeBin(AtomicReferenceArray<Node> nextTab, int i, TreeBin t) {
        int bit = nextTab.length() >>> 1;
        TreeBin lt = new TreeBin();
        TreeBin ht = new TreeBin();
        int lc = 0, hc = 0;
        for (Node e = t.first; e != null; e = e.next) {
            int h = e.hash & HASH_BITS;
            Object k = e.key, v = e.val;
            if ((h & bit) == 0) {
                ++lc;
                lt.putTreeNode(h, k, v);
            }
            else {
                ++hc;
                ht.putTreeNode(h, k, v);
            }
        }
        Node ln, hn; // throw away trees if too small
        if (lc <= (TREE_THRESHOLD >>> 1)) {
            ln = null;
            for (Node p = lt.first; p != null; p = p.next)
                ln = new Node(p.hash, p.key, p.val, ln);
        }
        else
            ln = new Node(MOVED, lt, null, null);
        setTabAt(nextTab, i, ln);
        if (hc <= (TREE_THRESHOLD >>> 1)) {
            hn = null;
            for (Node p = ht.first; p != null; p = p.next)
                hn = new Node(p.hash, p.key, p.val, hn);
        }
        else
            hn = new Node(MOVED, ht, null, null);
        setTabAt(nextTab, i + bit, hn);
    }"
7423,"    private final void internalClear() {
        long delta = 0L; // negative number of deletions
        int i = 0;
        AtomicReferenceArray<Node> tab = table;
        while (tab != null && i < tab.length()) {
            int fh; Object fk;
            Node f = tabAt(tab, i);
            if (f == null)
                ++i;
            else if ((fh = f.hash) == MOVED) {
                if ((fk = f.key) instanceof TreeBin) {
                    TreeBin t = (TreeBin)fk;
                    t.acquire(0);
                    try {
                        if (tabAt(tab, i) == f) {
                            for (Node p = t.first; p != null; p = p.next) {
                                if (p.val != null) { // (currently always true)
                                    p.val = null;
                                    --delta;
                                }
                            }
                            t.first = null;
                            t.root = null;
                            ++i;
                        }
                    } finally {
                        t.release(0);
                    }
                }
                else
                    tab = (AtomicReferenceArray<Node>)fk;
            }
            else if ((fh & LOCKED) != 0) {
                counter.add(delta); // opportunistically update count
                delta = 0L;
                f.tryAwaitLock(tab, i);
            }
            else if (f.casHash(fh, fh | LOCKED)) {
                try {
                    if (tabAt(tab, i) == f) {
                        for (Node e = f; e != null; e = e.next) {
                            if (e.val != null) {  // (currently always true)
                                e.val = null;
                                --delta;
                            }
                        }
                        setTabAt(tab, i, null);
                        ++i;
                    }
                } finally {
                    if (!f.casHash(fh | LOCKED, fh)) {
                        f.hash = fh;
                        synchronized (f) { f.notifyAll(); };
                    }
                }
            }
        }
        if (delta != 0)
            counter.add(delta);"
7424,"        final V advance() {
            Node e = next;
            V ev = null;
            outer: do {
                if (e != null)                  // advance past used/skipped node
                    e = e.next;
                while (e == null) {             // get to next non-null bin
                    ConcurrentHashMapV8<K, V> m;
                    AtomicReferenceArray<Node> t; int b, i, n; Object ek; // checks must use locals
                    if ((t = tab) != null)
                        n = t.length();
                    else if ((m = map) != null && (t = tab = m.table) != null)
                        n = baseLimit = baseSize = t.length();
                    else
                        break outer;
                    if ((b = baseIndex) >= baseLimit ||
                            (i = index) < 0 || i >= n)
                        break outer;
                    if ((e = tabAt(t, i)) != null && e.hash == MOVED) {
                        if ((ek = e.key) instanceof TreeBin)
                            e = ((TreeBin)ek).first;
                        else {
                            tab = (AtomicReferenceArray<Node>)ek;
                            continue;           // restarts due to null val
                        }
                    }                           // visit upper slots if present
                    index = (i += baseSize) < n ? i : (baseIndex = b + 1);
                }
                nextKey = (K) e.key;
            } while ((ev = (V) e.val) == null);    // skip deleted or special nodes
            next = e;
            return nextVal = ev;
        }"
7425,"        public final void remove() {
            Object k = nextKey;
            if (k == null && (advance() == null || (k = nextKey) == null))
                throw new IllegalStateException();
            map.internalReplace(k, null, null);
        }"
7426,"        public final boolean hasNext() {
            return nextVal != null || advance() != null;
        }"
7427,"        public final boolean hasMoreElements() { return hasNext(); }
        public final void setRawResult(Object x) { }"
7428,"        public final void setRawResult(Object x) { }
        public R getRawResult() { return null; }
        public boolean exec() { return true; }
    }

    /* ---------------- Public operations -------------- */

    /**
     * Creates a new, empty map with the default initial table size (16).
     */
    public ConcurrentHashMapV8() {
        this.counter = new LongAdder();
    }

    /**
     * Creates a new, empty map with an initial table size
     * accommodating the specified number of elements without the need
     * to dynamically resize.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     */
    public ConcurrentHashMapV8(int initialCapacity) {
        if (initialCapacity < 0)
            throw new IllegalArgumentException();
        int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
                MAXIMUM_CAPACITY :
                tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new map with the same mappings as the given map.
     *
     * @param m the map
     */
    public ConcurrentHashMapV8(Map<? extends K, ? extends V> m) {
        this.counter = new LongAdder();
        this.sizeCtl = DEFAULT_CAPACITY;
        internalPutAll(m);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}) and
     * initial table density ({@code loadFactor}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative or the load factor is nonpositive
     *
     * @since 1.6
     */
    public ConcurrentHashMapV8(int initialCapacity, float loadFactor) {
        this(initialCapacity, loadFactor, 1);
    }

    /**
     * Creates a new, empty map with an initial table size based on
     * the given number of elements ({@code initialCapacity}), table
     * density ({@code loadFactor}), and number of concurrently
     * updating threads ({@code concurrencyLevel}).
     *
     * @param initialCapacity the initial capacity. The implementation
     * performs internal sizing to accommodate this many elements,
     * given the specified load factor.
     * @param loadFactor the load factor (table density) for
     * establishing the initial table size
     * @param concurrencyLevel the estimated number of concurrently
     * updating threads. The implementation may use this value as
     * a sizing hint.
     * @throws IllegalArgumentException if the initial capacity is
     * negative or the load factor or concurrencyLevel are
     * nonpositive
     */
    public ConcurrentHashMapV8(int initialCapacity,
                               float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
                MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.counter = new LongAdder();
        this.sizeCtl = cap;
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);
    }

    /**
     * Creates a new {@link Set} backed by a ConcurrentHashMapV8
     * from the given type to {@code Boolean.TRUE}.
     *
     * @param initialCapacity The implementation performs internal
     * sizing to accommodate this many elements.
     * @throws IllegalArgumentException if the initial capacity of
     * elements is negative
     * @return the new set
     */
    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);
    }

    /**
     * {@inheritDoc}
     */
    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }

    /**
     * {@inheritDoc}
     */
    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
                        (int)n);
    }

    /**
     * Returns the number of mappings. This method should be used
     * instead of {@link #size} because a ConcurrentHashMapV8 may
     * contain more mappings than can be represented as an int. The
     * value returned is a snapshot; the actual count may differ if
     * there are ongoing concurrent insertions or removals.
     *
     * @return the number of mappings
     */
    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or {@code null} if this map contains no mapping for the key.
     *
     * <p>More formally, if this map contains a mapping from a key
     * {@code k} to a value {@code v} such that {@code key.equals(k)},
     * then this method returns {@code v}; otherwise it returns
     * {@code null}.  (There can be at most one such mapping.)
     *
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }

    /**
     * Returns the value to which the specified key is mapped,
     * or the given defaultValue if this map contains no mapping for the key.
     *
     * @param key the key
     * @param defaultValue the value to return if this map contains
     * no mapping for the given key
     * @return the mapping for the key, if present; else the defaultValue
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }

    /**
     * Tests if the specified object is a key in this table.
     *
     * @param  key   possible key
     * @return {@code true} if and only if the specified object
     *         is a key in this table, as determined by the
     *         {@code equals} method; {@code false} otherwise
     * @throws NullPointerException if the specified key is null
     */
    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }

    /**
     * Returns {@code true} if this map maps one or more keys to the
     * specified value. Note: This method may require a full traversal
     * of the map, and is much slower than method {@code containsKey}.
     *
     * @param value value whose presence in this map is to be tested
     * @return {@code true} if this map maps one or more keys to the
     *         specified value
     * @throws NullPointerException if the specified value is null
     */
    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }

    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }

    /**
     * Legacy method testing if some key maps into the specified value
     * in this table.  This method is identical in functionality to
     * {@link #containsValue}, and exists solely to ensure
     * full compatibility with class {@link java.util.Hashtable},
     * which supported this method prior to introduction of the
     * Java Collections framework.
     *
     * @param  value a value to search for
     * @return {@code true} if and only if some key maps to the
     *         {@code value} argument in this table as
     *         determined by the {@code equals} method;
     *         {@code false} otherwise
     * @throws NullPointerException if the specified value is null
     */
    public boolean contains(Object value) {
        return containsValue(value);
    }

    /**
     * Maps the specified key to the specified value in this table.
     * Neither the key nor the value can be null.
     *
     * <p>The value can be retrieved by calling the {@code get} method
     * with a key that is equal to the original key.
     *
     * @param key key with which the specified value is to be associated
     * @param value value to be associated with the specified key
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }

    /**
     * Copies all of the mappings from the specified map to this one.
     * These mappings replace any mappings that this map had for any of the
     * keys currently in the specified map.
     *
     * @param m mappings to be stored in this map
     */
    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }

    /**
     * If the specified key is not already associated with a value,
     * computes its value using the given mappingFunction and enters
     * it into the map unless null.  This is equivalent to
     * <pre> {@code
     * if (map.containsKey(key))
     *   return map.get(key);
     * value = mappingFunction.apply(key);
     * if (value != null)
     *   map.put(key, value);
     * return value;}</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null} no mapping is recorded. If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and no mapping is recorded.  Some
     * attempted update operations on this map by other threads may be
     * blocked while computation is in progress, so the computation
     * should be short and simple, and must not attempt to update any
     * other mappings of this Map. The most appropriate usage is to
     * construct a new object serving as an initial mapped value, or
     * memoized result, as in:
     *
     *  <pre> {@code
     * map.computeIfAbsent(key, new Fun<K, V>() {
     *   public V map(K k) { return new Value(f(k)); }});}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param mappingFunction the function to compute a value
     * @return the current (existing or computed) value associated with
     *         the specified key, or null if the computed value is null
     * @throws NullPointerException if the specified key or mappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the mappingFunction does so,
     *         in which case the mapping is left unestablished
     */
    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }

    /**
     * If the given key is present, computes a new mapping value given a key and
     * its current mapped value. This is equivalent to
     *  <pre> {@code
     *   if (map.containsKey(key)) {
     *     value = remappingFunction.apply(key, map.get(key));
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }

    /**
     * Computes a new mapping value given a key and
     * its current mapped value (or {@code null} if there is no current
     * mapping). This is equivalent to
     *  <pre> {@code
     *   value = remappingFunction.apply(key, map.get(key));
     *   if (value != null)
     *     map.put(key, value);
     *   else
     *     map.remove(key);
     * }</pre>
     *
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map. For example,
     * to either create or append new messages to a value mapping:
     *
     * <pre> {@code
     * Map<Key, String> map = ...;
     * final String msg = ...;
     * map.compute(key, new BiFun<Key, String, String>() {
     *   public String apply(Key k, String v) {
     *    return (v == null) ? msg : v + msg;});}}</pre>
     *
     * @param key key with which the specified value is to be associated
     * @param remappingFunction the function to compute a value
     * @return the new value associated with the specified key, or null if none
     * @throws NullPointerException if the specified key or remappingFunction
     *         is null
     * @throws IllegalStateException if the computation detectably
     *         attempts a recursive update to this map that would
     *         otherwise never complete
     * @throws RuntimeException or Error if the remappingFunction does so,
     *         in which case the mapping is unchanged
     */
    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }

    /**
     * If the specified key is not already associated
     * with a value, associate it with the given value.
     * Otherwise, replace the value with the results of
     * the given remapping function. This is equivalent to:
     *  <pre> {@code
     *   if (!map.containsKey(key))
     *     map.put(value);
     *   else {
     *     newValue = remappingFunction.apply(map.get(key), value);
     *     if (value != null)
     *       map.put(key, value);
     *     else
     *       map.remove(key);
     *   }
     * }</pre>
     * except that the action is performed atomically.  If the
     * function returns {@code null}, the mapping is removed.  If the
     * function itself throws an (unchecked) exception, the exception
     * is rethrown to its caller, and the current mapping is left
     * unchanged.  Some attempted update operations on this map by
     * other threads may be blocked while computation is in progress,
     * so the computation should be short and simple, and must not
     * attempt to update any other mappings of this Map.
     */
    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }

    /**
     * Removes the key (and its corresponding value) from this map.
     * This method does nothing if the key is not in the map.
     *
     * @param  key the key that needs to be removed
     * @return the previous value associated with {@code key}, or
     *         {@code null} if there was no mapping for {@code key}
     * @throws NullPointerException if the specified key is null
     */
    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if the specified key is null
     */
    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @throws NullPointerException if any of the arguments are null
     */
    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }

    /**
     * {@inheritDoc}
     *
     * @return the previous value associated with the specified key,
     *         or {@code null} if there was no mapping for the key
     * @throws NullPointerException if the specified key or value is null
     */
    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }

    /**
     * Removes all of the mappings from this map.
     */
    public void clear() {
        internalClear();
    }

    /**
     * Returns a {@link Set} view of the keys contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.
     *
     * @return the set view
     */
    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }

    /**
     * Returns a {@link Set} view of the keys in this map, using the
     * given common mapped value for any additions (i.e., {@link
     * Collection#add} and {@link Collection#addAll}). This is of
     * course only appropriate if it is acceptable to use the same
     * value for all additions from this view.
     *
     * @param mappedValue the mapped value to use for any
     * additions.
     * @return the set view
     * @throws NullPointerException if the mappedValue is null
     */
    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }

    /**
     * Returns a {@link Collection} view of the values contained in this map.
     * The collection is backed by the map, so changes to the map are
     * reflected in the collection, and vice-versa.
     */
    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }

    /**
     * Returns a {@link Set} view of the mappings contained in this map.
     * The set is backed by the map, so changes to the map are
     * reflected in the set, and vice-versa.  The set supports element
     * removal, which removes the corresponding mapping from the map,
     * via the {@code Iterator.remove}, {@code Set.remove},
     * {@code removeAll}, {@code retainAll}, and {@code clear}
     * operations.  It does not support the {@code add} or
     * {@code addAll} operations.
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }

    /**
     * Returns an enumeration of the keys in this table.
     *
     * @return an enumeration of the keys in this table
     * @see #keySet()
     */
    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns an enumeration of the values in this table.
     *
     * @return an enumeration of the values in this table
     * @see #values()
     */
    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the keys in this map.
     *
     * @return a partitionable iterator of the keys in this map
     */
    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the values in this map.
     *
     * @return a partitionable iterator of the values in this map
     */
    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }

    /**
     * Returns a partitionable iterator of the entries in this map.
     *
     * @return a partitionable iterator of the entries in this map
     */
    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }

    /**
     * Returns the hash code value for this {@link Map}, i.e.,
     * the sum of, for each key-value pair in the map,
     * {@code key.hashCode() ^ value.hashCode()}.
     *
     * @return the hash code value for this map
     */
    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }

    /**
     * Returns a string representation of this map.  The string
     * representation consists of a list of key-value mappings (in no
     * particular order) enclosed in braces (""{@code {}}"").  Adjacent
     * mappings are separated by the characters {@code "", ""} (comma
     * and space).  Each key-value mapping is rendered as the key
     * followed by an equals sign (""{@code =}"") followed by the
     * associated value.
     *
     * @return a string representation of this map
     */
    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }

    /**
     * Compares the specified object with this map for equality.
     * Returns {@code true} if the given object is a map with the same
     * mappings as this map.  This operation may return misleading
     * results if either map is concurrently modified during execution
     * of this method.
     *
     * @param o object to be compared for equality with this map
     * @return {@code true} if the specified object is equal to this map
     */
    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }

    /* ----------------Iterators -------------- */

    @SuppressWarnings(""serial"") static final class KeyIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<K>, Enumeration<K> {
        KeyIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        KeyIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }
        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }

        public final K nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class ValueIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<V>, Enumeration<V> {
        ValueIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        ValueIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }

        public final V nextElement() { return next(); }
    }

    @SuppressWarnings(""serial"") static final class EntryIterator<K,V> extends Traverser<K,V,Object>
            implements Spliterator<Map.Entry<K,V>> {
        EntryIterator(ConcurrentHashMapV8<K, V> map) { super(map); }
        EntryIterator(Traverser<K,V,Object> it) {
            super(it);
        }
        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }

        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }
    }

    /**
     * Exported Entry for iterators
     */
    static final class MapEntry<K,V> implements Map.Entry<K, V> {
        final K key; // non-null
        V val;       // non-null
        final ConcurrentHashMapV8<K, V> map;
        MapEntry(K key, V val, ConcurrentHashMapV8<K, V> map) {
            this.key = key;
            this.val = val;
            this.map = map;
        }
        public final K getKey()       { return key; }
        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }

        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    (k == key || k.equals(key)) &&
                    (v == val || v.equals(val)));
        }

        /**
         * Sets our entry's value and writes through to the map. The
         * value to return is somewhat arbitrary here. Since we do not
         * necessarily track asynchronous changes, the most recent
         * ""previous"" value could be different from what we return (or
         * could even have been removed in which case the put will
         * re-establish). We do not and cannot guarantee more.
         */
        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }
    }

    /* ---------------- Serialization Support -------------- */

    /**
     * Stripped-down version of helper class used in previous version,
     * declared for the sake of serialization compatibility
     */
    static class Segment<K,V> implements Serializable {
        private static final long serialVersionUID = 2249069246763182397L;
        final float loadFactor;
        Segment(float lf) { this.loadFactor = lf; }
    }

    /**
     * Saves the state of the {@code ConcurrentHashMapV8} instance to a
     * stream (i.e., serializes it).
     * @param s the stream
     * @serialData
     * the key (Object) and value (Object)
     * for each key-value mapping, followed by a null pair.
     * The key-value mappings are emitted in no particular order.
     */
    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }

    /**
     * Reconstitutes the instance from a stream (that is, deserializes it).
     * @param s the stream
     */
    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        this.counter = new LongAdder();

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;
            int n;
            if (size >= (long)(MAXIMUM_CAPACITY >>> 1))
                n = MAXIMUM_CAPACITY;
            else {
                int sz = (int)size;
                n = tableSizeFor(sz + (sz >>> 1) + 1);
            }
            int sc = sizeCtl;
            boolean collide = false;
            if (n > sc &&
                    SIZE_CTRL_UPDATER.compareAndSet(this, sc, -1)) {
                try {
                    if (table == null) {
                        init = true;
                        AtomicReferenceArray<Node> tab = new AtomicReferenceArray<Node>(n);
                        int mask = n - 1;
                        while (p != null) {
                            int j = p.hash & mask;
                            Node next = p.next;
                            Node q = p.next = tabAt(tab, j);
                            setTabAt(tab, j, p);
                            if (!collide && q != null && q.hash == p.hash)
                                collide = true;
                            p = next;
                        }
                        table = tab;
                        counter.add(size);
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                if (collide) { // rescan and convert to TreeBins
                    AtomicReferenceArray<Node> tab = table;
                    for (int i = 0; i < tab.length(); ++i) {
                        int c = 0;
                        for (Node e = tabAt(tab, i); e != null; e = e.next) {
                            if (++c > TREE_THRESHOLD &&
                                    (e.key instanceof Comparable)) {
                                replaceWithTreeBin(tab, i, e.key);
                                break;
                            }
                        }
                    }
                }
            }
            if (!init) { // Can only happen if unsafely published.
                while (p != null) {
                    internalPut(p.key, p.val);
                    p = p.next;
                }
            }
        }
    }


    // -------------------------------------------------------

    // Sams
    /** Interface describing a void action of one argument */
    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7429,"        public R getRawResult() { return null; }
        public boolean exec() { return true; }"
7430,"        public boolean exec() { return true; }
    }"
7431,"    public static <K> KeySetView<K,Boolean> newKeySet() {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(),
                Boolean.TRUE);"
7432,"    public static <K> KeySetView<K,Boolean> newKeySet(int initialCapacity) {
        return new KeySetView<K,Boolean>(new ConcurrentHashMapV8<K,Boolean>(initialCapacity),
                Boolean.TRUE);"
7433,"    public boolean isEmpty() {
        return counter.sum() <= 0L; // ignore transient negative values
    }"
7434,"    public int size() {
        long n = counter.sum();
        return ((n < 0L) ? 0 :
                (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :"
7435,"    public long mappingCount() {
        long n = counter.sum();
        return (n < 0L) ? 0L : n; // ignore transient negative values
    }"
7436,"    @SuppressWarnings(""unchecked"") public V get(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalGet(key);
    }"
7437,"    @SuppressWarnings(""unchecked"") public V getValueOrDefault(Object key, V defaultValue) {
        if (key == null)
            throw new NullPointerException();
        V v = (V) internalGet(key);
        return v == null ? defaultValue : v;
    }"
7438,"    public boolean containsKey(Object key) {
        if (key == null)
            throw new NullPointerException();
        return internalGet(key) != null;
    }"
7439,"    public boolean containsValue(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return true;
        }
        return false;
    }"
7440,"    public K findKey(Object value) {
        if (value == null)
            throw new NullPointerException();
        Object v;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        while ((v = it.advance()) != null) {
            if (v == value || value.equals(v))
                return it.nextKey;
        }
        return null;
    }"
7441,"    public boolean contains(Object value) {
        return containsValue(value);
    }"
7442,"    @SuppressWarnings(""unchecked"") public V put(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPut(key, value);
    }"
7443,"    @SuppressWarnings(""unchecked"") public V putIfAbsent(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalPutIfAbsent(key, value);
    }"
7444,"    public void putAll(Map<? extends K, ? extends V> m) {
        internalPutAll(m);
    }"
7445,"    @SuppressWarnings(""unchecked"") public V computeIfAbsent
    (K key, Fun<? super K, ? extends V> mappingFunction) {
        if (key == null || mappingFunction == null)
            throw new NullPointerException();
        return (V)internalComputeIfAbsent(key, mappingFunction);
    }"
7446,"    @SuppressWarnings(""unchecked"") public V computeIfPresent
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, true, remappingFunction);
    }"
7447,"    @SuppressWarnings(""unchecked"") public V compute
    (K key, BiFun<? super K, ? super V, ? extends V> remappingFunction) {
        if (key == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalCompute(key, false, remappingFunction);
    }"
7448,"    @SuppressWarnings(""unchecked"") public V merge
    (K key, V value, BiFun<? super V, ? super V, ? extends V> remappingFunction) {
        if (key == null || value == null || remappingFunction == null)
            throw new NullPointerException();
        return (V)internalMerge(key, value, remappingFunction);
    }"
7449,"    @SuppressWarnings(""unchecked"") public V remove(Object key) {
        if (key == null)
            throw new NullPointerException();
        return (V)internalReplace(key, null, null);
    }"
7450,"    public boolean remove(Object key, Object value) {
        if (key == null)
            throw new NullPointerException();
        if (value == null)
            return false;
        return internalReplace(key, null, value) != null;
    }"
7451,"    public boolean replace(K key, V oldValue, V newValue) {
        if (key == null || oldValue == null || newValue == null)
            throw new NullPointerException();
        return internalReplace(key, newValue, oldValue) != null;
    }"
7452,"    @SuppressWarnings(""unchecked"") public V replace(K key, V value) {
        if (key == null || value == null)
            throw new NullPointerException();
        return (V)internalReplace(key, value, null);
    }"
7453,"    public void clear() {
        internalClear();
    }"
7454,"    public KeySetView<K,V> keySet() {
        KeySetView<K,V> ks = keySet;
        return (ks != null) ? ks : (keySet = new KeySetView<K,V>(this, null));
    }"
7455,"    public KeySetView<K,V> keySet(V mappedValue) {
        if (mappedValue == null)
            throw new NullPointerException();
        return new KeySetView<K,V>(this, mappedValue);
    }"
7456,"    public ValuesView<K,V> values() {
        ValuesView<K,V> vs = values;
        return (vs != null) ? vs : (values = new ValuesView<K,V>(this));
    }"
7457,"    public Set<Map.Entry<K,V>> entrySet() {
        EntrySetView<K,V> es = entrySet;
        return (es != null) ? es : (entrySet = new EntrySetView<K,V>(this));
    }"
7458,"    public Enumeration<K> keys() {
        return new KeyIterator<K,V>(this);
    }"
7459,"    public Enumeration<V> elements() {
        return new ValueIterator<K,V>(this);
    }"
7460,"    public Spliterator<K> keySpliterator() {
        return new KeyIterator<K,V>(this);
    }"
7461,"    public Spliterator<V> valueSpliterator() {
        return new ValueIterator<K,V>(this);
    }"
7462,"    public Spliterator<Map.Entry<K,V>> entrySpliterator() {
        return new EntryIterator<K,V>(this);
    }"
7463,"    public int hashCode() {
        int h = 0;
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            h += it.nextKey.hashCode() ^ v.hashCode();
        }
        return h;
    }"
7464,"    public String toString() {
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        StringBuilder sb = new StringBuilder();
        sb.append('{');
        Object v;
        if ((v = it.advance()) != null) {
            for (;;) {
                Object k = it.nextKey;
                sb.append(k == this ? ""(this Map)"" : k);
                sb.append('=');
                sb.append(v == this ? ""(this Map)"" : v);
                if ((v = it.advance()) == null)
                    break;
                sb.append(',').append(' ');
            }
        }
        return sb.append('}').toString();
    }"
7465,"    public boolean equals(Object o) {
        if (o != this) {
            if (!(o instanceof Map))
                return false;
            Map<?,?> m = (Map<?,?>) o;
            Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
            Object val;
            while ((val = it.advance()) != null) {
                Object v = m.get(it.nextKey);
                if (v == null || (v != val && !v.equals(val)))
                    return false;
            }
            for (Map.Entry<?,?> e : m.entrySet()) {
                Object mk, mv, v;
                if ((mk = e.getKey()) == null ||
                        (mv = e.getValue()) == null ||
                        (v = internalGet(mk)) == null ||
                        (mv != v && !mv.equals(v)))
                    return false;
            }
        }
        return true;
    }"
7466,"        public KeyIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new KeyIterator<K,V>(this);
        }"
7467,"        @SuppressWarnings(""unchecked"") public final K next() {
            if (nextVal == null && advance() == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return (K) k;
        }"
7468,"        public final K nextElement() { return next(); }
    }"
7469,"        public ValueIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new ValueIterator<K,V>(this);
        }"
7470,"        @SuppressWarnings(""unchecked"") public final V next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            nextVal = null;
            return (V) v;
        }"
7471,"        public final V nextElement() { return next(); }
    }"
7472,"        public EntryIterator<K,V> split() {
            if (nextKey != null)
                throw new IllegalStateException();
            return new EntryIterator<K,V>(this);
        }"
7473,"        @SuppressWarnings(""unchecked"") public final Map.Entry<K,V> next() {
            Object v;
            if ((v = nextVal) == null && (v = advance()) == null)
                throw new NoSuchElementException();
            Object k = nextKey;
            nextVal = null;
            return new MapEntry<K,V>((K)k, (V)v, map);
        }"
7474,"        public final K getKey()       { return key; }
        public final V getValue()     { return val; }"
7475,"        public final V getValue()     { return val; }
        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }"
7476,"        public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
        public final String toString(){ return key + ""="" + val; }"
7477,"        public final String toString(){ return key + ""="" + val; }
"
7478,"        public final boolean equals(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7479,"        public final V setValue(V value) {
            if (value == null) throw new NullPointerException();
            V v = val;
            val = value;
            map.put(key, value);
            return v;
        }"
7480,"    @SuppressWarnings(""unchecked"") private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        if (segments == null) { // for serialization compatibility
            segments = (Segment<K,V>[])
                    new Segment<?,?>[DEFAULT_CONCURRENCY_LEVEL];
            for (int i = 0; i < segments.length; ++i)
                segments[i] = new Segment<K,V>(LOAD_FACTOR);
        }
        s.defaultWriteObject();
        Traverser<K,V,Object> it = new Traverser<K,V,Object>(this);
        Object v;
        while ((v = it.advance()) != null) {
            s.writeObject(it.nextKey);
            s.writeObject(v);
        }
        s.writeObject(null);
        s.writeObject(null);
        segments = null; // throw away
    }"
7481,"    @SuppressWarnings(""unchecked"") private void readObject(java.io.ObjectInputStream s)
            throws java.io.IOException, ClassNotFoundException {
        s.defaultReadObject();
        this.segments = null; // unneeded
        // initialize transient final field
        this.counter = new LongAdder();

        // Create all nodes, then place in table once size is known
        long size = 0L;
        Node p = null;
        for (;;) {
            K k = (K) s.readObject();
            V v = (V) s.readObject();
            if (k != null && v != null) {
                int h = spread(k.hashCode());
                p = new Node(h, k, v, p);
                ++size;
            }
            else
                break;
        }
        if (p != null) {
            boolean init = false;"
7482,"    public interface Action<A> { void apply(A a); }
    /** Interface describing a void action of two arguments */
    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7483,"    public interface BiAction<A,B> { void apply(A a, B b); }
    /** Interface describing a function of one argument */
    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7484,"    public interface Generator<T> { T apply(); }
    /** Interface describing a function mapping its argument to a double */
    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7485,"    public interface ObjectToDouble<A> { double apply(A a); }
    /** Interface describing a function mapping its argument to a long */
    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7486,"    public interface ObjectToLong<A> { long apply(A a); }
    /** Interface describing a function mapping its argument to an int */
    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7487,"    public interface ObjectToInt<A> {int apply(A a); }
    /** Interface describing a function mapping two arguments to a double */
    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7488,"    public interface ObjectByObjectToDouble<A,B> { double apply(A a, B b); }
    /** Interface describing a function mapping two arguments to a long */
    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7489,"    public interface ObjectByObjectToLong<A,B> { long apply(A a, B b); }
    /** Interface describing a function mapping two arguments to an int */
    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7490,"    public interface ObjectByObjectToInt<A,B> {int apply(A a, B b); }
    /** Interface describing a function mapping a double to a double */
    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7491,"    public interface DoubleToDouble { double apply(double a); }
    /** Interface describing a function mapping a long to a long */
    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7492,"    public interface LongToLong { long apply(long a); }
    /** Interface describing a function mapping an int to an int */
    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7493,"    public interface IntToInt { int apply(int a); }
    /** Interface describing a function mapping two doubles to a double */
    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7494,"    public interface DoubleByDoubleToDouble { double apply(double a, double b); }
    /** Interface describing a function mapping two longs to a long */
    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7495,"    public interface LongByLongToLong { long apply(long a, long b); }
    /** Interface describing a function mapping two ints to an int */
    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7496,"    public interface IntByIntToInt { int apply(int a, int b); }


    /* ----------------Views -------------- */

    /**
     * Base class for views.
     */
    static abstract class CHMView<K, V> {
        final ConcurrentHashMapV8<K, V> map;
        CHMView(ConcurrentHashMapV8<K, V> map)  { this.map = map; }

        /**
         * Returns the map backing this view.
         *
         * @return the map backing this view
         */
        public ConcurrentHashMapV8<K,V> getMap() { return map; }

        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }

        // implementations below rely on concrete classes supplying these
        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7497,"        public ConcurrentHashMapV8<K,V> getMap() { return map; }
"
7498,"        public final int size()                 { return map.size(); }
        public final boolean isEmpty()          { return map.isEmpty(); }"
7499,"        public final boolean isEmpty()          { return map.isEmpty(); }
        public final void clear()               { map.clear(); }"
7500,"        public final void clear()               { map.clear(); }
"
7501,"        abstract public Iterator<?> iterator();
        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7502,"        abstract public boolean contains(Object o);
        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7503,"        abstract public boolean remove(Object o);

        private static final String oomeMsg = ""Required array size too large"";

        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }

        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }

        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }

        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }

        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }

    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of keys, in
     * which additions may optionally be enabled by mapping to a
     * common value.  This class cannot be directly instantiated. See
     * {@link #keySet}, {@link #keySet(Object)}, {@link #newKeySet()},
     * {@link #newKeySet(int)}.
     */
    public static class KeySetView<K,V> extends CHMView<K,V> implements Set<K>, java.io.Serializable {
        private static final long serialVersionUID = 7249069246763182397L;
        private final V value;
        KeySetView(ConcurrentHashMapV8<K, V> map, V value) {  // non-public
            super(map);
            this.value = value;
        }

        /**
         * Returns the default mapped value for additions,
         * or {@code null} if additions are not supported.
         *
         * @return the default mapped value for additions, or {@code null}
         * if not supported.
         */
        public V getMappedValue() { return value; }

        // implement Set API

        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the keys of this map
         */
        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }
        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Collection} of
     * values, in which additions are disabled. This class cannot be
     * directly instantiated. See {@link #values},
     *
     * <p>The view's {@code iterator} is a ""weakly consistent"" iterator
     * that will never throw {@link ConcurrentModificationException},
     * and guarantees to traverse elements as they existed upon
     * construction of the iterator, and may (but is not guaranteed to)
     * reflect any modifications subsequent to construction.
     */
    public static final class ValuesView<K,V> extends CHMView<K,V>
            implements Collection<V> {
        ValuesView(ConcurrentHashMapV8<K, V> map)   { super(map); }
        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the values of this map
         */
        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }
        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }
        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }
    }

    /**
     * A view of a ConcurrentHashMapV8 as a {@link Set} of (key, value)
     * entries.  This class cannot be directly instantiated. See
     * {@link #entrySet}.
     */
    public static final class EntrySetView<K,V> extends CHMView<K,V>
            implements Set<Map.Entry<K,V>> {
        EntrySetView(ConcurrentHashMapV8<K, V> map) { super(map); }
        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (r = map.get(k)) != null &&
                    (v = e.getValue()) != null &&
                    (v == r || v.equals(r)));
        }
        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&
                    (v = e.getValue()) != null &&
                    map.remove(k, v));
        }

        /**
         * Returns a ""weakly consistent"" iterator that will never
         * throw {@link ConcurrentModificationException}, and
         * guarantees to traverse elements as they existed upon
         * construction of the iterator, and may (but is not
         * guaranteed to) reflect any modifications subsequent to
         * construction.
         *
         * @return an iterator over the entries of this map
         */
        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }

        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }
        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }
        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||
                            (containsAll(c) && c.containsAll(this))));
        }
    }
}"
7504,"        public final Object[] toArray() {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int n = (int)sz;
            Object[] r = new Object[n];
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = it.next();
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }"
7505,"        @SuppressWarnings(""unchecked"") public final <T> T[] toArray(T[] a) {
            long sz = map.mappingCount();
            if (sz > (long)(MAX_ARRAY_SIZE))
                throw new OutOfMemoryError(oomeMsg);
            int m = (int)sz;
            T[] r = (a.length >= m) ? a :
                    (T[])java.lang.reflect.Array
                            .newInstance(a.getClass().getComponentType(), m);
            int n = r.length;
            int i = 0;
            Iterator<?> it = iterator();
            while (it.hasNext()) {
                if (i == n) {
                    if (n >= MAX_ARRAY_SIZE)
                        throw new OutOfMemoryError(oomeMsg);
                    if (n >= MAX_ARRAY_SIZE - (MAX_ARRAY_SIZE >>> 1) - 1)
                        n = MAX_ARRAY_SIZE;
                    else
                        n += (n >>> 1) + 1;
                    r = Arrays.copyOf(r, n);
                }
                r[i++] = (T)it.next();
            }
            if (a == r && i < n) {
                r[i] = null; // null-terminate
                return r;
            }
            return (i == n) ? r : Arrays.copyOf(r, i);
        }"
7506,"        public final int hashCode() {
            int h = 0;
            for (Iterator<?> it = iterator(); it.hasNext();)
                h += it.next().hashCode();
            return h;
        }"
7507,"        public final String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            Iterator<?> it = iterator();
            if (it.hasNext()) {
                for (;;) {
                    Object e = it.next();
                    sb.append(e == this ? ""(this Collection)"" : e);
                    if (!it.hasNext())
                        break;
                    sb.append(',').append(' ');
                }
            }
            return sb.append(']').toString();
        }"
7508,"        public final boolean containsAll(Collection<?> c) {
            if (c != this) {
                for (Iterator<?> it = c.iterator(); it.hasNext();) {
                    Object e = it.next();
                    if (e == null || !contains(e))
                        return false;
                }
            }
            return true;
        }"
7509,"        public final boolean removeAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }"
7510,"        public final boolean retainAll(Collection<?> c) {
            boolean modified = false;
            for (Iterator<?> it = iterator(); it.hasNext();) {
                if (!c.contains(it.next())) {
                    it.remove();
                    modified = true;
                }
            }
            return modified;
        }"
7511,"        public V getMappedValue() { return value; }
"
7512,"        public boolean contains(Object o) { return map.containsKey(o); }
        public boolean remove(Object o)   { return map.remove(o) != null; }"
7513,"        public boolean remove(Object o)   { return map.remove(o) != null; }
"
7514,"        public Iterator<K> iterator()     { return new KeyIterator<K,V>(map); }
        public boolean add(K e) {"
7515,"        public boolean add(K e) {
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            if (e == null)
                throw new NullPointerException();
            return map.internalPutIfAbsent(e, v) == null;
        }"
7516,"        public boolean addAll(Collection<? extends K> c) {
            boolean added = false;
            V v;
            if ((v = value) == null)
                throw new UnsupportedOperationException();
            for (K e : c) {
                if (e == null)
                    throw new NullPointerException();
                if (map.internalPutIfAbsent(e, v) == null)
                    added = true;
            }
            return added;
        }"
7517,"        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||"
7518,"        public final boolean contains(Object o) { return map.containsValue(o); }
        public final boolean remove(Object o) {"
7519,"        public final boolean remove(Object o) {
            if (o != null) {
                Iterator<V> it = new ValueIterator<K,V>(map);
                while (it.hasNext()) {
                    if (o.equals(it.next())) {
                        it.remove();
                        return true;
                    }
                }
            }
            return false;
        }"
7520,"        public final Iterator<V> iterator() {
            return new ValueIterator<K,V>(map);
        }"
7521,"        public final boolean add(V e) {
            throw new UnsupportedOperationException();
        }"
7522,"        public final boolean addAll(Collection<? extends V> c) {
            throw new UnsupportedOperationException();
        }"
7523,"        public final boolean contains(Object o) {
            Object k, v, r; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7524,"        public final boolean remove(Object o) {
            Object k, v; Map.Entry<?,?> e;
            return ((o instanceof Map.Entry) &&
                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&"
7525,"        public final Iterator<Map.Entry<K,V>> iterator() {
            return new EntryIterator<K,V>(map);
        }"
7526,"        public final boolean add(Entry<K,V> e) {
            K key = e.getKey();
            V value = e.getValue();
            if (key == null || value == null)
                throw new NullPointerException();
            return map.internalPut(key, value) == null;
        }"
7527,"        public final boolean addAll(Collection<? extends Entry<K,V>> c) {
            boolean added = false;
            for (Entry<K,V> e : c) {
                if (add(e))
                    added = true;
            }
            return added;
        }"
7528,"        public boolean equals(Object o) {
            Set<?> c;
            return ((o instanceof Set) &&
                    ((c = (Set<?>)o) == this ||"
7529,"    final long fn(long v, long x) { return v + x; }
"
7530,"    public void add(long x) {
        Cell[] as; long b, v; HashCode hc; Cell a; int n;
        if ((as = cells) != null || !casBase(b = base, b + x)) {
            boolean uncontended = true;"
7531,"    public void increment() {
        add(1L);
    }"
7532,"    public void decrement() {
        add(-1L);
    }"
7533,"    public long sum() {
        long sum = base;
        Cell[] as = cells;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null)
                    sum += a.value;
            }
        }
        return sum;
    }"
7534,"    public void reset() {
        internalReset(0L);
    }"
7535,"    public long sumThenReset() {
        long sum = base;
        Cell[] as = cells;
        base = 0L;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null) {
                    sum += a.value;
                    a.value = 0L;
                }
            }
        }
        return sum;
    }"
7536,"    public String toString() {
        return Long.toString(sum());
    }"
7537,"    public long longValue() {
        return sum();
    }"
7538,"    public int intValue() {
        return (int)sum();
    }"
7539,"    public float floatValue() {
        return (float)sum();
    }"
7540,"    public double doubleValue() {
        return (double)sum();
    }"
7541,"    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        s.defaultWriteObject();
        s.writeLong(sum());
    }"
7542,"    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        busy = 0;
        cells = null;
        base = s.readLong();
    }"
7543,"        final boolean cas(long cmp, long val) {
            return VALUE_UPDATER.compareAndSet(this, cmp, val);
        }"
7544,"        public HashCode initialValue() { return new HashCode(); }
    }"
7545,"    final boolean casBase(long cmp, long val) {
        return BASE_UPDATER.compareAndSet(this, cmp, val);
    }"
7546,"    final boolean casBusy() {
        return BUSY_UPDATER.compareAndSet(this, 0, 1);
    }"
7547,"    abstract long fn(long currentValue, long newValue);

    /**
     * Handles cases of updates involving initialization, resizing,
     * creating new Cells, and/or contention. See above for
     * explanation. This method suffers the usual non-modularity
     * problems of optimistic retry code, relying on rechecked sets of
     * reads.
     *
     * @param x the value
     * @param hc the hash code holder
     * @param wasUncontended false if CAS failed before call
     */
    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {
                if ((a = as[(n - 1) & h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 && casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 && casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h << 13;                   // Rehash
                h ^= h >>> 17;
                h ^= h << 5;
            }
            else if (busy == 0 && cells == as && casBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }


    /**
     * Sets base and all cells to the given value.
     */
    final void internalReset(long initialValue) {
        Cell[] as = cells;
        base = initialValue;
        if (as != null) {
            int n = as.length;
            for (int i = 0; i < n; ++i) {
                Cell a = as[i];
                if (a != null)
                    a.value = initialValue;
            }
        }
    }
}"
7548,"    final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {
        int h = hc.code;
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            Cell[] as; Cell a; int n; long v;
            if ((as = cells) != null && (n = as.length) > 0) {
                if ((a = as[(n - 1) & h]) == null) {
                    if (busy == 0) {            // Try to attach new Cell
                        Cell r = new Cell(x);   // Optimistically create
                        if (busy == 0 && casBusy()) {
                            boolean created = false;
                            try {               // Recheck under lock
                                Cell[] rs; int m, j;
                                if ((rs = cells) != null &&
                                        (m = rs.length) > 0 &&
                                        rs[j = (m - 1) & h] == null) {
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                busy = 0;
                            }
                            if (created)
                                break;
                            continue;           // Slot is now non-empty
                        }
                    }
                    collide = false;
                }
                else if (!wasUncontended)       // CAS already known to fail
                    wasUncontended = true;      // Continue after rehash
                else if (a.cas(v = a.value, fn(v, x)))
                    break;
                else if (n >= NCPU || cells != as)
                    collide = false;            // At max size or stale
                else if (!collide)
                    collide = true;
                else if (busy == 0 && casBusy()) {
                    try {
                        if (cells == as) {      // Expand table unless stale
                            Cell[] rs = new Cell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            cells = rs;
                        }
                    } finally {
                        busy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                h ^= h << 13;                   // Rehash
                h ^= h >>> 17;
                h ^= h << 5;
            }
            else if (busy == 0 && cells == as && casBusy()) {
                boolean init = false;
                try {                           // Initialize table
                    if (cells == as) {
                        Cell[] rs = new Cell[2];
                        rs[h & 1] = new Cell(x);
                        cells = rs;
                        init = true;
                    }
                } finally {
                    busy = 0;
                }
                if (init)
                    break;
            }
            else if (casBase(v = base, fn(v, x)))
                break;                          // Fall back on using base
        }
        hc.code = h;                            // Record index for next time
    }"
7549,"    final void internalReset(long initialValue) {
        Cell[] as = cells;
        base = initialValue;
        if (as != null) {
            int n = as.length;"
7550,"            protected ThreadLocalRandom initialValue() {
                return new ThreadLocalRandom();
            }"
7551,"    public static ThreadLocalRandom current() {
        return localRandom.get();
    }"
7552,"    public void setSeed(long seed) {
        if (initialized)
            throw new UnsupportedOperationException();
        rnd = (seed ^ multiplier) & mask;
    }"
7553,"    protected int next(int bits) {
        rnd = (rnd * multiplier + addend) & mask;
        return (int) (rnd >>> (48-bits));
    }"
7554,"    public int nextInt(int least, int bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextInt(bound - least) + least;
    }"
7555,"    public long nextLong(long n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        // Divide n by two until small enough for nextInt. On each
        // iteration (at most 31 of them but usually much less),
        // randomly choose both whether to include high bit in result
        // (offset) and whether to continue with the lower vs upper
        // half (which makes a difference only if odd).
        long offset = 0;
        while (n >= Integer.MAX_VALUE) {
            int bits = next(2);
            long half = n >>> 1;
            long nextn = ((bits & 2) == 0) ? half : n - half;
            if ((bits & 1) == 0)
                offset += n - nextn;
            n = nextn;
        }
        return offset + nextInt((int) n);
    }"
7556,"    public long nextLong(long least, long bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextLong(bound - least) + least;
    }"
7557,"    public double nextDouble(double n) {
        if (n <= 0)
            throw new IllegalArgumentException(""n must be positive"");
        return nextDouble() * n;
    }"
7558,"    public double nextDouble(double least, double bound) {
        if (least >= bound)
            throw new IllegalArgumentException();
        return nextDouble() * (bound - least) + least;
    }"
